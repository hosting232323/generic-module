(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode('.sup-container[data-v-8abb3880]{display:flex;align-items:center;justify-content:center;visibility:hidden;position:fixed;right:15px;width:40px;height:40px;background-color:#eeec;border-radius:100%;z-index:999;cursor:pointer}.visible[data-v-8abb3880]{visibility:visible}.shadown[data-v-8abb3880]{box-shadow:0 4px 4px #0003;transition:box-shadow 225ms}.shadown[data-v-8abb3880]:hover{box-shadow:0 10px 14px #0003}.v-autocomplete--chips.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,.v-autocomplete--chips.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,.v-autocomplete--chips.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,.v-autocomplete--chips.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating{top:0}.v-autocomplete .v-field .v-text-field__prefix,.v-autocomplete .v-field .v-text-field__suffix,.v-autocomplete .v-field .v-field__input,.v-autocomplete .v-field.v-field{cursor:text}.v-autocomplete .v-field .v-field__input>input{flex:1 1}.v-autocomplete .v-field input{min-width:64px}.v-autocomplete .v-field:not(.v-field--focused) input{min-width:0}.v-autocomplete .v-field--dirty .v-autocomplete__selection{margin-inline-end:2px}.v-autocomplete .v-autocomplete__selection-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.v-autocomplete__content{overflow:hidden}.v-autocomplete__content{box-shadow:0 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 4px 5px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 10px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-autocomplete__content{border-radius:4px}.v-autocomplete__mask{background:rgb(var(--v-theme-surface-light))}.v-autocomplete__selection{display:inline-flex;align-items:center;height:1.5rem;letter-spacing:inherit;line-height:inherit;max-width:calc(100% - 4px)}.v-autocomplete__selection:first-child{margin-inline-start:0}.v-autocomplete--selecting-index .v-autocomplete__selection{opacity:var(--v-medium-emphasis-opacity)}.v-autocomplete--selecting-index .v-autocomplete__selection--selected{opacity:1}.v-autocomplete--selecting-index .v-field__input>input{caret-color:transparent}.v-autocomplete--single:not(.v-autocomplete--selection-slot).v-text-field input{flex:1 1;position:absolute;left:0;right:0;width:100%;padding-inline:inherit}.v-autocomplete--single:not(.v-autocomplete--selection-slot) .v-field--active input{transition:none}.v-autocomplete--single:not(.v-autocomplete--selection-slot) .v-field--dirty:not(.v-field--focused) input{opacity:0}.v-autocomplete--single:not(.v-autocomplete--selection-slot) .v-field--focused .v-autocomplete__selection{opacity:0}.v-autocomplete__menu-icon{margin-inline-start:4px;transition:.2s cubic-bezier(.4,0,.2,1)}.v-autocomplete--active-menu .v-autocomplete__menu-icon{transform:rotate(180deg)}.v-avatar{flex:none;align-items:center;display:inline-flex;justify-content:center;line-height:normal;overflow:hidden;position:relative;text-align:center;transition:.2s cubic-bezier(.4,0,.2,1);transition-property:width,height;vertical-align:middle}.v-avatar.v-avatar--size-x-small{--v-avatar-height: 24px}.v-avatar.v-avatar--size-small{--v-avatar-height: 32px}.v-avatar.v-avatar--size-default{--v-avatar-height: 40px}.v-avatar.v-avatar--size-large{--v-avatar-height: 48px}.v-avatar.v-avatar--size-x-large{--v-avatar-height: 56px}.v-avatar.v-avatar--density-default{height:calc(var(--v-avatar-height) + 0px);width:calc(var(--v-avatar-height) + 0px)}.v-avatar.v-avatar--density-comfortable{height:calc(var(--v-avatar-height) + -4px);width:calc(var(--v-avatar-height) + -4px)}.v-avatar.v-avatar--density-compact{height:calc(var(--v-avatar-height) + -8px);width:calc(var(--v-avatar-height) + -8px)}.v-avatar{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-avatar--border{border-width:thin;box-shadow:none}.v-avatar{border-radius:50%}.v-avatar--variant-plain,.v-avatar--variant-outlined,.v-avatar--variant-text,.v-avatar--variant-tonal{background:transparent;color:inherit}.v-avatar--variant-plain{opacity:.62}.v-avatar--variant-plain:focus,.v-avatar--variant-plain:hover{opacity:1}.v-avatar--variant-plain .v-avatar__overlay{display:none}.v-avatar--variant-elevated,.v-avatar--variant-flat{background:var(--v-theme-surface);color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity))}.v-avatar--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 3px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-avatar--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-avatar--variant-outlined{border:thin solid currentColor}.v-avatar--variant-text .v-avatar__overlay{background:currentColor}.v-avatar--variant-tonal .v-avatar__underlay{background:currentColor;opacity:var(--v-activated-opacity);border-radius:inherit;top:0;right:0;bottom:0;left:0;pointer-events:none}.v-avatar .v-avatar__underlay{position:absolute}.v-avatar--rounded{border-radius:4px}.v-avatar--start{margin-inline-end:8px}.v-avatar--end{margin-inline-start:8px}.v-avatar .v-img{height:100%;width:100%}.v-icon{--v-icon-size-multiplier: 1;align-items:center;display:inline-flex;font-feature-settings:"liga";height:1em;justify-content:center;letter-spacing:normal;line-height:1;position:relative;opacity:var(--v-icon-opacity, 1);text-indent:0;text-align:center;-webkit-user-select:none;user-select:none;vertical-align:middle;width:1em;min-width:1em}.v-icon--clickable{cursor:pointer}.v-icon--disabled{pointer-events:none;opacity:.38}.v-icon--size-x-small{font-size:calc(var(--v-icon-size-multiplier) * 1em)}.v-icon--size-small{font-size:calc(var(--v-icon-size-multiplier) * 1.25em)}.v-icon--size-default{font-size:calc(var(--v-icon-size-multiplier) * 1.5em)}.v-icon--size-large{font-size:calc(var(--v-icon-size-multiplier) * 1.75em)}.v-icon--size-x-large{font-size:calc(var(--v-icon-size-multiplier) * 2em)}.v-icon__svg{fill:currentColor;width:100%;height:100%}.v-icon--start{margin-inline-end:8px}.v-icon--end{margin-inline-start:8px}.v-img{--v-theme-overlay-multiplier: 3;z-index:0}.v-img.v-img--absolute{height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:-1}.v-img--booting .v-responsive__sizer{transition:none}.v-img--rounded{border-radius:4px}.v-img__img,.v-img__picture,.v-img__gradient,.v-img__placeholder,.v-img__error{z-index:-1}.v-img__img,.v-img__picture,.v-img__gradient,.v-img__placeholder,.v-img__error{position:absolute;top:0;left:0;width:100%;height:100%}.v-img__img--preload{filter:blur(4px)}.v-img__img--contain{object-fit:contain}.v-img__img--cover{object-fit:cover}.v-img__gradient{background-repeat:no-repeat}.v-responsive{display:flex;flex:1 0 auto;max-height:100%;max-width:100%;overflow:hidden;position:relative}.v-responsive--inline{display:inline-flex;flex:0 0 auto}.v-responsive__content{flex:1 0 0px;max-width:100%}.v-responsive__sizer~.v-responsive__content{margin-inline-start:-100%}.v-responsive__sizer{flex:1 0 0px;transition:padding-bottom .2s cubic-bezier(.4,0,.2,1);pointer-events:none}.v-selection-control{align-items:center;contain:layout;display:flex;flex:1 0;grid-area:control;position:relative;-webkit-user-select:none;user-select:none}.v-selection-control .v-label{white-space:normal;word-break:break-word;height:100%;opacity:1}.v-selection-control--disabled{opacity:var(--v-disabled-opacity);pointer-events:none}.v-selection-control--error:not(.v-selection-control--disabled) .v-label{color:rgb(var(--v-theme-error))}.v-selection-control--inline{display:inline-flex;flex:0 0 auto;min-width:0;max-width:100%}.v-selection-control--inline .v-label{width:auto}.v-selection-control--density-default{--v-selection-control-size: 40px}.v-selection-control--density-comfortable{--v-selection-control-size: 36px}.v-selection-control--density-compact{--v-selection-control-size: 28px}.v-selection-control__wrapper{width:var(--v-selection-control-size);height:var(--v-selection-control-size);display:inline-flex;align-items:center;position:relative;justify-content:center;flex:none}.v-selection-control__input{width:var(--v-selection-control-size);height:var(--v-selection-control-size);align-items:center;display:flex;flex:none;justify-content:center;position:relative;border-radius:50%}.v-selection-control__input input{cursor:pointer;position:absolute;left:0;top:0;width:100%;height:100%;opacity:0}.v-selection-control__input:before{border-radius:100%;background-color:currentColor;opacity:0;pointer-events:none}.v-selection-control__input:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%}.v-selection-control__input:hover:before{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-selection-control__input>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-selection-control--disabled .v-selection-control__input>.v-icon,.v-selection-control--dirty .v-selection-control__input>.v-icon,.v-selection-control--error .v-selection-control__input>.v-icon{opacity:1}.v-selection-control--error:not(.v-selection-control--disabled) .v-selection-control__input>.v-icon{color:rgb(var(--v-theme-error))}.v-selection-control--focus-visible .v-selection-control__input:before{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}.v-label{align-items:center;color:inherit;display:inline-flex;font-size:1rem;letter-spacing:.009375em;min-width:0;opacity:var(--v-medium-emphasis-opacity);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.v-label--clickable{cursor:pointer}.v-selection-control-group{grid-area:control;display:flex;flex-direction:column}.v-selection-control-group--inline{flex-direction:row;flex-wrap:wrap}.v-ripple__container{color:inherit;border-radius:inherit;position:absolute;width:100%;height:100%;left:0;top:0;overflow:hidden;z-index:0;pointer-events:none;contain:strict}.v-ripple__animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;background:currentColor;opacity:0;pointer-events:none;overflow:hidden;will-change:transform,opacity}.v-ripple__animation--enter{transition:none;opacity:0}.v-ripple__animation--in{transition:transform .25s cubic-bezier(0,0,.2,1),opacity .1s cubic-bezier(0,0,.2,1);opacity:calc(.25 * var(--v-theme-overlay-multiplier))}.v-ripple__animation--out{transition:opacity .3s cubic-bezier(0,0,.2,1);opacity:0}.v-input{display:grid;flex:1 1 auto;font-size:1rem;font-weight:400;line-height:1.5}.v-input--disabled{pointer-events:none}.v-input--density-default{--v-input-control-height: 56px;--v-input-padding-top: 16px}.v-input--density-comfortable{--v-input-control-height: 48px;--v-input-padding-top: 12px}.v-input--density-compact{--v-input-control-height: 40px;--v-input-padding-top: 8px}.v-input--vertical{grid-template-areas:"append" "control" "prepend";grid-template-rows:max-content auto max-content;grid-template-columns:min-content}.v-input--vertical .v-input__prepend{margin-block-start:16px}.v-input--vertical .v-input__append{margin-block-end:16px}.v-input--horizontal{grid-template-areas:"prepend control append" "a messages b";grid-template-columns:max-content minmax(0,1fr) max-content;grid-template-rows:1fr auto}.v-input--horizontal .v-input__prepend{margin-inline-end:16px}.v-input--horizontal .v-input__append{margin-inline-start:16px}.v-input__details{align-items:flex-end;display:flex;font-size:.75rem;font-weight:400;grid-area:messages;letter-spacing:.0333333333em;line-height:normal;min-height:22px;padding-top:6px;overflow:hidden;justify-content:space-between}.v-input__details>.v-icon,.v-input__prepend>.v-icon,.v-input__append>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-input--disabled .v-input__details>.v-icon,.v-input--disabled .v-input__details .v-messages,.v-input--error .v-input__details>.v-icon,.v-input--error .v-input__details .v-messages,.v-input--disabled .v-input__prepend>.v-icon,.v-input--disabled .v-input__prepend .v-messages,.v-input--error .v-input__prepend>.v-icon,.v-input--error .v-input__prepend .v-messages,.v-input--disabled .v-input__append>.v-icon,.v-input--disabled .v-input__append .v-messages,.v-input--error .v-input__append>.v-icon,.v-input--error .v-input__append .v-messages{opacity:1}.v-input--glow.v-input--focused .v-input__details>.v-icon,.v-input--glow.v-input--focused .v-input__prepend>.v-icon,.v-input--glow.v-input--focused .v-input__append>.v-icon{opacity:1}.v-input--disabled .v-input__details,.v-input--disabled .v-input__prepend,.v-input--disabled .v-input__append{opacity:var(--v-disabled-opacity)}.v-input--error:not(.v-input--disabled) .v-input__details>.v-icon,.v-input--error:not(.v-input--disabled) .v-input__details .v-messages,.v-input--error:not(.v-input--disabled) .v-input__prepend>.v-icon,.v-input--error:not(.v-input--disabled) .v-input__prepend .v-messages,.v-input--error:not(.v-input--disabled) .v-input__append>.v-icon,.v-input--error:not(.v-input--disabled) .v-input__append .v-messages{color:rgb(var(--v-theme-error))}.v-input__prepend,.v-input__append{display:flex;align-items:flex-start;padding-top:var(--v-input-padding-top)}.v-input--center-affix .v-input__prepend,.v-input--center-affix .v-input__append{align-items:center;padding-top:0}.v-input__prepend{grid-area:prepend}.v-input__append{grid-area:append}.v-input__control{display:flex;grid-area:control}.v-input--hide-spin-buttons input::-webkit-outer-spin-button,.v-input--hide-spin-buttons input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}.v-input--hide-spin-buttons input[type=number]{-moz-appearance:textfield}.v-input--plain-underlined .v-input__prepend,.v-input--plain-underlined .v-input__append{align-items:flex-start}.v-input--density-default.v-input--plain-underlined .v-input__prepend,.v-input--density-default.v-input--plain-underlined .v-input__append{padding-top:calc(var(--v-input-padding-top) + 4px)}.v-input--density-comfortable.v-input--plain-underlined .v-input__prepend,.v-input--density-comfortable.v-input--plain-underlined .v-input__append{padding-top:calc(var(--v-input-padding-top) + 2px)}.v-input--density-compact.v-input--plain-underlined .v-input__prepend,.v-input--density-compact.v-input--plain-underlined .v-input__append{padding-top:calc(var(--v-input-padding-top) + 0px)}.v-messages{flex:1 1 auto;font-size:12px;min-height:14px;min-width:1px;opacity:var(--v-medium-emphasis-opacity);position:relative}.v-messages__message{line-height:12px;word-break:break-word;overflow-wrap:break-word;word-wrap:break-word;-webkit-hyphens:auto;hyphens:auto;transition-duration:.15s}.v-chip{align-items:center;display:inline-flex;font-weight:400;max-width:100%;min-width:0;overflow:hidden;position:relative;text-decoration:none;white-space:nowrap;vertical-align:middle}.v-chip .v-icon{--v-icon-size-multiplier: .8571428571}.v-chip.v-chip--size-x-small{--v-chip-size: .625rem;--v-chip-height: 20px;font-size:.625rem;padding:0 8px}.v-chip.v-chip--size-x-small .v-avatar{--v-avatar-height: 14px}.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar{--v-avatar-height: 20px}.v-chip.v-chip--size-x-small .v-avatar--start{margin-inline-start:-5.6px;margin-inline-end:4px}.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar--start{margin-inline-start:-8px}.v-chip.v-chip--size-x-small .v-avatar--end{margin-inline-start:4px;margin-inline-end:-5.6px}.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar--end{margin-inline-end:-8px}.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar--end+.v-chip__close{margin-inline-start:12px}.v-chip.v-chip--size-x-small .v-icon--start,.v-chip.v-chip--size-x-small .v-chip__filter{margin-inline-start:-4px;margin-inline-end:4px}.v-chip.v-chip--size-x-small .v-icon--end,.v-chip.v-chip--size-x-small .v-chip__close{margin-inline-start:4px;margin-inline-end:-4px}.v-chip.v-chip--size-x-small .v-icon--end+.v-chip__close,.v-chip.v-chip--size-x-small .v-avatar--end+.v-chip__close,.v-chip.v-chip--size-x-small .v-chip__append+.v-chip__close{margin-inline-start:8px}.v-chip.v-chip--size-small{--v-chip-size: .75rem;--v-chip-height: 26px;font-size:.75rem;padding:0 10px}.v-chip.v-chip--size-small .v-avatar{--v-avatar-height: 20px}.v-chip--pill.v-chip.v-chip--size-small .v-avatar{--v-avatar-height: 26px}.v-chip.v-chip--size-small .v-avatar--start{margin-inline-start:-7px;margin-inline-end:5px}.v-chip--pill.v-chip.v-chip--size-small .v-avatar--start{margin-inline-start:-10px}.v-chip.v-chip--size-small .v-avatar--end{margin-inline-start:5px;margin-inline-end:-7px}.v-chip--pill.v-chip.v-chip--size-small .v-avatar--end{margin-inline-end:-10px}.v-chip--pill.v-chip.v-chip--size-small .v-avatar--end+.v-chip__close{margin-inline-start:15px}.v-chip.v-chip--size-small .v-icon--start,.v-chip.v-chip--size-small .v-chip__filter{margin-inline-start:-5px;margin-inline-end:5px}.v-chip.v-chip--size-small .v-icon--end,.v-chip.v-chip--size-small .v-chip__close{margin-inline-start:5px;margin-inline-end:-5px}.v-chip.v-chip--size-small .v-icon--end+.v-chip__close,.v-chip.v-chip--size-small .v-avatar--end+.v-chip__close,.v-chip.v-chip--size-small .v-chip__append+.v-chip__close{margin-inline-start:10px}.v-chip.v-chip--size-default{--v-chip-size: .875rem;--v-chip-height: 32px;font-size:.875rem;padding:0 12px}.v-chip.v-chip--size-default .v-avatar{--v-avatar-height: 26px}.v-chip--pill.v-chip.v-chip--size-default .v-avatar{--v-avatar-height: 32px}.v-chip.v-chip--size-default .v-avatar--start{margin-inline-start:-8.4px;margin-inline-end:6px}.v-chip--pill.v-chip.v-chip--size-default .v-avatar--start{margin-inline-start:-12px}.v-chip.v-chip--size-default .v-avatar--end{margin-inline-start:6px;margin-inline-end:-8.4px}.v-chip--pill.v-chip.v-chip--size-default .v-avatar--end{margin-inline-end:-12px}.v-chip--pill.v-chip.v-chip--size-default .v-avatar--end+.v-chip__close{margin-inline-start:18px}.v-chip.v-chip--size-default .v-icon--start,.v-chip.v-chip--size-default .v-chip__filter{margin-inline-start:-6px;margin-inline-end:6px}.v-chip.v-chip--size-default .v-icon--end,.v-chip.v-chip--size-default .v-chip__close{margin-inline-start:6px;margin-inline-end:-6px}.v-chip.v-chip--size-default .v-icon--end+.v-chip__close,.v-chip.v-chip--size-default .v-avatar--end+.v-chip__close,.v-chip.v-chip--size-default .v-chip__append+.v-chip__close{margin-inline-start:12px}.v-chip.v-chip--size-large{--v-chip-size: 1rem;--v-chip-height: 38px;font-size:1rem;padding:0 14px}.v-chip.v-chip--size-large .v-avatar{--v-avatar-height: 32px}.v-chip--pill.v-chip.v-chip--size-large .v-avatar{--v-avatar-height: 38px}.v-chip.v-chip--size-large .v-avatar--start{margin-inline-start:-9.8px;margin-inline-end:7px}.v-chip--pill.v-chip.v-chip--size-large .v-avatar--start{margin-inline-start:-14px}.v-chip.v-chip--size-large .v-avatar--end{margin-inline-start:7px;margin-inline-end:-9.8px}.v-chip--pill.v-chip.v-chip--size-large .v-avatar--end{margin-inline-end:-14px}.v-chip--pill.v-chip.v-chip--size-large .v-avatar--end+.v-chip__close{margin-inline-start:21px}.v-chip.v-chip--size-large .v-icon--start,.v-chip.v-chip--size-large .v-chip__filter{margin-inline-start:-7px;margin-inline-end:7px}.v-chip.v-chip--size-large .v-icon--end,.v-chip.v-chip--size-large .v-chip__close{margin-inline-start:7px;margin-inline-end:-7px}.v-chip.v-chip--size-large .v-icon--end+.v-chip__close,.v-chip.v-chip--size-large .v-avatar--end+.v-chip__close,.v-chip.v-chip--size-large .v-chip__append+.v-chip__close{margin-inline-start:14px}.v-chip.v-chip--size-x-large{--v-chip-size: 1.125rem;--v-chip-height: 44px;font-size:1.125rem;padding:0 17px}.v-chip.v-chip--size-x-large .v-avatar{--v-avatar-height: 38px}.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar{--v-avatar-height: 44px}.v-chip.v-chip--size-x-large .v-avatar--start{margin-inline-start:-11.9px;margin-inline-end:8.5px}.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar--start{margin-inline-start:-17px}.v-chip.v-chip--size-x-large .v-avatar--end{margin-inline-start:8.5px;margin-inline-end:-11.9px}.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar--end{margin-inline-end:-17px}.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar--end+.v-chip__close{margin-inline-start:25.5px}.v-chip.v-chip--size-x-large .v-icon--start,.v-chip.v-chip--size-x-large .v-chip__filter{margin-inline-start:-8.5px;margin-inline-end:8.5px}.v-chip.v-chip--size-x-large .v-icon--end,.v-chip.v-chip--size-x-large .v-chip__close{margin-inline-start:8.5px;margin-inline-end:-8.5px}.v-chip.v-chip--size-x-large .v-icon--end+.v-chip__close,.v-chip.v-chip--size-x-large .v-avatar--end+.v-chip__close,.v-chip.v-chip--size-x-large .v-chip__append+.v-chip__close{margin-inline-start:17px}.v-chip.v-chip--density-default{height:calc(var(--v-chip-height) + 0px)}.v-chip.v-chip--density-comfortable{height:calc(var(--v-chip-height) + -4px)}.v-chip.v-chip--density-compact{height:calc(var(--v-chip-height) + -8px)}.v-chip{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-chip:hover>.v-chip__overlay{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-chip:focus-visible>.v-chip__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-chip:focus>.v-chip__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}}.v-chip--active>.v-chip__overlay,.v-chip[aria-haspopup=menu][aria-expanded=true]>.v-chip__overlay{opacity:calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier))}.v-chip--active:hover>.v-chip__overlay,.v-chip[aria-haspopup=menu][aria-expanded=true]:hover>.v-chip__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}.v-chip--active:focus-visible>.v-chip__overlay,.v-chip[aria-haspopup=menu][aria-expanded=true]:focus-visible>.v-chip__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-chip--active:focus>.v-chip__overlay,.v-chip[aria-haspopup=menu][aria-expanded=true]:focus>.v-chip__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}}.v-chip{border-radius:9999px}.v-chip--variant-plain,.v-chip--variant-outlined,.v-chip--variant-text,.v-chip--variant-tonal{background:transparent;color:inherit}.v-chip--variant-plain{opacity:.26}.v-chip--variant-plain:focus,.v-chip--variant-plain:hover{opacity:1}.v-chip--variant-plain .v-chip__overlay{display:none}.v-chip--variant-elevated,.v-chip--variant-flat{background:rgb(var(--v-theme-surface-variant));color:rgb(var(--v-theme-on-surface-variant))}.v-chip--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 3px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-chip--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-chip--variant-outlined{border:thin solid currentColor}.v-chip--variant-text .v-chip__overlay{background:currentColor}.v-chip--variant-tonal .v-chip__underlay{background:currentColor;opacity:var(--v-activated-opacity);border-radius:inherit;top:0;right:0;bottom:0;left:0;pointer-events:none}.v-chip .v-chip__underlay{position:absolute}.v-chip--border{border-width:thin}.v-chip--link{cursor:pointer}.v-chip--link,.v-chip--filter{-webkit-user-select:none;user-select:none}.v-chip__content{align-items:center;display:inline-flex}.v-autocomplete__selection .v-chip__content,.v-combobox__selection .v-chip__content,.v-select__selection .v-chip__content{overflow:hidden}.v-chip__filter,.v-chip__prepend,.v-chip__append,.v-chip__close{align-items:center;display:inline-flex}.v-chip__close{cursor:pointer;flex:0 1 auto;font-size:18px;max-height:18px;max-width:18px;-webkit-user-select:none;user-select:none}.v-chip__close .v-icon{font-size:inherit}.v-chip__filter{transition:.15s cubic-bezier(.4,0,.2,1)}.v-chip__overlay{background-color:currentColor;border-radius:inherit;pointer-events:none;opacity:0;transition:opacity .2s ease-in-out}.v-chip__overlay{position:absolute;top:0;left:0;width:100%;height:100%}.v-chip--disabled{opacity:.3;pointer-events:none;-webkit-user-select:none;user-select:none}.v-chip--label{border-radius:4px}.v-chip-group{display:flex;max-width:100%;min-width:0;overflow-x:auto;padding:4px 0}.v-chip-group .v-chip{margin:4px 8px 4px 0}.v-chip-group .v-chip.v-chip--selected:not(.v-chip--disabled) .v-chip__overlay{opacity:var(--v-activated-opacity)}.v-chip-group--column .v-slide-group__content{white-space:normal;flex-wrap:wrap;max-width:100%}.v-slide-group{display:flex;overflow:hidden}.v-slide-group__next,.v-slide-group__prev{align-items:center;display:flex;flex:0 1 52px;justify-content:center;min-width:52px;cursor:pointer}.v-slide-group__next--disabled,.v-slide-group__prev--disabled{pointer-events:none;opacity:var(--v-disabled-opacity)}.v-slide-group__content{display:flex;flex:1 0 auto;position:relative;transition:.2s all cubic-bezier(.4,0,.2,1);white-space:nowrap}.v-slide-group__content>*{white-space:initial}.v-slide-group__container{contain:content;display:flex;flex:1 1 auto;overflow-x:auto;overflow-y:hidden;scrollbar-width:none;scrollbar-color:rgba(0,0,0,0)}.v-slide-group__container::-webkit-scrollbar{display:none}.v-slide-group--vertical{max-height:inherit}.v-slide-group--vertical,.v-slide-group--vertical .v-slide-group__container,.v-slide-group--vertical .v-slide-group__content{flex-direction:column}.v-slide-group--vertical .v-slide-group__container{overflow-x:hidden;overflow-y:auto}.v-divider{display:block;flex:1 1 100%;height:0px;max-height:0px;opacity:var(--v-border-opacity);transition:inherit}.v-divider{border-style:solid;border-width:thin 0 0 0}.v-divider--vertical{align-self:stretch;border-width:0 thin 0 0;display:inline-flex;height:auto;margin-left:-1px;max-height:100%;max-width:0px;vertical-align:text-bottom;width:0px}.v-divider--inset:not(.v-divider--vertical){max-width:calc(100% - 72px);margin-inline-start:72px}.v-divider--inset.v-divider--vertical{margin-bottom:8px;margin-top:8px;max-height:calc(100% - 16px)}.v-divider__content{padding:0 16px;text-wrap:nowrap}.v-divider__wrapper--vertical .v-divider__content{padding:4px 0}.v-divider__wrapper{display:flex;align-items:center;justify-content:center}.v-divider__wrapper--vertical{flex-direction:column;height:100%}.v-divider__wrapper--vertical .v-divider{margin:0 auto}.v-list{overflow:auto;padding:8px 0;position:relative;outline:none}.v-list{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-list--border{border-width:thin;box-shadow:none}.v-list{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-list{border-radius:0}.v-list{background:rgba(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-list--disabled{pointer-events:none;-webkit-user-select:none;user-select:none}.v-list--nav{padding-inline:8px}.v-list--rounded{border-radius:4px}.v-list--subheader{padding-top:0}.v-list-img{border-radius:inherit;display:flex;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:-1}.v-list-subheader{align-items:center;background:inherit;color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity));display:flex;font-size:.875rem;font-weight:400;line-height:1.375rem;padding-inline-end:16px;min-height:40px;transition:.2s min-height cubic-bezier(.4,0,.2,1)}.v-list-subheader__text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.v-list--density-default .v-list-subheader{min-height:40px;padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list--density-comfortable .v-list-subheader{min-height:36px;padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list--density-compact .v-list-subheader{min-height:32px;padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list-subheader--inset{--indent-padding: 56px}.v-list--nav .v-list-subheader{font-size:.75rem}.v-list-subheader--sticky{background:inherit;left:0;position:sticky;top:0;z-index:1}.v-list__overlay{background-color:currentColor;border-radius:inherit;bottom:0;left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:opacity .2s ease-in-out}.v-list-item{align-items:center;display:grid;flex:none;grid-template-areas:"prepend content append";grid-template-columns:max-content 1fr auto;outline:none;max-width:100%;padding:4px 16px;position:relative;text-decoration:none}.v-list-item{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-list-item--border{border-width:thin;box-shadow:none}.v-list-item:hover>.v-list-item__overlay{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-list-item:focus-visible>.v-list-item__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-list-item:focus>.v-list-item__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}}.v-list-item--active>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]>.v-list-item__overlay{opacity:calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier))}.v-list-item--active:hover>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]:hover>.v-list-item__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}.v-list-item--active:focus-visible>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]:focus-visible>.v-list-item__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-list-item--active:focus>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]:focus>.v-list-item__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}}.v-list-item{border-radius:0}.v-list-item--variant-plain,.v-list-item--variant-outlined,.v-list-item--variant-text,.v-list-item--variant-tonal{background:transparent;color:inherit}.v-list-item--variant-plain{opacity:.62}.v-list-item--variant-plain:focus,.v-list-item--variant-plain:hover{opacity:1}.v-list-item--variant-plain .v-list-item__overlay{display:none}.v-list-item--variant-elevated,.v-list-item--variant-flat{background:rgba(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-list-item--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 3px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-list-item--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-list-item--variant-outlined{border:thin solid currentColor}.v-list-item--variant-text .v-list-item__overlay{background:currentColor}.v-list-item--variant-tonal .v-list-item__underlay{background:currentColor;opacity:var(--v-activated-opacity);border-radius:inherit;top:0;right:0;bottom:0;left:0;pointer-events:none}.v-list-item .v-list-item__underlay{position:absolute}@supports selector(:focus-visible){.v-list-item:after{pointer-events:none;border:2px solid currentColor;border-radius:4px;opacity:0;transition:opacity .2s ease-in-out}.v-list-item:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%}.v-list-item:focus-visible:after{opacity:calc(.15 * var(--v-theme-overlay-multiplier))}}.v-list-item__prepend>.v-badge .v-icon,.v-list-item__prepend>.v-icon,.v-list-item__append>.v-badge .v-icon,.v-list-item__append>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-list-item--active .v-list-item__prepend>.v-badge .v-icon,.v-list-item--active .v-list-item__prepend>.v-icon,.v-list-item--active .v-list-item__append>.v-badge .v-icon,.v-list-item--active .v-list-item__append>.v-icon{opacity:1}.v-list-item--active:not(.v-list-item--link) .v-list-item__overlay{opacity:calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier))}.v-list-item--rounded{border-radius:4px}.v-list-item--disabled{pointer-events:none;-webkit-user-select:none;user-select:none;opacity:.6}.v-list-item--link{cursor:pointer}.v-navigation-drawer--rail:not(.v-navigation-drawer--expand-on-hover) .v-list-item .v-avatar,.v-navigation-drawer--rail.v-navigation-drawer--expand-on-hover:not(.v-navigation-drawer--is-hovering) .v-list-item .v-avatar{--v-avatar-height: 24px}.v-list-item__prepend{align-items:center;align-self:center;display:flex;grid-area:prepend}.v-list-item__prepend>.v-badge~.v-list-item__spacer,.v-list-item__prepend>.v-icon~.v-list-item__spacer,.v-list-item__prepend>.v-tooltip~.v-list-item__spacer{width:32px}.v-list-item__prepend>.v-avatar~.v-list-item__spacer,.v-list-item__prepend>.v-badge:is(:has(.v-avatar))~.v-list-item__spacer{width:16px}.v-list-item--slim .v-list-item__prepend>.v-badge~.v-list-item__spacer,.v-list-item--slim .v-list-item__prepend>.v-icon~.v-list-item__spacer,.v-list-item--slim .v-list-item__prepend>.v-tooltip~.v-list-item__spacer{width:20px}.v-list-item--slim .v-list-item__prepend>.v-avatar~.v-list-item__spacer,.v-list-item--slim .v-list-item__prepend>.v-badge:is(:has(.v-avatar))~.v-list-item__spacer{width:4px}.v-list-item--slim .v-list-item__prepend>.v-list-item-action~.v-list-item__spacer{width:4px}.v-list-item--three-line .v-list-item__prepend{align-self:start}.v-list-item__append{align-self:center;display:flex;align-items:center;grid-area:append}.v-list-item__append .v-list-item__spacer{order:-1;transition:.15s width cubic-bezier(.4,0,.2,1)}.v-list-item__append>.v-badge~.v-list-item__spacer,.v-list-item__append>.v-icon~.v-list-item__spacer,.v-list-item__append>.v-tooltip~.v-list-item__spacer{width:32px}.v-list-item__append>.v-avatar~.v-list-item__spacer,.v-list-item__append>.v-badge:is(:has(.v-avatar))~.v-list-item__spacer{width:16px}.v-list-item__append>.v-list-item-action~.v-list-item__spacer{width:16px}.v-list-item--slim .v-list-item__append>.v-badge~.v-list-item__spacer,.v-list-item--slim .v-list-item__append>.v-icon~.v-list-item__spacer,.v-list-item--slim .v-list-item__append>.v-tooltip~.v-list-item__spacer{width:20px}.v-list-item--slim .v-list-item__append>.v-avatar~.v-list-item__spacer,.v-list-item--slim .v-list-item__append>.v-badge:is(:has(.v-avatar))~.v-list-item__spacer{width:4px}.v-list-item--slim .v-list-item__append>.v-list-item-action~.v-list-item__spacer{width:4px}.v-list-item--three-line .v-list-item__append{align-self:start}.v-list-item__content{align-self:center;grid-area:content;overflow:hidden;min-width:40px}.v-list-item-action{align-self:center;display:flex;align-items:center;flex:none;transition:inherit;transition-property:height,width}.v-list-item-action--start{margin-inline-end:8px;margin-inline-start:-8px}.v-list-item-action--end{margin-inline-start:8px;margin-inline-end:-8px}.v-list-item-media{margin-top:0;margin-bottom:0}.v-list-item-media--start{margin-inline-end:16px}.v-list-item-media--end{margin-inline-start:16px}.v-list-item--two-line .v-list-item-media{margin-top:-4px;margin-bottom:-4px}.v-list-item--three-line .v-list-item-media{margin-top:0;margin-bottom:0}.v-list-item-subtitle{-webkit-box-orient:vertical;display:-webkit-box;opacity:var(--v-list-item-subtitle-opacity, var(--v-medium-emphasis-opacity));overflow:hidden;padding:0;text-overflow:ellipsis;overflow-wrap:break-word;word-break:initial}.v-list-item--one-line .v-list-item-subtitle{-webkit-line-clamp:1}.v-list-item--two-line .v-list-item-subtitle{-webkit-line-clamp:2}.v-list-item--three-line .v-list-item-subtitle{-webkit-line-clamp:3}.v-list-item-subtitle{font-size:.875rem;font-weight:400;letter-spacing:.0178571429em;line-height:1rem;text-transform:none}.v-list-item--nav .v-list-item-subtitle{font-size:.75rem;font-weight:400;letter-spacing:.0178571429em;line-height:1rem}.v-list-item-title{-webkit-hyphens:auto;hyphens:auto;overflow-wrap:normal;overflow:hidden;padding:0;white-space:nowrap;text-overflow:ellipsis;word-break:normal;word-wrap:break-word}.v-list-item-title{font-size:1rem;font-weight:400;letter-spacing:.009375em;line-height:1.5;text-transform:none}.v-list-item--nav .v-list-item-title{font-size:.8125rem;font-weight:500;letter-spacing:normal;line-height:1rem}.v-list-item--density-default{min-height:40px}.v-list-item--density-default.v-list-item--one-line{min-height:48px;padding-top:4px;padding-bottom:4px}.v-list-item--density-default.v-list-item--two-line{min-height:64px;padding-top:12px;padding-bottom:12px}.v-list-item--density-default.v-list-item--three-line{min-height:88px;padding-top:16px;padding-bottom:16px}.v-list-item--density-default.v-list-item--three-line .v-list-item__prepend,.v-list-item--density-default.v-list-item--three-line .v-list-item__append{padding-top:8px}.v-list-item--density-default:not(.v-list-item--nav).v-list-item--one-line{padding-inline:16px}.v-list-item--density-default:not(.v-list-item--nav).v-list-item--two-line{padding-inline:16px}.v-list-item--density-default:not(.v-list-item--nav).v-list-item--three-line{padding-inline:16px}.v-list-item--density-comfortable{min-height:36px}.v-list-item--density-comfortable.v-list-item--one-line{min-height:44px}.v-list-item--density-comfortable.v-list-item--two-line{min-height:60px;padding-top:8px;padding-bottom:8px}.v-list-item--density-comfortable.v-list-item--three-line{min-height:84px;padding-top:12px;padding-bottom:12px}.v-list-item--density-comfortable.v-list-item--three-line .v-list-item__prepend,.v-list-item--density-comfortable.v-list-item--three-line .v-list-item__append{padding-top:6px}.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--one-line{padding-inline:16px}.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--two-line{padding-inline:16px}.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--three-line{padding-inline:16px}.v-list-item--density-compact{min-height:32px}.v-list-item--density-compact.v-list-item--one-line{min-height:40px}.v-list-item--density-compact.v-list-item--two-line{min-height:56px;padding-top:4px;padding-bottom:4px}.v-list-item--density-compact.v-list-item--three-line{min-height:80px;padding-top:8px;padding-bottom:8px}.v-list-item--density-compact.v-list-item--three-line .v-list-item__prepend,.v-list-item--density-compact.v-list-item--three-line .v-list-item__append{padding-top:4px}.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--one-line{padding-inline:16px}.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--two-line{padding-inline:16px}.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--three-line{padding-inline:16px}.v-list-item--nav{padding-inline:8px}.v-list .v-list-item--nav:not(:only-child){margin-bottom:4px}.v-list-item__underlay{position:absolute}.v-list-item__overlay{background-color:currentColor;border-radius:inherit;bottom:0;left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:opacity .2s ease-in-out}.v-list-item--active.v-list-item--variant-elevated .v-list-item__overlay{--v-theme-overlay-multiplier: 0}.v-list{--indent-padding: 0px}.v-list--nav{--indent-padding: -8px}.v-list-group{--list-indent-size: 16px;--parent-padding: var(--indent-padding);--prepend-width: 40px}.v-list--slim .v-list-group{--prepend-width: 28px}.v-list-group--fluid{--list-indent-size: 0px}.v-list-group--prepend{--parent-padding: calc(var(--indent-padding) + var(--prepend-width))}.v-list-group--fluid.v-list-group--prepend{--parent-padding: var(--indent-padding)}.v-list-group__items{--indent-padding: calc(var(--parent-padding) + var(--list-indent-size));min-width:min-content}.v-list-group__items .v-list-item{padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list-group__header:not(.v-treeview-item--activatable-group-activator).v-list-item--active:not(:focus-visible) .v-list-item__overlay{opacity:0}.v-list-group__header:not(.v-treeview-item--activatable-group-activator).v-list-item--active:hover .v-list-item__overlay{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-menu>.v-overlay__content{display:flex;flex-direction:column}.v-menu>.v-overlay__content{border-radius:4px}.v-menu>.v-overlay__content>.v-card,.v-menu>.v-overlay__content>.v-sheet,.v-menu>.v-overlay__content>.v-list{background:rgb(var(--v-theme-surface));border-radius:inherit;overflow:auto;height:100%}.v-menu>.v-overlay__content>.v-card,.v-menu>.v-overlay__content>.v-sheet,.v-menu>.v-overlay__content>.v-list{box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-overlay-container{contain:layout;left:0;pointer-events:none;position:absolute;top:0;display:contents}.v-overlay-scroll-blocked{padding-inline-end:var(--v-scrollbar-offset)}.v-overlay-scroll-blocked:not(html){overflow-y:hidden!important}html.v-overlay-scroll-blocked{position:fixed;top:var(--v-body-scroll-y);left:var(--v-body-scroll-x);width:100%;height:100%}.v-overlay{--v-overlay-opacity: .32;border-radius:inherit;display:flex;left:0;pointer-events:none;position:fixed;top:0;bottom:0;right:0}.v-overlay__content{outline:none;position:absolute;pointer-events:auto;contain:layout}.v-overlay__scrim{pointer-events:auto;background:#000;border-radius:inherit;bottom:0;left:0;opacity:var(--v-overlay-opacity);position:fixed;right:0;top:0}.v-overlay--absolute,.v-overlay--contained .v-overlay__scrim{position:absolute}.v-overlay--scroll-blocked{padding-inline-end:var(--v-scrollbar-offset)}.v-select--chips.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,.v-select--chips.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,.v-select--chips.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,.v-select--chips.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating{top:0}.v-select .v-field .v-text-field__prefix,.v-select .v-field .v-text-field__suffix,.v-select .v-field .v-field__input,.v-select .v-field.v-field{cursor:pointer}.v-select .v-field .v-field__input>input{align-self:flex-start;opacity:1;flex:0 0;position:absolute;width:100%;transition:none;pointer-events:none;caret-color:transparent}.v-select .v-field--dirty .v-select__selection{margin-inline-end:2px}.v-select .v-select__selection-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.v-select__content{overflow:hidden}.v-select__content{box-shadow:0 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 4px 5px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 10px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-select__content{border-radius:4px}.v-select__selection{display:inline-flex;align-items:center;letter-spacing:inherit;line-height:inherit;max-width:100%}.v-select .v-select__selection:first-child{margin-inline-start:0}.v-select--selected .v-field .v-field__input>input{opacity:0}.v-select__menu-icon{margin-inline-start:4px;transition:.2s cubic-bezier(.4,0,.2,1)}.v-select--active-menu .v-select__menu-icon{transform:rotate(180deg)}.v-text-field input{color:inherit;opacity:0;flex:1;transition:.15s opacity cubic-bezier(.4,0,.2,1);min-width:0}.v-text-field input:focus,.v-text-field input:active{outline:none}.v-text-field input:invalid{box-shadow:none}.v-text-field .v-field{cursor:text}.v-text-field--prefixed.v-text-field .v-field:not(.v-field--reverse) .v-field__input{--v-field-padding-start: 6px}.v-text-field--suffixed.v-text-field .v-field:not(.v-field--reverse) .v-field__input{--v-field-padding-end: 0}.v-text-field--prefixed.v-text-field .v-field.v-field--reverse .v-field__input{--v-field-padding-end: 6px}.v-text-field--suffixed.v-text-field .v-field.v-field--reverse .v-field__input{--v-field-padding-start: 0}.v-text-field .v-input__details{padding-inline:16px}.v-input--plain-underlined.v-text-field .v-input__details{padding-inline:0}.v-text-field .v-field--no-label input,.v-text-field .v-field--active input{opacity:1}.v-text-field .v-field--single-line input{transition:none}.v-text-field__prefix,.v-text-field__suffix{align-items:center;color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity));cursor:default;display:flex;opacity:0;transition:inherit;white-space:nowrap;min-height:max(var(--v-input-control-height, 56px),1.5rem + var(--v-field-input-padding-top) + var(--v-field-input-padding-bottom));padding-top:calc(var(--v-field-padding-top, 4px) + var(--v-input-padding-top, 0));padding-bottom:var(--v-field-padding-bottom, 6px)}.v-field--active .v-text-field__prefix,.v-field--active .v-text-field__suffix{opacity:1}.v-field--disabled .v-text-field__prefix,.v-field--disabled .v-text-field__suffix{color:rgba(var(--v-theme-on-surface),var(--v-disabled-opacity))}.v-field:not(.v-field--reverse) .v-text-field__prefix{padding-inline-start:var(--v-field-padding-start)}.v-field.v-field--reverse .v-text-field__prefix{padding-inline-end:var(--v-field-padding-end)}.v-field:not(.v-field--reverse) .v-text-field__suffix{padding-inline-end:var(--v-field-padding-end)}.v-field.v-field--reverse .v-text-field__suffix{padding-inline-start:var(--v-field-padding-start)}.v-counter{color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity));flex:0 1 auto;font-size:12px;transition-duration:.15s}.v-field{display:grid;grid-template-areas:"prepend-inner field clear append-inner";grid-template-columns:min-content minmax(0,1fr) min-content min-content;font-size:16px;letter-spacing:.009375em;max-width:100%;border-radius:4px;contain:layout;flex:1 0;grid-area:control;position:relative;--v-theme-overlay-multiplier: 1;--v-field-padding-start: 16px;--v-field-padding-end: 16px;--v-field-padding-top: 8px;--v-field-padding-bottom: 4px;--v-field-input-padding-top: calc(var(--v-field-padding-top, 8px) + var(--v-input-padding-top, 0px));--v-field-input-padding-bottom: var(--v-field-padding-bottom, 4px)}.v-field--disabled{opacity:var(--v-disabled-opacity);pointer-events:none}.v-field .v-chip{--v-chip-height: 24px}.v-field--prepended{padding-inline-start:12px}.v-field--appended{padding-inline-end:12px}.v-field--variant-solo,.v-field--variant-solo-filled{background:rgb(var(--v-theme-surface));border-color:transparent;color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-field--variant-solo,.v-field--variant-solo-filled{box-shadow:0 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 2px 2px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 5px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-field--variant-solo-inverted{background:rgb(var(--v-theme-surface));border-color:transparent;color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-field--variant-solo-inverted{box-shadow:0 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 2px 2px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 5px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-field--variant-solo-inverted.v-field--focused{color:rgb(var(--v-theme-on-surface-variant))}.v-field--variant-filled{border-bottom-left-radius:0;border-bottom-right-radius:0}.v-input--density-default .v-field--variant-solo,.v-input--density-default .v-field--variant-solo-inverted,.v-input--density-default .v-field--variant-solo-filled,.v-input--density-default .v-field--variant-filled{--v-input-control-height: 56px;--v-field-padding-bottom: 4px}.v-input--density-comfortable .v-field--variant-solo,.v-input--density-comfortable .v-field--variant-solo-inverted,.v-input--density-comfortable .v-field--variant-solo-filled,.v-input--density-comfortable .v-field--variant-filled{--v-input-control-height: 48px;--v-field-padding-bottom: 0px}.v-input--density-compact .v-field--variant-solo,.v-input--density-compact .v-field--variant-solo-inverted,.v-input--density-compact .v-field--variant-solo-filled,.v-input--density-compact .v-field--variant-filled{--v-input-control-height: 40px;--v-field-padding-bottom: 0px}.v-field--variant-outlined,.v-field--single-line,.v-field--no-label{--v-field-padding-top: 0px}.v-input--density-default .v-field--variant-outlined,.v-input--density-default .v-field--single-line,.v-input--density-default .v-field--no-label{--v-field-padding-bottom: 16px}.v-input--density-comfortable .v-field--variant-outlined,.v-input--density-comfortable .v-field--single-line,.v-input--density-comfortable .v-field--no-label{--v-field-padding-bottom: 12px}.v-input--density-compact .v-field--variant-outlined,.v-input--density-compact .v-field--single-line,.v-input--density-compact .v-field--no-label{--v-field-padding-bottom: 8px}.v-field--variant-plain,.v-field--variant-underlined{border-radius:0;padding:0}.v-field--variant-plain.v-field,.v-field--variant-underlined.v-field{--v-field-padding-start: 0px;--v-field-padding-end: 0px}.v-input--density-default .v-field--variant-plain,.v-input--density-default .v-field--variant-underlined{--v-input-control-height: 48px;--v-field-padding-top: 4px;--v-field-padding-bottom: 4px}.v-input--density-comfortable .v-field--variant-plain,.v-input--density-comfortable .v-field--variant-underlined{--v-input-control-height: 40px;--v-field-padding-top: 2px;--v-field-padding-bottom: 0px}.v-input--density-compact .v-field--variant-plain,.v-input--density-compact .v-field--variant-underlined{--v-input-control-height: 32px;--v-field-padding-top: 0px;--v-field-padding-bottom: 0px}.v-field--flat{box-shadow:none}.v-field--rounded{border-radius:24px}.v-field.v-field--prepended{--v-field-padding-start: 6px}.v-field.v-field--appended{--v-field-padding-end: 6px}.v-field__input{align-items:center;color:inherit;column-gap:2px;display:flex;flex-wrap:wrap;letter-spacing:.009375em;opacity:var(--v-high-emphasis-opacity);min-height:max(var(--v-input-control-height, 56px),1.5rem + var(--v-field-input-padding-top) + var(--v-field-input-padding-bottom));min-width:0;padding-inline:var(--v-field-padding-start) var(--v-field-padding-end);padding-top:var(--v-field-input-padding-top);padding-bottom:var(--v-field-input-padding-bottom);position:relative;width:100%}.v-input--density-default .v-field__input{row-gap:8px}.v-input--density-comfortable .v-field__input{row-gap:6px}.v-input--density-compact .v-field__input{row-gap:4px}.v-field__input input{letter-spacing:inherit}.v-field__input input::placeholder,input.v-field__input::placeholder,textarea.v-field__input::placeholder{color:currentColor;opacity:var(--v-disabled-opacity)}.v-field__input:focus,.v-field__input:active{outline:none}.v-field__input:invalid{box-shadow:none}.v-field__field{flex:1 0;grid-area:field;position:relative;align-items:flex-start;display:flex}.v-field__prepend-inner{grid-area:prepend-inner;padding-inline-end:var(--v-field-padding-after)}.v-field__clearable{grid-area:clear}.v-field__append-inner{grid-area:append-inner;padding-inline-start:var(--v-field-padding-after)}.v-field__append-inner,.v-field__clearable,.v-field__prepend-inner{display:flex;align-items:flex-start;padding-top:var(--v-input-padding-top, 8px)}.v-field--center-affix .v-field__append-inner,.v-field--center-affix .v-field__clearable,.v-field--center-affix .v-field__prepend-inner{align-items:center;padding-top:0}.v-field.v-field--variant-underlined .v-field__append-inner,.v-field.v-field--variant-underlined .v-field__clearable,.v-field.v-field--variant-underlined .v-field__prepend-inner,.v-field.v-field--variant-plain .v-field__append-inner,.v-field.v-field--variant-plain .v-field__clearable,.v-field.v-field--variant-plain .v-field__prepend-inner{align-items:flex-start;padding-top:calc(var(--v-field-padding-top, 8px) + var(--v-input-padding-top, 0px));padding-bottom:var(--v-field-padding-bottom, 4px)}.v-field--focused .v-field__prepend-inner,.v-field--focused .v-field__append-inner{opacity:1}.v-field__prepend-inner>.v-icon,.v-field__append-inner>.v-icon,.v-field__clearable>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-field--disabled .v-field__prepend-inner>.v-icon,.v-field--error .v-field__prepend-inner>.v-icon,.v-field--glow.v-field--focused .v-field__prepend-inner>.v-icon,.v-field--disabled .v-field__append-inner>.v-icon,.v-field--error .v-field__append-inner>.v-icon,.v-field--glow.v-field--focused .v-field__append-inner>.v-icon,.v-field--disabled .v-field__clearable>.v-icon,.v-field--error .v-field__clearable>.v-icon,.v-field--glow.v-field--focused .v-field__clearable>.v-icon{opacity:1}.v-field--error:not(.v-field--disabled) .v-field__prepend-inner>.v-icon,.v-field--error:not(.v-field--disabled) .v-field__append-inner>.v-icon,.v-field--error:not(.v-field--disabled) .v-field__clearable>.v-icon{color:rgb(var(--v-theme-error))}.v-field__clearable{cursor:pointer;opacity:0;overflow:hidden;margin-inline:4px;transition:.15s cubic-bezier(.4,0,.2,1);transition-property:opacity,transform,width}.v-field--focused .v-field__clearable,.v-field--persistent-clear .v-field__clearable{opacity:1}@media (hover: hover){.v-field:hover .v-field__clearable{opacity:1}}@media (hover: none){.v-field__clearable{opacity:1}}.v-label.v-field-label{contain:layout paint;display:block;margin-inline-start:var(--v-field-padding-start);margin-inline-end:var(--v-field-padding-end);max-width:calc(100% - var(--v-field-padding-start) - var(--v-field-padding-end));pointer-events:none;position:absolute;top:var(--v-input-padding-top);transform-origin:left center;transition:.15s cubic-bezier(.4,0,.2,1);transition-property:opacity,transform;z-index:1}.v-field--variant-underlined .v-label.v-field-label,.v-field--variant-plain .v-label.v-field-label{top:calc(var(--v-input-padding-top) + var(--v-field-padding-top))}.v-field--center-affix .v-label.v-field-label{top:50%;transform:translateY(-50%)}.v-field--active .v-label.v-field-label{visibility:hidden}.v-field--focused .v-label.v-field-label,.v-field--error .v-label.v-field-label{opacity:1}.v-field--error:not(.v-field--disabled) .v-label.v-field-label{color:rgb(var(--v-theme-error))}.v-label.v-field-label--floating{--v-field-label-scale: .75em;font-size:var(--v-field-label-scale);visibility:hidden}.v-field--variant-outlined .v-label.v-field-label--floating{max-width:100%}.v-field--center-affix .v-label.v-field-label--floating{transform:none}.v-field.v-field--active .v-label.v-field-label--floating{visibility:unset}.v-input--density-default .v-field--variant-solo .v-label.v-field-label--floating,.v-input--density-default .v-field--variant-solo-inverted .v-label.v-field-label--floating,.v-input--density-default .v-field--variant-filled .v-label.v-field-label--floating,.v-input--density-default .v-field--variant-solo-filled .v-label.v-field-label--floating{top:7px}.v-input--density-comfortable .v-field--variant-solo .v-label.v-field-label--floating,.v-input--density-comfortable .v-field--variant-solo-inverted .v-label.v-field-label--floating,.v-input--density-comfortable .v-field--variant-filled .v-label.v-field-label--floating,.v-input--density-comfortable .v-field--variant-solo-filled .v-label.v-field-label--floating{top:5px}.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating{top:3px}.v-field--variant-plain .v-label.v-field-label--floating,.v-field--variant-underlined .v-label.v-field-label--floating{transform:translateY(-16px);margin:0;top:var(--v-input-padding-top)}.v-field--variant-outlined .v-label.v-field-label--floating{transform:translateY(-50%);transform-origin:center;position:static;margin:0 4px}.v-field__outline{--v-field-border-width: 1px;--v-field-border-opacity: .38;align-items:stretch;contain:layout;display:flex;height:100%;left:0;pointer-events:none;position:absolute;right:0;width:100%}@media (hover: hover){.v-field:hover .v-field__outline{--v-field-border-opacity: var(--v-high-emphasis-opacity)}}.v-field--error:not(.v-field--disabled) .v-field__outline{color:rgb(var(--v-theme-error))}.v-field.v-field--focused .v-field__outline,.v-input.v-input--error .v-field__outline{--v-field-border-opacity: 1}.v-field--variant-outlined.v-field--focused .v-field__outline{--v-field-border-width: 2px}.v-field--variant-filled .v-field__outline:before,.v-field--variant-underlined .v-field__outline:before{border-color:currentColor;border-style:solid;border-width:0 0 var(--v-field-border-width);opacity:var(--v-field-border-opacity);transition:opacity .25s cubic-bezier(.4,0,.2,1)}.v-field--variant-filled .v-field__outline:before,.v-field--variant-underlined .v-field__outline:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%}.v-field--variant-filled .v-field__outline:after,.v-field--variant-underlined .v-field__outline:after{border-color:currentColor;border-style:solid;border-width:0 0 2px;transform:scaleX(0);transition:transform .15s cubic-bezier(.4,0,.2,1)}.v-field--variant-filled .v-field__outline:after,.v-field--variant-underlined .v-field__outline:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%}.v-field--focused.v-field--variant-filled .v-field__outline:after,.v-field--focused.v-field--variant-underlined .v-field__outline:after{transform:scaleX(1)}.v-field--variant-outlined .v-field__outline{border-radius:inherit}.v-field--variant-outlined .v-field__outline__start,.v-field--variant-outlined .v-field__outline__notch:before,.v-field--variant-outlined .v-field__outline__notch:after,.v-field--variant-outlined .v-field__outline__end{border:0 solid currentColor;opacity:var(--v-field-border-opacity);transition:opacity .25s cubic-bezier(.4,0,.2,1)}.v-field--variant-outlined .v-field__outline__start{flex:0 0 12px;border-top-width:var(--v-field-border-width);border-bottom-width:var(--v-field-border-width);border-inline-start-width:var(--v-field-border-width);border-start-start-radius:inherit;border-start-end-radius:0;border-end-end-radius:0;border-end-start-radius:inherit}.v-field--rounded.v-field--variant-outlined .v-field__outline__start,[class^=rounded-].v-field--variant-outlined .v-field__outline__start,[class*=" rounded-"].v-field--variant-outlined .v-field__outline__start{flex-basis:calc(var(--v-input-control-height) / 2 + 2px)}.v-field--reverse.v-field--variant-outlined .v-field__outline__start{border-start-start-radius:0;border-start-end-radius:inherit;border-end-end-radius:inherit;border-end-start-radius:0;border-inline-end-width:var(--v-field-border-width);border-inline-start-width:0}.v-field--variant-outlined .v-field__outline__notch{flex:none;position:relative;max-width:calc(100% - 24px)}.v-field--rounded.v-field--variant-outlined .v-field__outline__notch,[class^=rounded-].v-field--variant-outlined .v-field__outline__notch,[class*=" rounded-"].v-field--variant-outlined .v-field__outline__notch{max-width:calc(100% - var(--v-input-control-height))}.v-field--variant-outlined .v-field__outline__notch:before,.v-field--variant-outlined .v-field__outline__notch:after{opacity:var(--v-field-border-opacity);transition:opacity .25s cubic-bezier(.4,0,.2,1)}.v-field--variant-outlined .v-field__outline__notch:before,.v-field--variant-outlined .v-field__outline__notch:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%}.v-field--variant-outlined .v-field__outline__notch:before{border-width:var(--v-field-border-width) 0 0}.v-field--variant-outlined .v-field__outline__notch:after{bottom:0;border-width:0 0 var(--v-field-border-width)}.v-field--active.v-field--variant-outlined .v-field__outline__notch:before{opacity:0}.v-field--variant-outlined .v-field__outline__end{flex:1;border-top-width:var(--v-field-border-width);border-bottom-width:var(--v-field-border-width);border-inline-end-width:var(--v-field-border-width);border-start-start-radius:0;border-start-end-radius:inherit;border-end-end-radius:inherit;border-end-start-radius:0}.v-field--reverse.v-field--variant-outlined .v-field__outline__end{border-start-start-radius:inherit;border-start-end-radius:0;border-end-end-radius:0;border-end-start-radius:inherit;border-inline-end-width:0;border-inline-start-width:var(--v-field-border-width)}.v-field__loader{top:calc(100% - 2px);left:0;position:absolute;right:0;width:100%;border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:inherit;border-bottom-right-radius:inherit;overflow:hidden}.v-field--variant-outlined .v-field__loader{top:calc(100% - 3px);width:calc(100% - 2px);left:1px}.v-field__overlay{border-radius:inherit;pointer-events:none}.v-field__overlay{position:absolute;top:0;left:0;width:100%;height:100%}.v-field--variant-filled .v-field__overlay{background-color:currentColor;opacity:.04;transition:opacity .25s cubic-bezier(.4,0,.2,1)}.v-field--variant-filled.v-field--has-background .v-field__overlay{opacity:0}@media (hover: hover){.v-field--variant-filled:hover .v-field__overlay{opacity:calc((.04 + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}}.v-field--variant-filled.v-field--focused .v-field__overlay{opacity:calc((.04 + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}.v-field--variant-solo-filled .v-field__overlay{background-color:currentColor;opacity:.04;transition:opacity .25s cubic-bezier(.4,0,.2,1)}@media (hover: hover){.v-field--variant-solo-filled:hover .v-field__overlay{opacity:calc((.04 + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}}.v-field--variant-solo-filled.v-field--focused .v-field__overlay{opacity:calc((.04 + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}.v-field--variant-solo-inverted .v-field__overlay{transition:opacity .25s cubic-bezier(.4,0,.2,1)}.v-field--variant-solo-inverted.v-field--has-background .v-field__overlay{opacity:0}@media (hover: hover){.v-field--variant-solo-inverted:hover .v-field__overlay{opacity:calc((.04 + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}}.v-field--variant-solo-inverted.v-field--focused .v-field__overlay{background-color:rgb(var(--v-theme-surface-variant));opacity:1}.v-field--reverse .v-field__field,.v-field--reverse .v-field__input,.v-field--reverse .v-field__outline{flex-direction:row-reverse}.v-field--reverse .v-field__input,.v-field--reverse input{text-align:end}.v-input--disabled .v-field--variant-filled .v-field__outline:before,.v-input--disabled .v-field--variant-underlined .v-field__outline:before{border-image:repeating-linear-gradient(to right,rgba(var(--v-theme-on-surface),var(--v-disabled-opacity)) 0px,rgba(var(--v-theme-on-surface),var(--v-disabled-opacity)) 2px,transparent 2px,transparent 4px) 1 repeat}.v-field--loading .v-field__outline:after,.v-field--loading .v-field__outline:before{opacity:0}.v-progress-linear{background:transparent;overflow:hidden;position:relative;transition:.2s cubic-bezier(.4,0,.2,1);width:100%}@media (forced-colors: active){.v-progress-linear{border:thin solid buttontext}}.v-progress-linear__background,.v-progress-linear__buffer{background:currentColor;bottom:0;left:0;opacity:var(--v-border-opacity);position:absolute;top:0;width:100%;transition-property:width,left,right;transition:inherit}@media (forced-colors: active){.v-progress-linear__buffer{background-color:highlight;opacity:.3}}.v-progress-linear__content{align-items:center;display:flex;height:100%;justify-content:center;left:0;pointer-events:none;position:absolute;top:0;width:100%}.v-progress-linear__determinate,.v-progress-linear__indeterminate{background:currentColor}@media (forced-colors: active){.v-progress-linear__determinate,.v-progress-linear__indeterminate{background-color:highlight}}.v-progress-linear__determinate{height:inherit;left:0;position:absolute;transition:inherit;transition-property:width,left,right}.v-progress-linear__indeterminate .long,.v-progress-linear__indeterminate .short{animation-play-state:paused;animation-duration:2.2s;animation-iteration-count:infinite;bottom:0;height:inherit;left:0;position:absolute;right:auto;top:0;width:auto}.v-progress-linear__indeterminate .long{animation-name:indeterminate-ltr}.v-progress-linear__indeterminate .short{animation-name:indeterminate-short-ltr}.v-progress-linear__stream{animation:stream .25s infinite linear;animation-play-state:paused;bottom:0;left:auto;opacity:.3;pointer-events:none;position:absolute;transition:inherit;transition-property:width,left,right}.v-progress-linear--reverse .v-progress-linear__background,.v-progress-linear--reverse .v-progress-linear__determinate,.v-progress-linear--reverse .v-progress-linear__content,.v-progress-linear--reverse .v-progress-linear__indeterminate .long,.v-progress-linear--reverse .v-progress-linear__indeterminate .short{left:auto;right:0}.v-progress-linear--reverse .v-progress-linear__indeterminate .long{animation-name:indeterminate-rtl}.v-progress-linear--reverse .v-progress-linear__indeterminate .short{animation-name:indeterminate-short-rtl}.v-progress-linear--reverse .v-progress-linear__stream{right:auto}.v-progress-linear--absolute,.v-progress-linear--fixed{left:0;z-index:1}.v-progress-linear--absolute{position:absolute}.v-progress-linear--fixed{position:fixed}.v-progress-linear--rounded{border-radius:9999px}.v-progress-linear--rounded.v-progress-linear--rounded-bar .v-progress-linear__determinate,.v-progress-linear--rounded.v-progress-linear--rounded-bar .v-progress-linear__indeterminate{border-radius:inherit}.v-progress-linear--striped .v-progress-linear__determinate{animation:progress-linear-stripes 1s infinite linear;background-image:linear-gradient(135deg,hsla(0,0%,100%,.25) 25%,transparent 0,transparent 50%,hsla(0,0%,100%,.25) 0,hsla(0,0%,100%,.25) 75%,transparent 0,transparent);background-repeat:repeat;background-size:var(--v-progress-linear-height)}.v-progress-linear--active .v-progress-linear__indeterminate .long,.v-progress-linear--active .v-progress-linear__indeterminate .short,.v-progress-linear--active .v-progress-linear__stream{animation-play-state:running}.v-progress-linear--rounded-bar .v-progress-linear__determinate,.v-progress-linear--rounded-bar .v-progress-linear__indeterminate,.v-progress-linear--rounded-bar .v-progress-linear__stream+.v-progress-linear__background{border-radius:9999px}.v-progress-linear--rounded-bar .v-progress-linear__determinate{border-start-start-radius:0;border-end-start-radius:0}@keyframes indeterminate-ltr{0%{left:-90%;right:100%}60%{left:-90%;right:100%}to{left:100%;right:-35%}}@keyframes indeterminate-rtl{0%{left:100%;right:-90%}60%{left:100%;right:-90%}to{left:-35%;right:100%}}@keyframes indeterminate-short-ltr{0%{left:-200%;right:100%}60%{left:107%;right:-8%}to{left:107%;right:-8%}}@keyframes indeterminate-short-rtl{0%{left:100%;right:-200%}60%{left:-8%;right:107%}to{left:-8%;right:107%}}@keyframes stream{to{transform:translate(var(--v-progress-linear-stream-to))}}@keyframes progress-linear-stripes{0%{background-position-x:var(--v-progress-linear-height)}}.v-virtual-scroll{display:block;flex:1 1 auto;max-width:100%;overflow:auto;position:relative}.v-virtual-scroll__container{display:block}.v-container{width:100%;padding:16px;margin-right:auto;margin-left:auto}@media (min-width: 960px){.v-container{max-width:900px}}@media (min-width: 1280px){.v-container{max-width:1200px}}@media (min-width: 1920px){.v-container{max-width:1800px}}@media (min-width: 2560px){.v-container{max-width:2400px}}.v-container--fluid{max-width:100%}.v-container.fill-height{align-items:center;display:flex;flex-wrap:wrap}.v-row{display:flex;flex-wrap:wrap;flex:1 1 auto;margin:-12px}.v-row+.v-row{margin-top:12px}.v-row+.v-row--dense{margin-top:4px}.v-row--dense{margin:-4px}.v-row--dense>.v-col,.v-row--dense>[class*=v-col-]{padding:4px}.v-row.v-row--no-gutters{margin:0}.v-row.v-row--no-gutters>.v-col,.v-row.v-row--no-gutters>[class*=v-col-]{padding:0}.v-spacer{flex-grow:1}.v-col-xxl,.v-col-xxl-auto,.v-col-xxl-12,.v-col-xxl-11,.v-col-xxl-10,.v-col-xxl-9,.v-col-xxl-8,.v-col-xxl-7,.v-col-xxl-6,.v-col-xxl-5,.v-col-xxl-4,.v-col-xxl-3,.v-col-xxl-2,.v-col-xxl-1,.v-col-xl,.v-col-xl-auto,.v-col-xl-12,.v-col-xl-11,.v-col-xl-10,.v-col-xl-9,.v-col-xl-8,.v-col-xl-7,.v-col-xl-6,.v-col-xl-5,.v-col-xl-4,.v-col-xl-3,.v-col-xl-2,.v-col-xl-1,.v-col-lg,.v-col-lg-auto,.v-col-lg-12,.v-col-lg-11,.v-col-lg-10,.v-col-lg-9,.v-col-lg-8,.v-col-lg-7,.v-col-lg-6,.v-col-lg-5,.v-col-lg-4,.v-col-lg-3,.v-col-lg-2,.v-col-lg-1,.v-col-md,.v-col-md-auto,.v-col-md-12,.v-col-md-11,.v-col-md-10,.v-col-md-9,.v-col-md-8,.v-col-md-7,.v-col-md-6,.v-col-md-5,.v-col-md-4,.v-col-md-3,.v-col-md-2,.v-col-md-1,.v-col-sm,.v-col-sm-auto,.v-col-sm-12,.v-col-sm-11,.v-col-sm-10,.v-col-sm-9,.v-col-sm-8,.v-col-sm-7,.v-col-sm-6,.v-col-sm-5,.v-col-sm-4,.v-col-sm-3,.v-col-sm-2,.v-col-sm-1,.v-col,.v-col-auto,.v-col-12,.v-col-11,.v-col-10,.v-col-9,.v-col-8,.v-col-7,.v-col-6,.v-col-5,.v-col-4,.v-col-3,.v-col-2,.v-col-1{width:100%;padding:12px}.v-col{flex-basis:0;flex-grow:1;max-width:100%}.v-col-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-3{flex:0 0 25%;max-width:25%}.v-col-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-6{flex:0 0 50%;max-width:50%}.v-col-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-9{flex:0 0 75%;max-width:75%}.v-col-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-12{flex:0 0 100%;max-width:100%}.offset-1{margin-inline-start:8.3333333333%}.offset-2{margin-inline-start:16.6666666667%}.offset-3{margin-inline-start:25%}.offset-4{margin-inline-start:33.3333333333%}.offset-5{margin-inline-start:41.6666666667%}.offset-6{margin-inline-start:50%}.offset-7{margin-inline-start:58.3333333333%}.offset-8{margin-inline-start:66.6666666667%}.offset-9{margin-inline-start:75%}.offset-10{margin-inline-start:83.3333333333%}.offset-11{margin-inline-start:91.6666666667%}@media (min-width: 600px){.v-col-sm{flex-basis:0;flex-grow:1;max-width:100%}.v-col-sm-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-sm-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-sm-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-sm-3{flex:0 0 25%;max-width:25%}.v-col-sm-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-sm-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-sm-6{flex:0 0 50%;max-width:50%}.v-col-sm-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-sm-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-sm-9{flex:0 0 75%;max-width:75%}.v-col-sm-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-sm-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-sm-12{flex:0 0 100%;max-width:100%}.offset-sm-0{margin-inline-start:0}.offset-sm-1{margin-inline-start:8.3333333333%}.offset-sm-2{margin-inline-start:16.6666666667%}.offset-sm-3{margin-inline-start:25%}.offset-sm-4{margin-inline-start:33.3333333333%}.offset-sm-5{margin-inline-start:41.6666666667%}.offset-sm-6{margin-inline-start:50%}.offset-sm-7{margin-inline-start:58.3333333333%}.offset-sm-8{margin-inline-start:66.6666666667%}.offset-sm-9{margin-inline-start:75%}.offset-sm-10{margin-inline-start:83.3333333333%}.offset-sm-11{margin-inline-start:91.6666666667%}}@media (min-width: 960px){.v-col-md{flex-basis:0;flex-grow:1;max-width:100%}.v-col-md-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-md-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-md-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-md-3{flex:0 0 25%;max-width:25%}.v-col-md-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-md-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-md-6{flex:0 0 50%;max-width:50%}.v-col-md-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-md-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-md-9{flex:0 0 75%;max-width:75%}.v-col-md-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-md-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-md-12{flex:0 0 100%;max-width:100%}.offset-md-0{margin-inline-start:0}.offset-md-1{margin-inline-start:8.3333333333%}.offset-md-2{margin-inline-start:16.6666666667%}.offset-md-3{margin-inline-start:25%}.offset-md-4{margin-inline-start:33.3333333333%}.offset-md-5{margin-inline-start:41.6666666667%}.offset-md-6{margin-inline-start:50%}.offset-md-7{margin-inline-start:58.3333333333%}.offset-md-8{margin-inline-start:66.6666666667%}.offset-md-9{margin-inline-start:75%}.offset-md-10{margin-inline-start:83.3333333333%}.offset-md-11{margin-inline-start:91.6666666667%}}@media (min-width: 1280px){.v-col-lg{flex-basis:0;flex-grow:1;max-width:100%}.v-col-lg-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-lg-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-lg-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-lg-3{flex:0 0 25%;max-width:25%}.v-col-lg-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-lg-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-lg-6{flex:0 0 50%;max-width:50%}.v-col-lg-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-lg-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-lg-9{flex:0 0 75%;max-width:75%}.v-col-lg-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-lg-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-lg-12{flex:0 0 100%;max-width:100%}.offset-lg-0{margin-inline-start:0}.offset-lg-1{margin-inline-start:8.3333333333%}.offset-lg-2{margin-inline-start:16.6666666667%}.offset-lg-3{margin-inline-start:25%}.offset-lg-4{margin-inline-start:33.3333333333%}.offset-lg-5{margin-inline-start:41.6666666667%}.offset-lg-6{margin-inline-start:50%}.offset-lg-7{margin-inline-start:58.3333333333%}.offset-lg-8{margin-inline-start:66.6666666667%}.offset-lg-9{margin-inline-start:75%}.offset-lg-10{margin-inline-start:83.3333333333%}.offset-lg-11{margin-inline-start:91.6666666667%}}@media (min-width: 1920px){.v-col-xl{flex-basis:0;flex-grow:1;max-width:100%}.v-col-xl-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-xl-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-xl-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-xl-3{flex:0 0 25%;max-width:25%}.v-col-xl-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-xl-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-xl-6{flex:0 0 50%;max-width:50%}.v-col-xl-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-xl-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-xl-9{flex:0 0 75%;max-width:75%}.v-col-xl-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-xl-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-xl-12{flex:0 0 100%;max-width:100%}.offset-xl-0{margin-inline-start:0}.offset-xl-1{margin-inline-start:8.3333333333%}.offset-xl-2{margin-inline-start:16.6666666667%}.offset-xl-3{margin-inline-start:25%}.offset-xl-4{margin-inline-start:33.3333333333%}.offset-xl-5{margin-inline-start:41.6666666667%}.offset-xl-6{margin-inline-start:50%}.offset-xl-7{margin-inline-start:58.3333333333%}.offset-xl-8{margin-inline-start:66.6666666667%}.offset-xl-9{margin-inline-start:75%}.offset-xl-10{margin-inline-start:83.3333333333%}.offset-xl-11{margin-inline-start:91.6666666667%}}@media (min-width: 2560px){.v-col-xxl{flex-basis:0;flex-grow:1;max-width:100%}.v-col-xxl-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-xxl-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-xxl-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-xxl-3{flex:0 0 25%;max-width:25%}.v-col-xxl-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-xxl-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-xxl-6{flex:0 0 50%;max-width:50%}.v-col-xxl-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-xxl-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-xxl-9{flex:0 0 75%;max-width:75%}.v-col-xxl-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-xxl-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-xxl-12{flex:0 0 100%;max-width:100%}.offset-xxl-0{margin-inline-start:0}.offset-xxl-1{margin-inline-start:8.3333333333%}.offset-xxl-2{margin-inline-start:16.6666666667%}.offset-xxl-3{margin-inline-start:25%}.offset-xxl-4{margin-inline-start:33.3333333333%}.offset-xxl-5{margin-inline-start:41.6666666667%}.offset-xxl-6{margin-inline-start:50%}.offset-xxl-7{margin-inline-start:58.3333333333%}.offset-xxl-8{margin-inline-start:66.6666666667%}.offset-xxl-9{margin-inline-start:75%}.offset-xxl-10{margin-inline-start:83.3333333333%}.offset-xxl-11{margin-inline-start:91.6666666667%}}.v-card-title[data-v-209409d1]{font-size:18px;color:#000}.v-btn[data-v-209409d1]{border-radius:10px}.v-card[data-v-209409d1]{border-radius:20px;box-shadow:0 4px 12px #0000001a}.v-list-item[data-v-209409d1]{border-bottom:1px solid rgba(0,0,0,.1)}.v-btn{align-items:center;border-radius:4px;display:inline-grid;grid-template-areas:"prepend content append";grid-template-columns:max-content auto max-content;font-weight:500;justify-content:center;letter-spacing:.0892857143em;line-height:normal;max-width:100%;outline:none;position:relative;text-decoration:none;text-indent:.0892857143em;text-transform:uppercase;transition-property:box-shadow,transform,opacity,background;transition-duration:.28s;transition-timing-function:cubic-bezier(.4,0,.2,1);-webkit-user-select:none;user-select:none;vertical-align:middle;flex-shrink:0}.v-locale--is-rtl .v-btn{text-indent:-.0892857143em}.v-btn--size-x-small{--v-btn-size: .625rem;--v-btn-height: 20px;font-size:var(--v-btn-size);min-width:36px;padding:0 8px}.v-btn--size-small{--v-btn-size: .75rem;--v-btn-height: 28px;font-size:var(--v-btn-size);min-width:50px;padding:0 12px}.v-btn--size-default{--v-btn-size: .875rem;--v-btn-height: 36px;font-size:var(--v-btn-size);min-width:64px;padding:0 16px}.v-btn--size-large{--v-btn-size: 1rem;--v-btn-height: 44px;font-size:var(--v-btn-size);min-width:78px;padding:0 20px}.v-btn--size-x-large{--v-btn-size: 1.125rem;--v-btn-height: 52px;font-size:var(--v-btn-size);min-width:92px;padding:0 24px}.v-btn.v-btn--density-default{height:calc(var(--v-btn-height) + 0px)}.v-btn.v-btn--density-comfortable{height:calc(var(--v-btn-height) + -8px)}.v-btn.v-btn--density-compact{height:calc(var(--v-btn-height) + -12px)}.v-btn{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-btn--border{border-width:thin;box-shadow:none}.v-btn--absolute{position:absolute}.v-btn--fixed{position:fixed}.v-btn:hover>.v-btn__overlay{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-btn:focus-visible>.v-btn__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-btn:focus>.v-btn__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}}.v-btn--active>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]>.v-btn__overlay{opacity:calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier))}.v-btn--active:hover>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]:hover>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}.v-btn--active:focus-visible>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]:focus-visible>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-btn--active:focus>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]:focus>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}}.v-btn--variant-plain,.v-btn--variant-outlined,.v-btn--variant-text,.v-btn--variant-tonal{background:transparent;color:inherit}.v-btn--variant-plain{opacity:.62}.v-btn--variant-plain:focus,.v-btn--variant-plain:hover{opacity:1}.v-btn--variant-plain .v-btn__overlay{display:none}.v-btn--variant-elevated,.v-btn--variant-flat{background:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-btn--variant-elevated{box-shadow:0 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 2px 2px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 5px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-btn--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-btn--variant-outlined{border:thin solid currentColor}.v-btn--variant-text .v-btn__overlay{background:currentColor}.v-btn--variant-tonal .v-btn__underlay{background:currentColor;opacity:var(--v-activated-opacity);border-radius:inherit;top:0;right:0;bottom:0;left:0;pointer-events:none}.v-btn .v-btn__underlay{position:absolute}@supports selector(:focus-visible){.v-btn:after{pointer-events:none;border:2px solid currentColor;border-radius:inherit;opacity:0;transition:opacity .2s ease-in-out}.v-btn:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%}.v-btn:focus-visible:after{opacity:calc(.25 * var(--v-theme-overlay-multiplier))}}.v-btn--icon{border-radius:50%;min-width:0;padding:0}.v-btn--icon.v-btn--size-default{--v-btn-size: 1rem}.v-btn--icon.v-btn--density-default{width:calc(var(--v-btn-height) + 12px);height:calc(var(--v-btn-height) + 12px)}.v-btn--icon.v-btn--density-comfortable{width:calc(var(--v-btn-height) + 0px);height:calc(var(--v-btn-height) + 0px)}.v-btn--icon.v-btn--density-compact{width:calc(var(--v-btn-height) + -8px);height:calc(var(--v-btn-height) + -8px)}.v-btn--elevated:hover,.v-btn--elevated:focus{box-shadow:0 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 4px 5px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 10px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-btn--elevated:active{box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-btn--flat{box-shadow:none}.v-btn--block{display:flex;flex:1 0 auto;min-width:100%}.v-btn--disabled{pointer-events:none;opacity:.26}.v-btn--disabled:hover{opacity:.26}.v-btn--disabled.v-btn--variant-elevated,.v-btn--disabled.v-btn--variant-flat{box-shadow:none;opacity:1;color:rgba(var(--v-theme-on-surface),.26);background:rgb(var(--v-theme-surface))}.v-btn--disabled.v-btn--variant-elevated .v-btn__overlay,.v-btn--disabled.v-btn--variant-flat .v-btn__overlay{opacity:.4615384615}.v-btn--loading{pointer-events:none}.v-btn--loading .v-btn__content,.v-btn--loading .v-btn__prepend,.v-btn--loading .v-btn__append{opacity:0}.v-btn--stacked{grid-template-areas:"prepend" "content" "append";grid-template-columns:auto;grid-template-rows:max-content max-content max-content;justify-items:center;align-content:center}.v-btn--stacked .v-btn__content{flex-direction:column;line-height:1.25}.v-btn--stacked .v-btn__prepend,.v-btn--stacked .v-btn__append,.v-btn--stacked .v-btn__content>.v-icon--start,.v-btn--stacked .v-btn__content>.v-icon--end{margin-inline:0}.v-btn--stacked .v-btn__prepend,.v-btn--stacked .v-btn__content>.v-icon--start{margin-bottom:4px}.v-btn--stacked .v-btn__append,.v-btn--stacked .v-btn__content>.v-icon--end{margin-top:4px}.v-btn--stacked.v-btn--size-x-small{--v-btn-size: .625rem;--v-btn-height: 56px;font-size:var(--v-btn-size);min-width:56px;padding:0 12px}.v-btn--stacked.v-btn--size-small{--v-btn-size: .75rem;--v-btn-height: 64px;font-size:var(--v-btn-size);min-width:64px;padding:0 14px}.v-btn--stacked.v-btn--size-default{--v-btn-size: .875rem;--v-btn-height: 72px;font-size:var(--v-btn-size);min-width:72px;padding:0 16px}.v-btn--stacked.v-btn--size-large{--v-btn-size: 1rem;--v-btn-height: 80px;font-size:var(--v-btn-size);min-width:80px;padding:0 18px}.v-btn--stacked.v-btn--size-x-large{--v-btn-size: 1.125rem;--v-btn-height: 88px;font-size:var(--v-btn-size);min-width:88px;padding:0 20px}.v-btn--stacked.v-btn--density-default{height:calc(var(--v-btn-height) + 0px)}.v-btn--stacked.v-btn--density-comfortable{height:calc(var(--v-btn-height) + -16px)}.v-btn--stacked.v-btn--density-compact{height:calc(var(--v-btn-height) + -24px)}.v-btn--slim{padding:0 8px}.v-btn--readonly{pointer-events:none}.v-btn--rounded{border-radius:24px}.v-btn--rounded.v-btn--icon{border-radius:4px}.v-btn .v-icon{--v-icon-size-multiplier: .8571428571}.v-btn--icon .v-icon{--v-icon-size-multiplier: 1}.v-btn--stacked .v-icon{--v-icon-size-multiplier: 1.1428571429}.v-btn--stacked.v-btn--block{min-width:100%}.v-btn__loader{align-items:center;display:flex;height:100%;justify-content:center;left:0;position:absolute;top:0;width:100%}.v-btn__loader>.v-progress-circular{width:1.5em;height:1.5em}.v-btn__content,.v-btn__prepend,.v-btn__append{align-items:center;display:flex;transition:transform,opacity .2s cubic-bezier(.4,0,.2,1)}.v-btn__prepend{grid-area:prepend;margin-inline:calc(var(--v-btn-height) / -9) calc(var(--v-btn-height) / 4.5)}.v-btn--slim .v-btn__prepend{margin-inline-start:0}.v-btn__append{grid-area:append;margin-inline:calc(var(--v-btn-height) / 4.5) calc(var(--v-btn-height) / -9)}.v-btn--slim .v-btn__append{margin-inline-end:0}.v-btn__content{grid-area:content;justify-content:center;white-space:nowrap}.v-btn__content>.v-icon--start{margin-inline:calc(var(--v-btn-height) / -9) calc(var(--v-btn-height) / 4.5)}.v-btn__content>.v-icon--end{margin-inline:calc(var(--v-btn-height) / 4.5) calc(var(--v-btn-height) / -9)}.v-btn--stacked .v-btn__content{white-space:normal}.v-btn__overlay{background-color:currentColor;border-radius:inherit;opacity:0;transition:opacity .2s ease-in-out}.v-btn__overlay,.v-btn__underlay{pointer-events:none}.v-btn__overlay,.v-btn__underlay{position:absolute;top:0;left:0;width:100%;height:100%}.v-pagination .v-btn{width:auto;padding-inline:5px}.v-pagination .v-btn.v-btn--density-default{min-width:calc(var(--v-btn-height) + 12px)}.v-pagination .v-btn.v-btn--density-comfortable{min-width:calc(var(--v-btn-height) + 0px)}.v-pagination .v-btn.v-btn--density-compact{min-width:calc(var(--v-btn-height) + -8px)}.v-pagination .v-btn{border-radius:4px}.v-pagination .v-btn--rounded{border-radius:50%}.v-pagination .v-btn__overlay{transition:none}.v-pagination__prev .v-btn,.v-pagination__next .v-btn{padding-inline:0}.v-pagination__prev .v-btn.v-btn--density-default,.v-pagination__next .v-btn.v-btn--density-default{width:calc(var(--v-btn-height) + 12px)}.v-pagination__prev .v-btn.v-btn--density-comfortable,.v-pagination__next .v-btn.v-btn--density-comfortable{width:calc(var(--v-btn-height) + 0px)}.v-pagination__prev .v-btn.v-btn--density-compact,.v-pagination__next .v-btn.v-btn--density-compact{width:calc(var(--v-btn-height) + -8px)}.v-pagination .v-pagination__item--is-active .v-btn__overlay{opacity:var(--v-border-opacity)}.v-btn-toggle>.v-btn.v-btn--active:not(.v-btn--disabled)>.v-btn__overlay{opacity:calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier))}.v-btn-toggle>.v-btn.v-btn--active:not(.v-btn--disabled):hover>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}.v-btn-toggle>.v-btn.v-btn--active:not(.v-btn--disabled):focus-visible>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-btn-toggle>.v-btn.v-btn--active:not(.v-btn--disabled):focus>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}}.v-btn-toggle>.v-btn.v-btn--active:not(.v-btn--disabled).v-btn--variant-plain{opacity:1}.v-btn-group{display:inline-flex;flex-wrap:nowrap;max-width:100%;min-width:0;overflow-y:hidden;overflow-x:auto;vertical-align:middle}.v-btn-group{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-btn-group--border{border-width:thin;box-shadow:none}.v-btn-group{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-btn-group{border-radius:4px}.v-btn-group{background:transparent;color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-btn-group--density-default.v-btn-group{height:48px}.v-btn-group--density-comfortable.v-btn-group{height:40px}.v-btn-group--density-compact.v-btn-group{height:36px}.v-btn-group .v-btn{border-radius:0;border-color:inherit}.v-btn-group--tile{border-radius:0}.v-btn-group--horizontal .v-btn:not(:last-child){border-inline-end:none}.v-btn-group--horizontal .v-btn:not(:first-child){border-inline-start:none}.v-btn-group--horizontal .v-btn:first-child{border-start-start-radius:inherit;border-end-start-radius:inherit}.v-btn-group--horizontal .v-btn:last-child{border-start-end-radius:inherit;border-end-end-radius:inherit}.v-btn-group--horizontal.v-btn-group--divided .v-btn:not(:last-child){border-inline-end-width:thin;border-inline-end-style:solid;border-inline-end-color:rgba(var(--v-border-color),var(--v-border-opacity))}.v-btn-group--vertical{flex-direction:column;height:auto!important}.v-btn-group--vertical .v-btn:not(:last-child){border-block-end:none}.v-btn-group--vertical .v-btn:not(:first-child){border-block-start:none}.v-btn-group--vertical .v-btn:first-child{border-start-start-radius:inherit;border-start-end-radius:inherit}.v-btn-group--vertical .v-btn:last-child{border-end-start-radius:inherit;border-end-end-radius:inherit}.v-btn-group--vertical.v-btn-group--divided .v-btn:not(:last-child){border-block-end-width:thin;border-block-end-style:solid;border-block-end-color:rgba(var(--v-border-color),var(--v-border-opacity))}.v-progress-circular{align-items:center;display:inline-flex;justify-content:center;position:relative;vertical-align:middle}.v-progress-circular>svg{width:100%;height:100%;margin:auto;position:absolute;top:0;bottom:0;left:0;right:0;z-index:0}.v-progress-circular__content{align-items:center;display:flex;justify-content:center}.v-progress-circular__underlay{color:rgba(var(--v-border-color),var(--v-border-opacity));stroke:currentColor;z-index:1}.v-progress-circular__overlay{stroke:currentColor;transition:all .2s ease-in-out,stroke-width 0s;z-index:2}.v-progress-circular--size-x-small{height:16px;width:16px}.v-progress-circular--size-small{height:24px;width:24px}.v-progress-circular--size-default{height:32px;width:32px}.v-progress-circular--size-large{height:48px;width:48px}.v-progress-circular--size-x-large{height:64px;width:64px}.v-progress-circular--indeterminate>svg{animation:progress-circular-rotate 1.4s linear infinite;transform-origin:center center;transition:all .2s ease-in-out}.v-progress-circular--indeterminate .v-progress-circular__overlay{animation:progress-circular-dash 1.4s ease-in-out infinite,progress-circular-rotate 1.4s linear infinite;stroke-dasharray:25,200;stroke-dashoffset:0;stroke-linecap:round;transform-origin:center center;transform:rotate(-90deg)}.v-progress-circular--disable-shrink>svg{animation-duration:.7s}.v-progress-circular--disable-shrink .v-progress-circular__overlay{animation:none}.v-progress-circular--indeterminate:not(.v-progress-circular--visible)>svg,.v-progress-circular--indeterminate:not(.v-progress-circular--visible) .v-progress-circular__overlay{animation-play-state:paused!important}@keyframes progress-circular-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0px}50%{stroke-dasharray:100,200;stroke-dashoffset:-15px}to{stroke-dasharray:100,200;stroke-dashoffset:-124px}}@keyframes progress-circular-rotate{to{transform:rotate(270deg)}}.v-card{display:block;overflow:hidden;overflow-wrap:break-word;position:relative;padding:0;text-decoration:none;transition-duration:.28s;transition-property:box-shadow,opacity,background;transition-timing-function:cubic-bezier(.4,0,.2,1);z-index:0}.v-card{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-card--border{border-width:thin;box-shadow:none}.v-card--absolute{position:absolute}.v-card--fixed{position:fixed}.v-card{border-radius:4px}.v-card:hover>.v-card__overlay{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-card:focus-visible>.v-card__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-card:focus>.v-card__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}}.v-card--active>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]>.v-card__overlay{opacity:calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier))}.v-card--active:hover>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]:hover>.v-card__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}.v-card--active:focus-visible>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]:focus-visible>.v-card__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-card--active:focus>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]:focus>.v-card__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}}.v-card--variant-plain,.v-card--variant-outlined,.v-card--variant-text,.v-card--variant-tonal{background:transparent;color:inherit}.v-card--variant-plain{opacity:.62}.v-card--variant-plain:focus,.v-card--variant-plain:hover{opacity:1}.v-card--variant-plain .v-card__overlay{display:none}.v-card--variant-elevated,.v-card--variant-flat{background:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-card--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 3px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-card--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-card--variant-outlined{border:thin solid currentColor}.v-card--variant-text .v-card__overlay{background:currentColor}.v-card--variant-tonal .v-card__underlay{background:currentColor;opacity:var(--v-activated-opacity);border-radius:inherit;top:0;right:0;bottom:0;left:0;pointer-events:none}.v-card .v-card__underlay{position:absolute}.v-card--disabled{pointer-events:none;-webkit-user-select:none;user-select:none}.v-card--disabled>:not(.v-card__loader){opacity:.6}.v-card--flat{box-shadow:none}.v-card--hover{cursor:pointer}.v-card--hover:before,.v-card--hover:after{border-radius:inherit;bottom:0;content:"";display:block;left:0;pointer-events:none;position:absolute;right:0;top:0;transition:inherit}.v-card--hover:before{opacity:1;z-index:-1}.v-card--hover:before{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 3px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-card--hover:after{z-index:1;opacity:0}.v-card--hover:after{box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-card--hover:hover:after{opacity:1}.v-card--hover:hover:before{opacity:0}.v-card--hover:hover{box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-card--link{cursor:pointer}.v-card-actions{align-items:center;display:flex;flex:none;min-height:52px;padding:.5rem;gap:.5rem}.v-card-item{align-items:center;display:grid;flex:none;grid-template-areas:"prepend content append";grid-template-columns:max-content auto max-content;padding:.625rem 1rem}.v-card-item+.v-card-text{padding-top:0}.v-card-item__prepend,.v-card-item__append{align-items:center;display:flex}.v-card-item__prepend{grid-area:prepend;padding-inline-end:.5rem}.v-card-item__append{grid-area:append;padding-inline-start:.5rem}.v-card-item__content{align-self:center;grid-area:content;overflow:hidden}.v-card-title{display:block;flex:none;font-size:1.25rem;font-weight:500;-webkit-hyphens:auto;hyphens:auto;letter-spacing:.0125em;min-width:0;overflow-wrap:normal;overflow:hidden;padding:.5rem 1rem;text-overflow:ellipsis;text-transform:none;white-space:nowrap;word-break:normal;word-wrap:break-word}.v-card .v-card-title{line-height:1.6}.v-card--density-comfortable .v-card-title{line-height:1.75rem}.v-card--density-compact .v-card-title{line-height:1.55rem}.v-card-item .v-card-title{padding:0}.v-card-title+.v-card-text,.v-card-title+.v-card-actions{padding-top:0}.v-card-subtitle{display:block;flex:none;font-size:.875rem;font-weight:400;letter-spacing:.0178571429em;opacity:var(--v-card-subtitle-opacity, var(--v-medium-emphasis-opacity));overflow:hidden;padding:0 1rem;text-overflow:ellipsis;text-transform:none;white-space:nowrap}.v-card .v-card-subtitle{line-height:1.425}.v-card--density-comfortable .v-card-subtitle{line-height:1.125rem}.v-card--density-compact .v-card-subtitle{line-height:1rem}.v-card-item .v-card-subtitle{padding:0 0 .25rem}.v-card-text{flex:1 1 auto;font-size:.875rem;font-weight:400;letter-spacing:.0178571429em;opacity:var(--v-card-text-opacity, 1);padding:1rem;text-transform:none}.v-card .v-card-text{line-height:1.425}.v-card--density-comfortable .v-card-text{line-height:1.2rem}.v-card--density-compact .v-card-text{line-height:1.15rem}.v-card__image{display:flex;height:100%;flex:1 1 auto;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:-1}.v-card__content{border-radius:inherit;overflow:hidden;position:relative}.v-card__loader{bottom:auto;top:0;left:0;position:absolute;right:0;width:100%;z-index:1}.v-card__overlay{background-color:currentColor;border-radius:inherit;position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;opacity:0;transition:opacity .2s ease-in-out}.flag[data-v-d1ce1a9a]{width:28px;height:18px;cursor:pointer}.flag-wrapper[data-v-d1ce1a9a]{display:flex;align-items:center;cursor:pointer}.arrow[data-v-d1ce1a9a]{margin-left:4px;transition:transform .3s ease}.arrow[data-v-d1ce1a9a]:active{transform:rotate(90deg)}.app-logo[data-v-f9d3029e]{height:40px;max-width:150px}.v-app-bar{display:flex}.v-app-bar.v-toolbar{background:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-app-bar.v-toolbar:not(.v-toolbar--flat){box-shadow:0 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 4px 5px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 10px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-app-bar:not(.v-toolbar--absolute){padding-inline-end:var(--v-scrollbar-offset)}.v-toolbar{align-items:flex-start;display:flex;flex:none;flex-direction:column;justify-content:space-between;max-width:100%;position:relative;transition:.2s cubic-bezier(.4,0,.2,1);transition-property:height,width,transform,max-width,left,right,top,bottom,box-shadow;width:100%}.v-toolbar{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-toolbar--border{border-width:thin;box-shadow:none}.v-toolbar{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-toolbar{border-radius:0}.v-toolbar{background:rgb(var(--v-theme-surface-light));color:rgba(var(--v-theme-on-surface-light),var(--v-high-emphasis-opacity))}.v-toolbar--absolute{position:absolute}.v-toolbar--collapse{max-width:112px;overflow:hidden;border-end-end-radius:24px}.v-toolbar--collapse .v-toolbar-title{display:none}.v-toolbar--flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-toolbar--floating{display:inline-flex;width:auto}.v-toolbar--rounded{border-radius:4px}.v-toolbar__content,.v-toolbar__extension{align-items:center;display:flex;flex:0 0 auto;position:relative;transition:inherit;width:100%}.v-toolbar__content{overflow:hidden}.v-toolbar__content>.v-btn:first-child{margin-inline-start:4px}.v-toolbar__content>.v-btn:last-child{margin-inline-end:4px}.v-toolbar__content>.v-toolbar-title{margin-inline-start:20px}.v-toolbar--density-prominent .v-toolbar__content{align-items:flex-start}.v-toolbar__image{display:flex;opacity:var(--v-toolbar-image-opacity, 1);transition-property:opacity}.v-toolbar__image{position:absolute;top:0;left:0;width:100%;height:100%}.v-toolbar__prepend,.v-toolbar__append{align-items:center;align-self:stretch;display:flex}.v-toolbar__prepend{margin-inline:4px auto}.v-toolbar__append{margin-inline:auto 4px}.v-toolbar-title{flex:1 1;font-size:1.25rem;min-width:0}.v-toolbar-title{font-size:1.25rem;font-weight:400;letter-spacing:0;line-height:1.75rem;text-transform:none}.v-toolbar--density-prominent .v-toolbar-title{align-self:flex-end;padding-bottom:6px}.v-toolbar--density-prominent .v-toolbar-title{font-size:1.5rem;font-weight:400;letter-spacing:0;line-height:2.25rem;text-transform:none}.v-toolbar-title__placeholder{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.v-toolbar-items{display:flex;height:inherit;align-self:stretch}.v-toolbar-items>.v-btn{border-radius:0}.v-navigation-drawer{-webkit-overflow-scrolling:touch;background:rgb(var(--v-theme-surface));display:flex;flex-direction:column;height:100%;max-width:100%;pointer-events:auto;transition-duration:.2s;transition-property:box-shadow,transform,visibility,width,height,left,right,top,bottom;transition-timing-function:cubic-bezier(.4,0,.2,1);position:absolute}.v-navigation-drawer{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-navigation-drawer--border{border-width:thin;box-shadow:none}.v-navigation-drawer{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-navigation-drawer{background:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-navigation-drawer--rounded{border-radius:4px}.v-navigation-drawer--top{top:0;border-bottom-width:thin}.v-navigation-drawer--bottom{left:0;border-top-width:thin}.v-navigation-drawer--left{top:0;left:0;right:auto;border-right-width:thin}.v-navigation-drawer--right{top:0;left:auto;right:0;border-left-width:thin}.v-navigation-drawer--floating{border:none}.v-navigation-drawer--temporary.v-navigation-drawer--active{box-shadow:0 8px 10px -5px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 16px 24px 2px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 6px 30px 5px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-navigation-drawer--sticky{height:auto;transition:box-shadow,transform,visibility,width,height,left,right}.v-navigation-drawer .v-list{overflow:hidden}.v-navigation-drawer__content{flex:0 1 auto;height:100%;max-width:100%;overflow-x:hidden;overflow-y:auto}.v-navigation-drawer__img{height:100%;left:0;position:absolute;top:0;width:100%;z-index:-1}.v-navigation-drawer__img img:not(.v-img__img){height:inherit;object-fit:cover;width:inherit}.v-navigation-drawer__scrim{position:absolute;top:0;left:0;width:100%;height:100%;background:#000;opacity:.2;transition:opacity .2s cubic-bezier(.4,0,.2,1);z-index:1}.v-navigation-drawer__prepend,.v-navigation-drawer__append{flex:none;overflow:hidden}.footer-link[data-v-5d96d66f]{color:#42b983;font-weight:700;transition:color .3s ease}.footer-link[data-v-5d96d66f]:hover{color:#2c3e50;text-decoration:underline}.fast-site-link[data-v-5d96d66f]{color:#42b983;font-weight:700;transition:color .3s ease}.fast-site-link[data-v-5d96d66f]:hover{color:#2c3e50;text-decoration:underline}.v-footer{align-items:center;display:flex;flex:1 1 auto;padding:8px 16px;position:relative;transition:.2s cubic-bezier(.4,0,.2,1);transition-property:height,width,transform,max-width,left,right,top,bottom}.v-footer{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-footer--border{border-width:thin;box-shadow:none}.v-footer{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-footer--absolute{position:absolute}.v-footer--fixed{position:fixed}.v-footer{border-radius:0}.v-footer{background:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-footer--rounded{border-radius:4px}:root,:host{--ol-background-color: white;--ol-accent-background-color: #F5F5F5;--ol-subtle-background-color: rgba(128, 128, 128, .25);--ol-partial-background-color: rgba(255, 255, 255, .75);--ol-foreground-color: #333333;--ol-subtle-foreground-color: #666666;--ol-brand-color: #00AAFF}.ol-box{box-sizing:border-box;border-radius:2px;border:1.5px solid var(--ol-background-color);background-color:var(--ol-partial-background-color)}.ol-mouse-position{top:8px;right:8px;position:absolute}.ol-scale-line{background:var(--ol-partial-background-color);border-radius:4px;bottom:8px;left:8px;padding:2px;position:absolute}.ol-scale-line-inner{border:1px solid var(--ol-subtle-foreground-color);border-top:none;color:var(--ol-foreground-color);font-size:10px;text-align:center;margin:1px;will-change:contents,width;transition:all .25s}.ol-scale-bar{position:absolute;bottom:8px;left:8px}.ol-scale-bar-inner{display:flex}.ol-scale-step-marker{width:1px;height:15px;background-color:var(--ol-foreground-color);float:right;z-index:10}.ol-scale-step-text{position:absolute;bottom:-5px;font-size:10px;z-index:11;color:var(--ol-foreground-color);text-shadow:-1.5px 0 var(--ol-partial-background-color),0 1.5px var(--ol-partial-background-color),1.5px 0 var(--ol-partial-background-color),0 -1.5px var(--ol-partial-background-color)}.ol-scale-text{position:absolute;font-size:12px;text-align:center;bottom:25px;color:var(--ol-foreground-color);text-shadow:-1.5px 0 var(--ol-partial-background-color),0 1.5px var(--ol-partial-background-color),1.5px 0 var(--ol-partial-background-color),0 -1.5px var(--ol-partial-background-color)}.ol-scale-singlebar{position:relative;height:10px;z-index:9;box-sizing:border-box;border:1px solid var(--ol-foreground-color)}.ol-scale-singlebar-even{background-color:var(--ol-subtle-foreground-color)}.ol-scale-singlebar-odd{background-color:var(--ol-background-color)}.ol-unsupported{display:none}.ol-viewport,.ol-unselectable{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.ol-viewport canvas{all:unset;overflow:hidden}.ol-viewport{touch-action:pan-x pan-y}.ol-selectable{-webkit-touch-callout:default;-webkit-user-select:text;-moz-user-select:text;user-select:text}.ol-grabbing{cursor:-webkit-grabbing;cursor:-moz-grabbing;cursor:grabbing}.ol-grab{cursor:move;cursor:-webkit-grab;cursor:-moz-grab;cursor:grab}.ol-control{position:absolute;background-color:var(--ol-subtle-background-color);border-radius:4px}.ol-zoom{top:.5em;left:.5em}.ol-rotate{top:.5em;right:.5em;transition:opacity .25s linear,visibility 0s linear}.ol-rotate.ol-hidden{opacity:0;visibility:hidden;transition:opacity .25s linear,visibility 0s linear .25s}.ol-zoom-extent{top:4.643em;left:.5em}.ol-full-screen{right:.5em;top:.5em}.ol-control button{display:block;margin:1px;padding:0;color:var(--ol-subtle-foreground-color);font-weight:700;text-decoration:none;font-size:inherit;text-align:center;height:1.375em;width:1.375em;line-height:.4em;background-color:var(--ol-background-color);border:none;border-radius:2px}.ol-control button::-moz-focus-inner{border:none;padding:0}.ol-zoom-extent button{line-height:1.4em}.ol-compass{display:block;font-weight:400;will-change:transform}.ol-touch .ol-control button{font-size:1.5em}.ol-touch .ol-zoom-extent{top:5.5em}.ol-control button:hover,.ol-control button:focus{text-decoration:none;outline:1px solid var(--ol-subtle-foreground-color);color:var(--ol-foreground-color)}.ol-zoom .ol-zoom-in{border-radius:2px 2px 0 0}.ol-zoom .ol-zoom-out{border-radius:0 0 2px 2px}.ol-attribution{text-align:right;bottom:.5em;right:.5em;max-width:calc(100% - 1.3em);display:flex;flex-flow:row-reverse;align-items:center}.ol-attribution a{color:var(--ol-subtle-foreground-color);text-decoration:none}.ol-attribution ul{margin:0;padding:1px .5em;color:var(--ol-foreground-color);text-shadow:0 0 2px var(--ol-background-color);font-size:12px}.ol-attribution li{display:inline;list-style:none}.ol-attribution li:not(:last-child):after{content:" "}.ol-attribution img{max-height:2em;max-width:inherit;vertical-align:middle}.ol-attribution button{flex-shrink:0}.ol-attribution.ol-collapsed ul{display:none}.ol-attribution:not(.ol-collapsed){background:var(--ol-partial-background-color)}.ol-attribution.ol-uncollapsible{bottom:0;right:0;border-radius:4px 0 0}.ol-attribution.ol-uncollapsible img{margin-top:-.2em;max-height:1.6em}.ol-attribution.ol-uncollapsible button{display:none}.ol-zoomslider{top:4.5em;left:.5em;height:200px}.ol-zoomslider button{position:relative;height:10px}.ol-touch .ol-zoomslider{top:5.5em}.ol-overviewmap{left:.5em;bottom:.5em}.ol-overviewmap.ol-uncollapsible{bottom:0;left:0;border-radius:0 4px 0 0}.ol-overviewmap .ol-overviewmap-map,.ol-overviewmap button{display:block}.ol-overviewmap .ol-overviewmap-map{border:1px solid var(--ol-subtle-foreground-color);height:150px;width:150px}.ol-overviewmap:not(.ol-collapsed) button{bottom:0;left:0;position:absolute}.ol-overviewmap.ol-collapsed .ol-overviewmap-map,.ol-overviewmap.ol-uncollapsible button{display:none}.ol-overviewmap:not(.ol-collapsed){background:var(--ol-subtle-background-color)}.ol-overviewmap-box{border:1.5px dotted var(--ol-subtle-foreground-color)}.ol-overviewmap .ol-overviewmap-box:hover{cursor:move}.nav[data-v-22e77fbc]{display:flex;justify-content:center;align-items:center;text-decoration:none;font-size:13px}.ol-popup[data-v-22e77fbc]{position:absolute;background:#fff;border-radius:8px;padding:8px 12px;min-width:220px;box-shadow:0 3px 14px #0003;pointer-events:auto;transform:translate(-50%);white-space:nowrap;font-size:14px;text-align:center;-webkit-user-select:none;user-select:none;z-index:1000}.ol-popup-arrow[data-v-22e77fbc]{position:absolute;width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-top:10px solid white;left:50%;bottom:-10px;transform:translate(-50%);filter:drop-shadow(0 1px 1px rgba(0,0,0,.1));z-index:1001}.popup-close-btn[data-v-22e77fbc]{position:absolute;top:8px;right:10px;background:transparent;border:none;font-size:18px;font-weight:700;cursor:pointer;line-height:1;color:#999;transition:color .2s;z-index:1002}.popup-close-btn[data-v-22e77fbc]:hover{color:#333}.articles-wrapper[data-v-d2a4554c]{display:flex;flex-wrap:wrap;justify-content:space-around}.article-item[data-v-d2a4554c]{width:300px;border-radius:8px}.img[data-v-d2a4554c]{width:100%;height:300px;object-fit:cover;border-radius:4px}.link[data-v-d2a4554c]{cursor:pointer;font-weight:600;text-decoration:none;position:relative;display:inline-block}.link[data-v-d2a4554c]:after{content:"";position:absolute;left:0%;bottom:-2px;width:50%;height:2px;background-color:currentColor;transition:width .3s ease,left .3s ease}.link[data-v-d2a4554c]:hover:after{width:100%;left:0;transform:none}.caption[data-v-f361fddd]{position:absolute;bottom:25px;left:15px;color:#fff;font-size:larger}.caption-mobile[data-v-f361fddd]{position:absolute;bottom:60px;right:25px;text-align:right;color:#fff;font-size:larger}.custom-controls[data-v-f361fddd]{position:absolute;bottom:25px;right:25px;display:flex;align-items:center;justify-content:center}.custom-dot[data-v-f361fddd]{width:10px;height:10px;border-radius:50%;background-color:#fff;cursor:pointer}.v-carousel{overflow:hidden;position:relative;width:100%}.v-carousel__controls{align-items:center;bottom:0;display:flex;height:50px;justify-content:center;list-style-type:none;position:absolute;width:100%;z-index:1}.v-carousel__controls{background:rgba(var(--v-theme-surface-variant),.3);color:rgb(var(--v-theme-on-surface-variant))}.v-carousel__controls>.v-item-group{flex:0 1 auto}.v-carousel__controls__item{margin:0 8px}.v-carousel__controls__item .v-icon{opacity:.5}.v-carousel__controls__item--active .v-icon{opacity:1;vertical-align:middle}.v-carousel__controls__item:hover{background:none}.v-carousel__controls__item:hover .v-icon{opacity:.8}.v-carousel__progress{margin:0;bottom:0;left:0;right:0}.v-carousel-item{display:block;height:inherit;text-decoration:none}.v-carousel-item>.v-img{height:inherit}.v-carousel--hide-delimiter-background .v-carousel__controls{background:transparent}.v-carousel--vertical-delimiters .v-carousel__controls{flex-direction:column;height:100%!important;width:50px}.v-window{overflow:hidden}.v-window__container{display:flex;flex-direction:column;height:inherit;position:relative;transition:.3s cubic-bezier(.25,.8,.5,1)}.v-window__controls{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:space-between;padding:0 16px;pointer-events:none}.v-window__controls>*{pointer-events:auto}.v-window--show-arrows-on-hover{overflow:hidden}.v-window--show-arrows-on-hover .v-window__left{transform:translate(-200%)}.v-window--show-arrows-on-hover .v-window__right{transform:translate(200%)}.v-window--show-arrows-on-hover:hover .v-window__left,.v-window--show-arrows-on-hover:hover .v-window__right{transform:translate(0)}.v-window--vertical-arrows .v-window__controls{flex-direction:column;justify-content:center;gap:12px}.v-window--vertical-arrows .v-window__controls--left{align-items:start}.v-window--vertical-arrows .v-window__controls--right{align-items:end}.v-window--vertical-arrows .v-window__controls .v-window__left .v-icon,.v-window--vertical-arrows .v-window__controls .v-window__right .v-icon{transform:rotate(90deg)}.v-window-x-transition-enter-active,.v-window-x-transition-leave-active,.v-window-x-reverse-transition-enter-active,.v-window-x-reverse-transition-leave-active,.v-window-y-transition-enter-active,.v-window-y-transition-leave-active,.v-window-y-reverse-transition-enter-active,.v-window-y-reverse-transition-leave-active{transition:.3s cubic-bezier(.25,.8,.5,1)}.v-window-x-transition-leave-from,.v-window-x-transition-leave-to,.v-window-x-reverse-transition-leave-from,.v-window-x-reverse-transition-leave-to,.v-window-y-transition-leave-from,.v-window-y-transition-leave-to,.v-window-y-reverse-transition-leave-from,.v-window-y-reverse-transition-leave-to{position:absolute!important;top:0;width:100%}.v-window-x-transition-enter-from{transform:translate(100%)}.v-window-x-transition-leave-to,.v-window-x-reverse-transition-enter-from{transform:translate(-100%)}.v-window-x-reverse-transition-leave-to{transform:translate(100%)}.v-window-y-transition-enter-from{transform:translateY(100%)}.v-window-y-transition-leave-to,.v-window-y-reverse-transition-enter-from{transform:translateY(-100%)}.v-window-y-reverse-transition-leave-to{transform:translateY(100%)}.v-expansion-panel{background-color:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-expansion-panel:not(:first-child):after{border-color:rgba(var(--v-border-color),var(--v-border-opacity))}.v-expansion-panel--disabled .v-expansion-panel-title{color:rgba(var(--v-theme-on-surface),.26)}.v-expansion-panel--disabled .v-expansion-panel-title .v-expansion-panel-title__overlay{opacity:.4615384615}.v-expansion-panels{display:flex;flex-wrap:wrap;justify-content:center;list-style-type:none;padding:0;width:100%;position:relative;z-index:1}.v-expansion-panels:not(.v-expansion-panels--variant-accordion)>:not(:first-child):not(:last-child):not(.v-expansion-panel--active):not(.v-expansion-panel--before-active){border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}.v-expansion-panels:not(.v-expansion-panels--variant-accordion)>:not(:first-child):not(:last-child):not(.v-expansion-panel--active):not(.v-expansion-panel--after-active){border-top-left-radius:0!important;border-top-right-radius:0!important}.v-expansion-panels:not(.v-expansion-panels--variant-accordion)>:first-child:not(:last-child):not(.v-expansion-panel--active):not(.v-expansion-panel--before-active){border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}.v-expansion-panels:not(.v-expansion-panels--variant-accordion)>:last-child:not(:first-child):not(.v-expansion-panel--active):not(.v-expansion-panel--after-active){border-top-left-radius:0!important;border-top-right-radius:0!important}.v-expansion-panels--variant-accordion>:first-child:not(:last-child){border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}.v-expansion-panels--variant-accordion>:last-child:not(:first-child){border-top-left-radius:0!important;border-top-right-radius:0!important}.v-expansion-panels--variant-accordion>:last-child:not(:first-child) .v-expansion-panel-title--active{border-bottom-left-radius:initial;border-bottom-right-radius:initial}.v-expansion-panels--variant-accordion>:not(:first-child):not(:last-child){border-radius:0!important}.v-expansion-panels--variant-accordion .v-expansion-panel-title__overlay{transition:.3s border-radius cubic-bezier(.4,0,.2,1)}.v-expansion-panel{flex:1 0 100%;max-width:100%;position:relative;transition:.3s all cubic-bezier(.4,0,.2,1);transition-property:margin-top,border-radius,border,max-width;border-radius:4px}.v-expansion-panel:not(:first-child):after{border-top-style:solid;border-top-width:thin;content:"";left:0;position:absolute;right:0;top:0;transition:.3s opacity cubic-bezier(.4,0,.2,1)}.v-expansion-panel--disabled .v-expansion-panel-title{pointer-events:none}.v-expansion-panel--active:not(:first-child),.v-expansion-panel--active+.v-expansion-panel{margin-top:16px}.v-expansion-panel--active:not(:first-child):after,.v-expansion-panel--active+.v-expansion-panel:after{opacity:0}.v-expansion-panel--active>.v-expansion-panel-title{border-bottom-left-radius:0;border-bottom-right-radius:0}.v-expansion-panel--active>.v-expansion-panel-title:not(.v-expansion-panel-title--static){min-height:64px}.v-expansion-panel__shadow{border-radius:inherit;z-index:-1}.v-expansion-panel__shadow{position:absolute;top:0;left:0;width:100%;height:100%}.v-expansion-panel__shadow{box-shadow:0 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 2px 2px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 5px 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-expansion-panel-title{align-items:center;text-align:start;border-radius:inherit;display:flex;font-size:.9375rem;line-height:1;min-height:48px;outline:none;padding:16px 24px;position:relative;transition:.3s min-height cubic-bezier(.4,0,.2,1);width:100%;justify-content:space-between}.v-expansion-panel-title:hover>.v-expansion-panel-title__overlay{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-expansion-panel-title:focus-visible>.v-expansion-panel-title__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-expansion-panel-title:focus>.v-expansion-panel-title__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}}.v-expansion-panel-title--focusable.v-expansion-panel-title--active .v-expansion-panel-title__overlay{opacity:calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier))}.v-expansion-panel-title--focusable.v-expansion-panel-title--active:hover .v-expansion-panel-title__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}.v-expansion-panel-title--focusable.v-expansion-panel-title--active:focus-visible .v-expansion-panel-title__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-expansion-panel-title--focusable.v-expansion-panel-title--active:focus .v-expansion-panel-title__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}}.v-expansion-panel-title__overlay{background-color:currentColor;border-radius:inherit;opacity:0}.v-expansion-panel-title__overlay{position:absolute;top:0;left:0;width:100%;height:100%}.v-expansion-panel-title__icon{display:inline-flex;margin-bottom:-4px;margin-top:-4px;-webkit-user-select:none;user-select:none;margin-inline-start:auto}.v-expansion-panel-text{display:flex}.v-expansion-panel-text__wrapper{padding:8px 24px 16px;flex:1 1 auto;max-width:100%}.v-expansion-panels--variant-accordion>.v-expansion-panel{margin-top:0}.v-expansion-panels--variant-accordion>.v-expansion-panel:after{opacity:1}.v-expansion-panels--variant-popout>.v-expansion-panel{max-width:calc(100% - 32px)}.v-expansion-panels--variant-popout>.v-expansion-panel--active{max-width:calc(100% + 16px)}.v-expansion-panels--variant-inset>.v-expansion-panel{max-width:100%}.v-expansion-panels--variant-inset>.v-expansion-panel--active{max-width:calc(100% - 32px)}.v-expansion-panels--flat>.v-expansion-panel:after{border-top:none}.v-expansion-panels--flat>.v-expansion-panel .v-expansion-panel__shadow{display:none}.v-expansion-panels--tile{border-radius:0}.v-expansion-panels--tile>.v-expansion-panel{border-radius:0}.contact__text[data-v-4734370a]{white-space:normal}.v-textarea .v-field{--v-textarea-control-height: var(--v-input-control-height)}.v-textarea .v-field__field{--v-input-control-height: var(--v-textarea-control-height)}.v-textarea .v-field__input{flex:1 1 auto;outline:none;-webkit-mask-image:linear-gradient(to bottom,transparent,transparent calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) - 6px),black calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) + 4px));mask-image:linear-gradient(to bottom,transparent,transparent calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) - 6px),black calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) + 4px))}.v-textarea .v-field__input.v-textarea__sizer{visibility:hidden;position:absolute;top:0;left:0;height:0!important;min-height:0!important;pointer-events:none}.v-textarea--no-resize .v-field__input{resize:none}.v-textarea .v-field--no-label textarea,.v-textarea .v-field--active textarea{opacity:1}.v-textarea textarea{opacity:0;flex:1;min-width:0;height:100%;transition:.15s opacity cubic-bezier(.4,0,.2,1)}.v-textarea textarea:focus,.v-textarea textarea:active{outline:none}.v-textarea textarea:invalid{box-shadow:none}.brand_item[data-v-07e05de9]{margin-right:25px;border:0px;display:flex;justify-content:center;align-items:center}.img-wrapper[data-v-8395df3e]{width:100%;height:600px;overflow:hidden;position:relative}.img-wrapper.mobile-height[data-v-8395df3e]{height:400px!important}.img[data-v-8395df3e]{width:100%;height:100%;object-fit:cover;display:block}.carousel--mobile[data-v-8395df3e] .v-btn.v-btn--icon{width:35px!important;height:35px!important;font-size:14px!important}.v-sheet{display:block}.v-sheet{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-sheet--border{border-width:thin;box-shadow:none}.v-sheet{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, .12))}.v-sheet--absolute{position:absolute}.v-sheet--fixed{position:fixed}.v-sheet--relative{position:relative}.v-sheet--sticky{position:sticky}.v-sheet{border-radius:0}.v-sheet{background:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-sheet--rounded{border-radius:4px}.social-container[data-v-8ea47031]{display:flex;align-items:center;justify-content:center;position:fixed;right:15px;border-radius:100%;z-index:999;cursor:pointer}.shadown[data-v-8ea47031]{box-shadow:0 4px 4px #0003;transition:box-shadow 225ms}.shadown[data-v-8ea47031]:hover{box-shadow:0 10px 14px #0003}.v-application{display:flex;background:rgb(var(--v-theme-background));color:rgba(var(--v-theme-on-background),var(--v-high-emphasis-opacity))}.v-application__wrap{backface-visibility:hidden;display:flex;flex-direction:column;flex:1 1 auto;max-width:100%;min-height:100vh;min-height:100dvh;position:relative}html{overflow-y:auto}.margin_top__default{margin-top:25px}.v-main{flex:1 0 auto;max-width:100%;transition:.2s cubic-bezier(.4,0,.2,1);padding-left:var(--v-layout-left);padding-right:var(--v-layout-right);padding-top:var(--v-layout-top);padding-bottom:var(--v-layout-bottom)}.v-main__scroller{max-width:100%;position:relative}.v-main--scrollable{display:flex}.v-main--scrollable{position:absolute;top:0;left:0;width:100%;height:100%}.v-main--scrollable>.v-main__scroller{flex:1 1 auto;overflow-y:auto;--v-layout-left: 0px;--v-layout-right: 0px;--v-layout-top: 0px;--v-layout-bottom: 0px}')),document.head.appendChild(e)}}catch(i){console.error("vite-plugin-css-injected-by-js",i)}})();
var Lm = Object.defineProperty;
var Vm = (t, e, n) => e in t ? Lm(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Yu = (t, e, n) => Vm(t, typeof e != "symbol" ? e + "" : e, n);
import { ref as Z, onMounted as at, onUnmounted as Zd, createElementBlock as Ie, openBlock as J, normalizeStyle as re, createElementVNode as w, onBeforeUnmount as pt, Fragment as pe, shallowRef as Q, capitalize as _o, reactive as cn, watchEffect as Pt, toRef as O, isVNode as Bm, Comment as Fm, unref as W, camelize as Ss, getCurrentInstance as Kd, inject as Ne, computed as E, provide as ht, warn as Ar, defineComponent as km, h as Ta, toRefs as Om, toValue as Vn, createVNode as S, mergeProps as oe, normalizeClass as te, Text as Dm, isRef as Gl, TransitionGroup as bs, Transition as Si, watch as ie, onBeforeMount as Rr, nextTick as Ye, withDirectives as it, vShow as Pi, onScopeDispose as _t, effectScope as Ms, toRaw as lt, useId as Ti, markRaw as Gm, onUpdated as Nm, readonly as Ir, resolveDynamicComponent as qd, toDisplayString as Ge, Teleport as Wm, onDeactivated as xs, cloneVNode as $m, createTextVNode as ct, withCtx as H, createBlock as Ce, createCommentVNode as Ae, renderList as Ft, withModifiers as Ja, normalizeProps as ju, onActivated as Jd, version as Xm, vModelText as Um } from "vue";
import { defineStore as So, storeToRefs as tn } from "pinia";
const Qd = "https://generic-be-test.replit.app/", Ym = (t, e, n, i) => {
  const a = new URL(`${t}${e}`);
  Object.keys(n).forEach((o) => a.searchParams.append(o, n[o])), fetch(a, {
    method: "GET",
    headers: { "Content-Type": "application/json" }
  }).then((o) => {
    if (!o.ok)
      throw new Error(`Errore nella risposta del server: ${o.status} - ${o.statusText}`);
    return o.json();
  }).then((o) => {
    i(o);
  }).catch((o) => {
    console.error("Errore nella richiesta:", o);
  });
}, jm = (t, e, n, i = "POST", a = void 0) => {
  fetch(`${Qd}${t}`, {
    method: i,
    headers: eh(),
    body: JSON.stringify(e)
  }).then((o) => {
    if (!o.ok)
      throw new Error(`Errore nella risposta del server: ${o.status} - ${o.statusText}`);
    return o.json();
  }).then((o) => {
    th(o, n, a);
  }).catch((o) => {
    console.error("Errore nella richiesta:", o);
  });
}, Hm = (t, e, n, i = "GET", a = void 0) => {
  const o = new URL(`${Qd}${t}`);
  Object.keys(e).forEach((r) => o.searchParams.append(r, e[r])), fetch(o, {
    method: i,
    headers: eh()
  }).then((r) => {
    if (!r.ok)
      throw new Error(`Errore nella risposta del server: ${r.status} - ${r.statusText}`);
    return r.json();
  }).then((r) => {
    th(r, n, a);
  }).catch((r) => {
    console.error("Errore nella richiesta:", r);
  });
}, eh = (t = !1) => {
  let e = {
    Token: localStorage.getItem("token")
  };
  return t ? e.Accept = "*/*" : e["Content-Type"] = "application/json", e;
}, th = (t, e, n) => {
  t.status == "session" ? (alert("Sessione scaduta"), n.push("/")) : e(t);
}, Qa = {
  postRequest: jm,
  getRequest: Hm,
  getRequestDemo: Ym
}, Zm = ["Chatty", "Menu"], Km = [{ content: { button: "Vai al menu!", description: "La nostra pizzeria offre una vasta selezione di pizze artigianali, realizzate con ingredienti di alta qualit e una maestria culinaria unica. Dalla classica margherita alle creazioni gourmet, ogni pizza  un'esperienza culinaria indimenticabile.", image: "https://fastsitepictures.s3.eu-north-1.amazonaws.com/Pizzeriabase0.png", orientationDesktop: "right", orientationMobile: "top", subtitle: "Tradizione e creativit in ogni fetta", title: "Esplora il nostro menu", url: "/menu" }, type: "dualSection" }, { content: ["https://fastsitepictures.s3.eu-north-1.amazonaws.com/Pizzeriagallery1.png", "https://fastsitepictures.s3.eu-north-1.amazonaws.com/Pizzeriagallery2.png", "https://fastsitepictures.s3.eu-north-1.amazonaws.com/Pizzeriagallery0.png"], type: "gallery" }, { content: [{ description: "Crea la tua pizza scegliendo gli ingredienti che preferisci. Da gustare calda e appena sfornata.", name: "Pizza Personalizzata" }, { description: "Scopri una selezione dei nostri migliori piatti con il menu degustazione che include antipasti, pizze speciali e dolci fatti in casa.", name: "Menu Degustazione" }, { description: "Organizza una festa o un evento speciale con il nostro servizio di pizza party a domicilio. Scegli le pizze da gustare comodamente a casa tua.", name: "Pizza Party a Domicilio" }], menu: "Servizi", type: "services" }, { type: "line" }, { content: [{ description: "Le nostre pizze vengono cotte in un forno a legna che garantisce una cottura perfetta e conferisce quel caratteristico sapore affumicato.", image: "https://fastsitepictures.s3.eu-north-1.amazonaws.com/Pizzeriaadvantages1.png", name: "Forno a Legna" }, { description: "Il nostro staff  ben addestrato a garantire un servizio rapido e cordiale, creando un'atmosfera accogliente per i nostri clienti.", image: "https://fastsitepictures.s3.eu-north-1.amazonaws.com/Pizzeriaadvantages3.png", name: "Servizio Veloce e Accogliente" }], menu: "Vantaggi", type: "advantages" }, { type: "line" }, { content: { Address: "Corso Dante Alighieri, 98, 70056 Molfetta BA, Italy", Phone: "+39 080 964 8969" }, menu: "Contatti", type: "contacts" }, { content: { title: "Puoi venirci a conoscere qui", address: "Via Abate Bruni, 11, 76011 Bisceglie BT, Italy", coordinates: ["16.5978131", "41.2051935"], zoom: 10 }, type: "map" }], qm = { chattyId: "10", name: "Pizzeria - Molfetta", primaryColor: "#F26C4F", secondaryColor: "#FFD166" }, Jm = [{ name: "Antipasti", icon: "mdi-food", image: "/menu/antipasti.jpg", items: [{ name: "Bruschette al Pomodoro", description: "Pane tostato con pomodorini freschi, aglio e basilico", price: 6, allergens: ["glutine"] }, { name: "Tagliere di Salumi", description: "Selezione di salumi italiani, accompagnati da focaccia", price: 12, allergens: ["glutine", "lattosio"] }, { name: "Mozzarella in Carrozza", description: "Mozzarella fritta con crosta dorata di pane", price: 7, allergens: ["glutine", "uova", "lattosio"] }, { name: "Frittura Mista", description: "Verdure pastellate croccanti con salsa yogurt", price: 9, allergens: ["glutine", "uova", "lattosio"] }] }, { name: "Pizze classiche", icon: "mdi-pizza", image: "/menu/pizze_classiche.jpg", items: [{ name: "Margherita", description: "Pomodoro San Marzano, mozzarella fior di latte, basilico", image: "/menu/pizza_margherita.png", price: 7, allergens: ["glutine", "lattosio"] }, { name: "Marinara", description: "Pomodoro, aglio fresco, origano e olio EVO", image: "/menu/pizza_marinara.png", price: 6, allergens: ["glutine"] }, { name: "Diavola", description: "Mozzarella, salame piccante, pomodoro", image: "/menu/pizza_diavola.png", price: 8, allergens: ["glutine", "lattosio"] }, { name: "Capricciosa", description: "Mozzarella, prosciutto, funghi, carciofi e olive", image: "/menu/pizza_capricciosa.png", price: 9, allergens: ["glutine", "lattosio"] }] }, { name: "Pizze Gourmet", icon: "mdi-star", image: "/menu/pizze_gourmet.jpg", items: [{ name: "Tartufo e Porcini", description: "Mozzarella, crema al tartufo nero, funghi porcini", price: 15, allergens: ["glutine", "lattosio"] }, { name: "Bufala e Pachino", description: "Mozzarella di bufala DOP, pomodorini Pachino, olio EVO", price: 13, allergens: ["glutine", "lattosio"] }, { name: "Speck e Brie", description: "Base bianca, speck dell'Alto Adige, brie fuso", price: 14, allergens: ["glutine", "lattosio"] }, { name: "Mortadella e Pistacchio", description: "Cremosa al pistacchio, mortadella IGP e granella di pistacchi", price: 16, allergens: ["glutine", "lattosio", "frutta_a_guscio"] }] }, { name: "Beverage", icon: "mdi-cup-water", image: "/menu/bevande.jpg", items: [{ name: "Acqua Naturale", description: "Bottiglia da 50cl", price: 1.5, allergens: [] }, { name: "Acqua Frizzante", description: "Bottiglia da 50cl", price: 1.5, allergens: [] }, { name: "Coca Cola", description: "Lattina da 33cl", price: 2.5, allergens: [] }, { name: "Fanta", description: "Lattina da 33cl", price: 2.5, allergens: [] }, { name: "T al Limone", description: "Bottiglietta fredda da 50cl", price: 3, allergens: [] }] }, { name: "Birre artigianali", icon: "mdi-beer", image: "/menu/birre.jpg", items: [{ name: "IPA Artigianale", description: "India Pale Ale luppolata e agrumata, 6.5%", price: 6, allergens: ["glutine"] }, { name: "Stout Nera", description: "Birra scura con note di caff, 7%", price: 6.5, allergens: ["glutine"] }, { name: "Weiss", description: "Birra di frumento, dolce e leggermente fruttata", price: 6, allergens: ["glutine"] }, { name: "Blonde Ale", description: "Birra chiara, leggera e rinfrescante", price: 5.5, allergens: ["glutine"] }] }], Qm = {
  addOn: Zm,
  components: Km,
  info: qm,
  menu: Jm
}, kn = So("data", {
  state: () => ({
    data: {},
    ready: !1
  }),
  actions: {
    initData() {
      this.updateData(Qm);
    },
    initDataByDemoLayout(t, e) {
      Qa.getRequestDemo(t, `get-data/${e}`, {}, (n) => {
        this.updateData(n.data);
      });
    },
    initDataByJson(t) {
      this.updateData(t);
    },
    updateData(t) {
      this.data = t, this.ready = !0;
    }
  }
}), rn = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [i, a] of e)
    n[i] = a;
  return n;
}, ev = {
  __name: "UpArrow",
  props: {
    bottomOffset: {
      type: Number,
      default: 20
    }
  },
  setup(t) {
    const e = t, n = kn(), { data: i } = tn(n), a = i.value.info, o = Z(null), r = () => {
      window.scrollTo({
        top: 0,
        behavior: "smooth"
      });
    }, l = () => {
      window.scrollY >= 250 ? o.value.classList.add("visible") : o.value.classList.remove("visible");
    };
    return at(() => {
      const s = document.getElementById("UpArrow");
      s && (s.style.color = a.primaryColor), window.addEventListener("scroll", l);
    }), Zd(() => {
      window.removeEventListener("scroll", l);
    }), (s, u) => (J(), Ie("div", {
      class: "sup-container shadown",
      style: re({ bottom: `${e.bottomOffset}px` }),
      ref_key: "topButton",
      ref: o,
      onClick: r
    }, u[0] || (u[0] = [
      w("i", {
        class: "fas fa-arrow-up",
        id: "UpArrow"
      }, null, -1)
    ]), 4));
  }
}, nh = /* @__PURE__ */ rn(ev, [["__scopeId", "data-v-8abb3880"]]), ih = So("address", {
  state: () => ({
    firstname: "",
    lastname: "",
    region: "",
    province: "",
    city: "",
    address: ""
  }),
  actions: {
    updateField(t, e) {
      this[t] = e;
    },
    clearAll() {
      this.firstname = "", this.lastname = "", this.region = "", this.province = "", this.city = "", this.address = "";
    },
    getFullAddress() {
      var t = `${this.firstname} ${this.lastname}, ${this.address}, ${this.city}, ${this.province}, ${this.region}`;
      return this.firstname && this.lastname && this.address && this.city && this.province && this.region ? (this.clearAll(), t) : !1;
    }
  },
  persist: {
    enabled: !0,
    storage: localStorage
  }
}), ah = So("order", {
  state: () => ({
    products: []
  }),
  actions: {
    addProduct(t) {
      const e = this.products.find((n) => n.product === t.product);
      e ? e.quantity += 1 : (t.quantity = 1, this.products.push(t));
    },
    removeProduct(t) {
      const e = this.products.find((n) => n.product === t.product);
      e && (e.quantity > 1 ? e.quantity -= 1 : this.products = this.products.filter((n) => n.product !== t.product));
    },
    removeAllProduct() {
      this.products = [], ih().clearAll();
    }
  },
  persist: !0
}), Ps = Z(!1), cl = () => {
  Ps.value = window.innerWidth < 600;
}, wa = () => (at(() => {
  cl(), window.addEventListener("resize", cl);
}), pt(() => {
  window.removeEventListener("resize", cl);
}), Ps), Ni = (t) => typeof t == "string" ? t : typeof t == "object" ? Ps.value ? t.mobile : t.desktop : "", tv = /* @__PURE__ */ JSON.parse(`{"Torino":["Reano","Usseaux","Salassa","Brandizzo","Pertusio","Cavour","Ivrea","Azeglio","Rivarossa","Salbertrand","Ciconio","Villastellone","Borgiallo","Alpignano","Torre Canavese","Cintano","Cuorgn","Rivoli","Cantalupa","Brosso","Cafasse","Lanzo Torinese","Romano Canavese","Novalesa","San Carlo Canavese","Rueglio","San Martino Canavese","Lessolo","Rocca Canavese","San Pietro Val Lemina","Giaglione","Orio Canavese","Ceres","Chiaverano","Cumiana","Osasio","Scalenghe","Mercenasco","Candia Canavese","Isolabella","Noasca","Groscavallo","Ribordone","Druento","Cossano Canavese","Villar Perosa","Locana","Piverone","Front","Levone","Settimo Torinese","Alpette","San Giusto Canavese","Bardonecchia","Verolengo","Fenestrelle","Sauze d'Oulx","Colleretto Castelnuovo","Rivara","Macello","Barbania","Gravere","Corio","Valprato Soana","Chianocco","Sestriere","Montalto Dora","Coazze","Meana di Susa","None","Cantoira","Chialamberto","Settimo Rottaro","Arignano","Mombello di Torino","Prali","Busano","Lemie","Val di Chy","Moncalieri","Banchette","Chiesanuova","Borgaro Torinese","Favria","Grosso","San Maurizio Canavese","Albiano d'Ivrea","Ror","Garzigliana","Exilles","Buriasco","Villar Focchiardo","Castagneto Po","Agli","Sant'Ambrogio di Torino","Balangero","Rivarolo Canavese","Rivalta di Torino","Andezeno","Cambiano","Beinasco","Valperga","Prarostino","Pinerolo","Vische","Bobbio Pellice","Mattie","Valchiusa","Lombriasco","Baldissero Torinese","Virle Piemonte","Venaria Reale","Mappano","Bollengo","Lusernetta","San Benigno Canavese","Borgone Susa","Balme","Borgofranco d'Ivrea","Montalenghe","Rubiana","Villar Pellice","Ala di Stura","Carignano","Castagnole Piemonte","Villafranca Piemonte","Casalborgone","Perrero","Mathi","Barone Canavese","Mazz","Brozolo","Roletto","Carema","Germagnano","Trofarello","Issiglio","Perosa Canavese","Montaldo Torinese","Mompantero","Bruino","Villar Dora","Rivalba","Vialfr","Tavagnasco","Luserna San Giovanni","San Francesco al Campo","Lombardore","Brusasco","Mezzenile","Salza di Pinerolo","Verrua Savoia","Leini","Caselette","Pratiglione","Bibiana","Traves","Condove","Castellamonte","Gassino Torinese","Sauze di Cesana","Givoletto","Carmagnola","Usseglio","Ronco Canavese","Caluso","Loranz","Forno Canavese","Canischio","Bairo","Sant'Antonino di Susa","Moriondo Torinese","Settimo Vittone","Airasca","Lauriano","Piscina","Andrate","Inverso Pinasca","Rosta","San Giorgio Canavese","Colleretto Giacosa","Caprie","Samone","Roure","Volpiano","Vaie","Grugliasco","Pomaretto","San Germano Chisone","Ceresole Reale","Vallo Torinese","Fiano","San Giorio di Susa","Caravino","Cesana Torinese","Varisella","Bosconero","Monteu da Po","Burolo","Cascinette d'Ivrea","Sciolze","Borgomasino","Pecetto Torinese","Massello","La Loggia","Ozegna","Sparone","Pessinetto","San Gillio","Feletto","Pralormo","Maglione","Caselle Torinese","Torrazza Piemonte","Oglianico","Coassolo Torinese","Vi","Chiomonte","Strambinello","Susa","Frossasco","Porte","Vinovo","Vauda Canavese","Pragelato","Parella","Villarbasse","Traversella","Vigone","Chivasso","Cercenasco","Santena","Giaveno","Pianezza","Riva presso Chieri","Cinzano","Fiorano Canavese","Volvera","Cuceglio","Candiolo","Torre Pellice","Almese","Castiglione Torinese","Piobesi Torinese","Quincinetto","Vistrorio","San Didero","Collegno","Villareggia","Pavone Canavese","Venaus","San Colombano Belmonte","Bussoleno","Oulx","Nichelino","Foglizzo","Baldissero Canavese","San Secondo di Pinerolo","Ingria","Scarmagno","Bruzolo","Quassolo","Moncenisio","Trana","Cavagnolo","San Sebastiano da Po","Poirino","Nomaglio","Chiusa di San Michele","Nole","Vestign","Angrogna","Robassomero","Vidracco","Val della Torre","Avigliana","Bricherasio","Strambino","Castelnuovo Nigra","Montanaro","Salerano Canavese","Valgioie","Marentino","Ciri","Campiglione Fenile","Osasco","Orbassano","Prascorsano","Torino","Perosa Argentina","Pont Canavese","Monastero di Lanzo","La Cassa","Pinasca","San Mauro Torinese","Sangano","Pavarolo","Buttigliera Alta","Palazzo Canavese","Quagliuzzo","Claviere","Villanova Canavese","Piossasco","Lusigli","Pino Torinese","Pancalieri","Chieri","Frassinetto","Pramollo","San Ponso","San Raffaele Cimena","Rondissone"],"Vercelli":["Albano Vercellese","Moncrivello","Villata","Asigliano Vercellese","Alice Castello","Cellio con Breia","Lenta","Mollia","Vocca","Desana","Varallo","Bianz","Palazzolo Vercellese","Ronsecco","Collobiano","Balmuccia","Campertogno","Valduggia","Cravagliana","Rovasenda","Casanova Elvo","Balocco","Salasco","Formigliana","Pezzana","Gattinara","Olcenengo","Roasio","Crova","Arborio","Rimella","Alagna Valsesia","Piode","Scopello","Costanzana","Carisio","Ghislarengo","Quarona","Villarboit","Boccioleto","Lozzolo","Borgo d'Ale","Prarolo","Serravalle Sesia","Trino","San Giacomo Vercellese","Caresana","Civiasco","Caresanablot","Santhi","Scopa","Fontanetto Po","Cervatto","Buronzo","Carcoforo","Saluggia","Greggio","Alto Sermenza","Oldenico","Quinto Vercellese","Pertengo","Sali Vercellese","Crescentino","Motta de' Conti","Cigliano","Rassa","Lignana","Rossa","Vercelli","Rive","Livorno Ferraris","Tricerro","Tronzano Vercellese","Borgosesia","San Germano Vercellese","Fobello","Pila","Lamporo","Borgo Vercelli","Stroppiana","Guardabosone","Postua"],"Novara":["Fara Novarese","Vaprio d'Agogna","Mandello Vitta","Invorio","Landiona","Divignano","Mezzomerico","Caltignaga","Castellazzo Novarese","Soriso","Vespolate","Cavaglio d'Agogna","Cureggio","Borgolavezzaro","Pella","Casalbeltrame","Pettenasco","Biandrate","Cavallirio","Meina","Casalvolone","Nebbiuno","Oleggio","Varallo Pombia","Casalino","San Pietro Mosezzo","Boca","Ameno","Miasino","Trecate","Carpignano Sesia","Garbagna Novarese","Pogno","Briga Novarese","Grignasco","Gargallo","Vinzaglio","Agrate Conturbia","Vicolungo","Bogogno","Cerano","Marano Ticino","Gattico-Veruno","Barengo","Cameri","Paruzzaro","Suno","Massino Visconti","Prato Sesia","Armeno","Ghemme","Bolzano Novarese","Dormelletto","San Maurizio d'Opaglio","Borgo Ticino","Oleggio Castello","Nibbiola","Colazza","Recetto","Gozzano","Sizzano","Pombia","Fontaneto d'Agogna","Romentino","Comignago","Bellinzago Novarese","Momo","Castelletto sopra Ticino","Lesa","Arona","Romagnano Sesia","Borgomanero","Maggiora","Sillavengo","Briona","Casaleggio Novara","Cressa","Cavaglietto","Pisano","Granozzo con Monticello","Novara","Sozzago","Galliate","Tornaco","Terdobbiate","San Nazzaro Sesia","Orta San Giulio"],"Cuneo":["Baldissero d'Alba","Bergolo","Mango","Margarita","Pamparato","Neviglie","Montelupo Albese","Govone","Farigliano","Castiglione Tinella","Lesegno","Villar San Costanzo","Castellinaldo d'Alba","Venasca","Oncino","Limone Piemonte","Rocca Cigli","Torre San Giorgio","Sambuco","Rodello","Santo Stefano Roero","Battifollo","Torre Bormida","Cuneo","Casteldelfino","Castelletto Stura","Serralunga d'Alba","Genola","Perletto","Barge","Entracque","Robilante","Busca","Corneliano d'Alba","Canosio","Castellino Tanaro","Guarene","Garessio","Card","Lisio","Neive","Niella Tanaro","Rittana","Roccavione","Carr","Canale","Rossana","Mondov","Bagnolo Piemonte","Treiso","Vicoforte","Roccabruna","Cigli","Monasterolo di Savigliano","Monasterolo Casotto","Crissolo","Bra","Pezzolo Valle Uzzone","Scagnello","Prazzo","Sale delle Langhe","Frassino","Pietraporzio","Rocca de' Baldi","Rocchetta Belbo","Valloriate","Villanova Solaro","Boves","Pontechianale","Pianfei","Revello","Montezemolo","Polonghera","Villafalletto","Moretta","Paesana","Sanfr","Racconigi","Saliceto","Tarantasca","Barolo","Gottasecca","Fossano","Narzole","Mont","Prunetto","Alba","Castelletto Uzzone","Morozzo","Belvedere Langhe","Costigliole Saluzzo","Briga Alta","Monterosso Grana","Piasco","Cervasca","San Michele Mondov","Moiola","Albaretto della Torre","Borgomale","Roascio","Gaiola","Magliano Alpi","Saluzzo","Trezzo Tinella","Cavallerleone","Nucetto","Lagnasco","Isasca","Bene Vagienna","Verzuolo","Monesiglio","Martiniana Po","Argentera","Valdieri","Marene","Villanova Mondov","Ceva","Frabosa Sottana","Cossano Belbo","Cortemilia","Montemale di Cuneo","Santa Vittoria d'Alba","Gambasca","Casalgrasso","Ceresole Alba","Frabosa Soprana","Perlo","Bellino","Aisone","Macra","Montaldo di Mondov","Chiusa di Pesio","Arguello","Piozzo","Stroppo","Caprauna","Elva","Priola","Santo Stefano Belbo","Cravanzana","Brondello","Demonte","Mombasiglio","La Morra","Roccasparvera","Sommariva Perno","Sale San Giovanni","Grinzane Cavour","Savigliano","Murazzano","Verduno","Acceglio","Monchiero","Cherasco","Roburent","Melle","Vernante","Sant'Albano Stura","Monastero di Vasco","Castiglione Falletto","Montaldo Roero","Roccaforte Mondov","Vottignasco","Sinio","Viola","Borgo San Dalmazzo","Scarnafigi","Niella Belbo","Bagnasco","Cartignano","Envie","Gorzegno","Murello","Lequio Berria","Cavallermaggiore","Marsaglia","Manta","Barbaresco","Camerana","Sampeyre","Sanfront","Rifreddo","Vignolo","Beinette","Benevello","Feisoglio","Cervere","Cerretto Langhe","San Damiano Macra","Caramagna Piemonte","Roddi","Roaschia","Serravalle Langhe","Valgrana","Vinadio","Lequio Tanaro","Dronero","Ostana","Salmour","Mombarcaro","Bossolasco","Castagnito","Centallo","Magliano Alfieri","Torresina","Pradleves","Igliano","Priero","Pocapaglia","Marmora","Dogliani","Alto","Bernezzo","Bonvicino","Monforte d'Alba","Castelnuovo di Ceva","Vezza d'Alba","Novello","Sommariva del Bosco","Briaglia","Torre Mondov","Bastia Mondov","Roddino","Monticello d'Alba","Caraglio","Castelmagno","Faule","Diano d'Alba","Monteu Roero","Castino","Somano","Pagno","Piobesi d'Alba","Ruffia","Brossasco","Priocca","Cissone","Bosia","Paroldo","Levice","Clavesana","Montanera","San Benedetto Belbo","Peveragno","Trinit","Celle di Macra","Ormea"],"Asti":["Incisa Scapaccino","Scurzolengo","Villa San Secondo","Cerro Tanaro","Montiglio Monferrato","Cortanze","Baldichieri d'Asti","Belveglio","Villanova d'Asti","Isola d'Asti","San Paolo Solbrito","Quaranti","Grazzano Badoglio","Cocconato","Serole","Sessame","Cassinasco","Moasca","Moransengo-Tonengo","Calosso","Passerano Marmorito","Camerano Casasco","Corsione","Bruno","Celle Enomondo","Cerreto d'Asti","Vinchio","Coazzolo","Cortiglione","Cossombrato","Monastero Bormida","Castell'Alfero","Asti","Cellarengo","Cantarana","Dusino San Michele","Roccaverano","Berzano di San Pietro","Montabone","San Giorgio Scarampi","Montegrosso d'Asti","Fontanile","Frinco","Vaglio Serra","Buttigliera d'Asti","Tonco","Montemagno Monferrato","Capriglio","Bubbio","Villafranca d'Asti","Viarigi","Penango","Maranzana","Rocca d'Arazzo","San Martino Alfieri","Aramengo","Costigliole d'Asti","Rocchetta Palafea","Castelnuovo Belbo","Soglio","Cisterna d'Asti","Castelnuovo Don Bosco","Castello di Annone","Refrancore","Revigliasco d'Asti","Rocchetta Tanaro","Nizza Monferrato","Piea","Cunico","Ferrere","Montafia","Robella","Canelli","Grana Monferrato","Calamandrana","Calliano Monferrato","Albugnano","Montaldo Scarampi","Olmo Gentile","Castel Boglione","Mombercelli","Antignano","Mongardino","Portacomaro","San Marzano Oliveto","Azzano d'Asti","Castellero","Roatto","Maretto","Cortazzone","Casorzo Monferrato","Castelnuovo Calcea","Tigliole","Moncucco Torinese","Settime","Moncalvo","Castelletto Molina","Cinaglio","Castagnole Monferrato","Pino d'Asti","Piov Massaia","Cessole","Valfenera","Mombaldone","Mombaruzzo","Montechiaro d'Asti","Chiusano d'Asti","Vigliano d'Asti","Loazzolo","Vesime","Monale","Viale","Castagnole delle Lanze","Agliano Terme","Cortandone","Castel Rocchero","San Damiano d'Asti"],"Alessandria":["Cereseto","Malvicino","Volpeglino","Avolasca","Fubine Monferrato","Vignole Borbera","Alice Bel Colle","Pareto","Gamalero","Melazzo","Bosco Marengo","Montegioco","Conzano","Alluvioni Piovera","Felizzano","Sala Monferrato","Acqui Terme","Prasco","Tagliolo Monferrato","Borgo San Martino","Gremiasco","Masio","Castelnuovo Scrivia","Casale Monferrato","Fabbrica Curone","Valmacca","Morsasco","Valenza","Pomaro Monferrato","Dernice","Molare","Borghetto di Borbera","Basaluzzo","Carrosio","Castelletto Merli","Monleale","Ponti","Trisobbio","Cerreto Grue","Montechiaro d'Acqui","Cella Monte","Merana","Cavatore","Spigno Monferrato","Orsara Bormida","Bozzole","San Giorgio Monferrato","Occimiano","Villamiroglio","Carentino","Pontestura","Oviglio","Terzo","Balzola","Voltaggio","Carbonara Scrivia","Rocchetta Ligure","Sarezzano","Rocca Grimalda","Morano sul Po","Ticineto","Stazzano","Fresonara","Strevi","Berzano di Tortona","Serralunga di Crea","Terruggia","Ponzano Monferrato","Arquata Scrivia","Tassarolo","Solero","Cantalupo Ligure","Cremolino","Bassignana","Frugarolo","Ponzone","Silvano d'Orba","Denice","Casal Cermelli","Rivarone","Solonghello","Brignano-Frascata","Montaldeo","Castelletto d'Erro","Francavilla Bisio","Pozzolo Formigaro","Molino dei Torti","Villalvernia","Volpedo","Capriata d'Orba","Carrega Ligure","Momperone","Viguzzolo","Mornese","Villanova Monferrato","Cartosio","Fraconalto","Grognardo","Montecastello","Pecetto di Valenza","Lu e Cuccaro Monferrato","Albera Ligure","Bistagno","Belforte Monferrato","Frassineto Po","Guazzora","Ozzano Monferrato","Visone","Casaleggio Boiro","Cassinelle","Grondona","Altavilla Monferrato","Garbagna","Sezzadio","Murisengo","Castelspina","Ricaldone","Castelnuovo Bormida","Isola Sant'Antonio","Castelletto d'Orba","Montacuto","Sant'Agata Fossili","Villadeati","Vignale Monferrato","Tortona","Castellar Guidobono","Ovada","Bergamasco","Pozzol Groppo","Quattordio","Rivalta Bormida","Quargnento","Alessandria","Alzano Scrivia","Treville","Villaromagnano","Camino","Novi Ligure","Rosignano Monferrato","Montaldo Bormida","Carezzano","Montemarzino","Serravalle Scrivia","Coniolo","San Salvatore Monferrato","Roccaforte Ligure","Predosa","Spineto Scrivia","Odalengo Piccolo","San Sebastiano Curone","Cassano Spinola","Giarole","Cabella Ligure","Moncestino","Carpeneto","Gavi","Sardigliano","Olivola","Frascaro","Ottiglio","Costa Vescovato","Casalnoceto","Gabiano","Odalengo Grande","Casasco","Castellazzo Bormida","Paderna","Bosio","San Cristoforo","Mirabello Monferrato","Frassinello Monferrato","Mongiardino Ligure","Sale","Castellania Coppi","Borgoratto Alessandrino","Pontecurone","Camagna Monferrato","Castelletto Monferrato","Pietra Marazzi","Cerrina Monferrato","Lerma","Cassine","Mombello Monferrato","Alfiano Natta","Parodi Ligure","Morbello","Pasturana"],"Biella":["Crevacuore","Cavagli","Ponderano","Viverone","Quaregna Cerreto","Sagliano Micca","Miagliano","Vigliano Biellese","Camandona","Piatto","Massazza","Campiglia Cervo","Bioglio","Rosazza","Veglio","Salussola","Vallanzengo","Graglia","Zubiena","Benna","Camburzano","Portula","Coggiola","Verrone","Strona","Ailoche","Sala Biellese","Muzzano","Cossato","Andorno Micca","Castelletto Cervo","Dorzano","Villa del Bosco","Magnano","Sandigliano","Zumaglia","Brusnengo","Biella","Gifflenga","Zimone","Mongrando","Sordevolo","Donato","Valle San Nicolao","Villanova Biellese","Candelo","Caprile","Pettinengo","Curino","Tollegno","Valdengo","Cerrione","Occhieppo Inferiore","Pralungo","Ronco Biellese","Netro","Callabiana","Roppolo","Masserano","Mezzana Mortigliengo","Tavigliano","Occhieppo Superiore","Lessona","Piedicavallo","Mottalciata","Valdilana","Torrazzo","Ternengo","Casapinta","Sostegno","Gaglianico","Borriana","Pollone","Pray"],"Verbano-Cusio-Ossola":["Belgirate","Domodossola","Bognanco","Macugnaga","Ornavasso","Nonio","Premia","Vignone","Santa Maria Maggiore","Beura-Cardezza","Caprezzo","Villadossola","Valstrona","Omegna","Trontano","Formazza","Germagno","Toceno","Bannio Anzino","Stresa","Madonna del Sasso","Arola","Cossogno","Oggebbio","Piedimulera","Aurano","Druogno","Pieve Vergonte","Anzola d'Ossola","Craveggia","Gravellona Toce","Intragna","Cannero Riviera","Baceno","Quarna Sotto","Varzo","Masera","Verbania","Crodo","Gurro","Crevoladossola","Miazzina","Premosello-Chiovenda","Cannobio","Massiola","Quarna Sopra","Montescheno","Pallanzeno","Vogogna","Gignese","Mergozzo","Premeno","Ceppo Morelli","Cambiasca","Arizzano","Montecrestese","Re","Valle Cannobina","Antrona Schieranco","Ghiffa","Loreglia","Trasquera","Villette","Bee","Trarego Viggiona","Malesco","Baveno","Borgomezzavalle","Brovello-Carpugnino","Cesara","San Bernardino Verbano","Casale Corte Cerro","Vanzone con San Carlo","Calasca-Castiglione"]}`), nv = { Imperia: ["Mendatica", "Borghetto d'Arroscia", "Montalto Carpasio", "Vallebona", "Aurigo", "Perinaldo", "Diano Castello", "Rezzo", "Borgomaro", "Civezza", "Ventimiglia", "Pietrabruna", "Chiusavecchia", "Dolceacqua", "Cervo", "Villa Faraldi", "San Biagio della Cima", "Molini di Triora", "Diano Marina", "Vallecrosia", "Diano Arentino", "Imperia", "Dolcedo", "Pontedassio", "Pieve di Teco", "Pornassio", "Airole", "Camporosso", "Bordighera", "Isolabona", "Vessalico", "Ceriana", "Triora", "Cesio", "Caravonica", "Taggia", "San Lorenzo al Mare", "Ranzo", "Armo", "Pompeiana", "Cosio d'Arroscia", "Montegrosso Pian Latte", "Riva Ligure", "Rocchetta Nervina", "San Bartolomeo al Mare", "Chiusanico", "Sanremo", "Prel", "Ospedaletti", "Castel Vittorio", "Santo Stefano al Mare", "Costarainera", "Apricale", "Aquila d'Arroscia", "Castellaro", "Cipressa", "Seborga", "Lucinasco", "Diano San Pietro", "Soldano", "Terzorio", "Vasia", "Pigna", "Badalucco", "Bajardo", "Olivetta San Michele"], Savona: ["Piana Crixia", "Balestrino", "Osiglia", "Spotorno", "Calice Ligure", "Varazze", "Vezzi Portio", "Cengio", "Albissola Marina", "Alassio", "Noli", "Roccavignale", "Ceriale", "Murialdo", "Villanova d'Albenga", "Zuccarello", "Bormida", "Andora", "Boissano", "Borgio Verezzi", "Plodio", "Rialto", "Vado Ligure", "Bergeggi", "Orco Feglino", "Urbe", "Erli", "Savona", "Giusvalla", "Laigueglia", "Testico", "Cairo Montenotte", "Altare", "Nasino", "Onzo", "Quiliano", "Bardineto", "Mioglia", "Tovo San Giacomo", "Casanova Lerrone", "Borghetto Santo Spirito", "Arnasco", "Pontinvrea", "Calizzano", "Giustenice", "Cosseria", "Garlenda", "Mallare", "Millesimo", "Toirano", "Albisola Superiore", "Stella", "Celle Ligure", "Castelbianco", "Magliolo", "Sassello", "Pietra Ligure", "Vendone", "Carcare", "Castelvecchio di Rocca Barbena", "Finale Ligure", "Loano", "Albenga", "Massimino", "Cisano sul Neva", "Pallare", "Stellanello", "Ortovero", "Dego"], Genova: ["Rapallo", "Santa Margherita Ligure", "Lumarzo", "Moneglia", "Rondanina", "Sori", "Isola del Cantone", "Favale di Malvaro", "Propata", "Fascia", "Mezzanego", "Borzonasca", "Campo Ligure", "San Colombano Certenoli", "Campomorone", "Pieve Ligure", "Montoggio", "Carasco", "Rezzoaglio", "Ronco Scrivia", "Rossiglione", "Chiavari", "Gorreto", "Tribogna", "Arenzano", "Masone", "Bargagli", "Sant'Olcese", "Genova", "Cogoleto", "Serra Ricc", "Savignone", "Valbrevenna", "Lorsica", "Moconesi", "Uscio", "Coreglia Ligure", "Davagna", "Orero", "Cogorno", "Tiglieto", "Mignanego", "Casella", "Castiglione Chiavarese", "Recco", "Torriglia", "Montebruno", "Leivi", "Sestri Levante", "Ceranesi", "Zoagli", "Santo Stefano d'Aveto", "Ne", "Lavagna", "Rovegno", "Mele", "Avegno", "Vobbia", "Neirone", "Casarza Ligure", "Busalla", "Portofino", "Cicagna", "Camogli", "Fontanigorda", "Bogliasco", "Crocefieschi"], "La Spezia": ["Calice al Cornoviglio", "Lerici", "Ameglia", "Carro", "Framura", "La Spezia", "Zignago", "Santo Stefano di Magra", "Castelnuovo Magra", "Carrodano", "Rocchetta di Vara", "Borghetto di Vara", "Beverino", "Follo", "Riomaggiore", "Luni", "Pignone", "Portovenere", "Bolano", "Sarzana", "Maissana", "Ricc del Golfo di Spezia", "Vezzano Ligure", "Bonassola", "Levanto", "Vernazza", "Deiva Marina", "Varese Ligure", "Sesta Godano", "Arcola", "Monterosso al Mare", "Brugnato"] }, iv = /* @__PURE__ */ JSON.parse(`{"Varese":["Castronno","Lavena Ponte Tresa","Olgiate Olona","Cassano Valcuvia","Gallarate","Leggiuno","Caronno Pertusella","Sangiano","Origgio","Casciago","Lonate Ceppino","Bardello con Malgesso e Bregano","Cadegliano-Viconago","Cavaria con Premezzo","Cuvio","Cazzago Brabbia","Venegono Inferiore","Albizzate","Buguggiate","Cadrezzate con Osmate","Bisuschio","Varese","Busto Arsizio","Luino","Gazzada Schianno","Vedano Olona","Cantello","Arcisate","Bedero Valcuvia","Agra","Orino","Uboldo","Brezzo di Bedero","Marnate","Masciago Primo","Angera","Gavirate","Jerago con Orago","Brunello","Crosio della Valle","Carnago","Mercallo","Montegrino Valtravaglia","Cocquio-Trevisago","Comerio","Venegono Superiore","Cugliate-Fabiasco","Induno Olona","Cuveglio","Cairate","Valganna","Cunardo","Castello Cabiaglio","Saronno","Morazzone","Mesenzana","Sesto Calende","Luvinate","Besozzo","Caronno Varesino","Mornago","Brinzio","Besnate","Cittiglio","Dumenza","Brusimpiano","Curiglia con Monteviasco","Ranco","Ferno","Samarate","Vergiate","Clivio","Gerenzano","Gorla Minore","Lonate Pozzolo","Maccagno con Pino e Veddasca","Marzio","Golasecca","Cassano Magnago","Brebbia","Ispra","Biandronno","Gemonio","Marchirolo","Tronzano Lago Maggiore","Fagnano Olona","Gornate Olona","Duno","Brissago-Valtravaglia","Sumirago","Azzio","Castelseprio","Viggi","Inarzo","Cislago","Taino","Solbiate Olona","Casorate Sempione","Casale Litta","Azzate","Oggiona con Santo Stefano","Gorla Maggiore","Besano","Barasso","Ferrera di Varese","Castiglione Olona","Varano Borghi","Comabbio","Cremenaga","Ternate","Castelveccana","Germignaga","Castellanza","Somma Lombardo","Brenta","Saltrio","Monvalle","Laveno-Mombello","Malnate","Porto Valtravaglia","Tradate","Vizzola Ticino","Grantola","Cuasso al Monte","Daverio","Arsago Seprio","Bodio Lomnago","Porto Ceresio","Casalzuigno","Lozza","Solbiate Arno","Travedona-Monate","Cardano al Campo","Rancio Valcuvia","Caravate","Galliate Lombardo"],"Como":["Trezzone","Stazzona","Como","Cusino","Merone","Uggiate con Ronago","Grandate","Appiano Gentile","Maslianico","Eupilio","Lurate Caccivio","Canzo","Brienno","Faggeto Lario","Albese con Cassano","Sorico","Bulgarograsso","Livo","Mariano Comense","Fenegr","Lomazzo","Solbiate con Cagno","Guanzate","Veleso","Gera Lario","Caslino d'Erba","Ponna","Colverde","Casnate con Bernate","Colonno","Centro Valle Intelvi","Limido Comasco","Monguzzo","Pusiano","Campione d'Italia","Vercana","Luisago","Vertemate con Minoprio","Valbrona","Orsenigo","San Nazzaro Val Cavargna","Albiolo","Griante","Oltrona di San Mamette","Rezzago","Corrido","Cremia","Rodero","Erba","Asso","Moltrasio","Nesso","Bene Lario","Figino Serenza","Turate","Tremezzina","Sala Comacina","Pianello del Lario","Fino Mornasco","Rovellasca","Capiago Intimiano","Castelmarte","Bregnano","Sormano","Brunate","Cabiate","Carlazzo","Menaggio","Montano Lucino","Porlezza","Veniano","Carate Urio","Bizzarone","Valsolda","San Fermo della Battaglia","Claino con Osteno","Anzano del Parco","Torno","Proserpio","Cadorago","Faloppio","Peglio","Olgiate Comasco","Barni","Cermenate","Arosio","Carugo","Bellagio","Val Rezzo","Cernobbio","Novedrate","Cerano d'Intelvi","Cirimido","Villa Guardia","Garzeno","Domaso","San Bartolomeo Val Cavargna","Blevio","Caglio","Rovello Porro","Lasnigo","Laino","Alta Valle Intelvi","Longone al Segrino","Carimate","Cassina Rizzardi","Beregazzo con Figliaro","Lambrugo","Lezzeno","Dongo","Argegno","Schignano","Binago","Lurago Marinone","Cucciago","Alzate Brianza","Locate Varesino","Montemezzo","Lurago d'Erba","Carbonate","Mozzate","Alserio","Pigra","Lipomo","Castelnuovo Bozzente","Cavargna","Blessagno","Magreglio","Dizzasco","Ponte Lambro","Tavernerio","Zelbio","Grandola ed Uniti","Gravedona ed Uniti","Dosso del Liro","Albavilla","Cant","Brenna","San Siro","Laglio","Inverigo","Montorfano","Musso","Pognana Lario","Plesio","Senna Comasco","Valmorea"],"Sondrio":["Pedesina","Montagna in Valtellina","Gordona","Berbenno di Valtellina","Tirano","Mazzo di Valtellina","Villa di Tirano","Sondrio","Vervio","Chiuro","Delebio","Livigno","Mese","Caiolo","Rasura","Andalo Valtellino","Prata Camportaccio","Piateda","Samolaco","Postalesio","Lanzada","Bianzone","Colorina","Bema","Talamona","Castione Andevenno","Campodolcino","Mello","Ardenno","Valdidentro","Fusine","Grosotto","Tovo di Sant'Agata","Castello dell'Acqua","Morbegno","Poggiridenti","Gerola Alta","Verceia","Cosio Valtellino","Bormio","Albosaggia","Dazio","Tresivio","Civo","Spriana","Cedrasco","Aprica","San Giacomo Filippo","Villa di Chiavenna","Teglio","Tartano","Albaredo per San Marco","Sondalo","Chiavenna","Forcola","Dubino","Faedo Valtellino","Rogolo","Sernio","Novate Mezzola","Chiesa in Valmalenco","Lovero","Traona","Caspoggio","Valfurva","Cino","Madesimo","Valdisotto","Ponte in Valtellina","Val Masino","Piuro","Torre di Santa Maria","Grosio","Cercino","Mantello","Piantedo","Buglio in Monte"],"Milano":["Bellinzago Lombardo","Boffalora sopra Ticino","Mediglia","Busto Garolfo","Motta Visconti","Solaro","Lainate","Albairate","Colturano","Noviglio","Arluno","Dresano","Vizzolo Predabissi","Castano Primo","Cuggiono","Calvignasco","Cesate","Tribiano","Nerviano","Inzago","Locate di Triulzi","Vimodrone","Liscate","Trezzano Rosa","Cassinetta di Lugagnano","Basiglio","Binasco","Pozzo d'Adda","Abbiategrasso","Corbetta","Dairago","Gudo Visconti","Pieve Emanuele","Nosate","Milano","Carugate","Cerro al Lambro","Rho","Pogliano Milanese","Buscate","Ozzero","Settimo Milanese","Morimondo","Sedriano","Peschiera Borromeo","Vermezzo con Zelo","Segrate","Mesero","Vittuone","Cornaredo","Magenta","Rodano","Rosate","San Giorgio su Legnano","Cusano Milanino","Bubbiano","Turbigo","Arconate","Senago","Lacchiarella","Magnago","Settala","Ossona","Cassano d'Adda","San Colombano al Lambro","Cinisello Balsamo","Opera","Robecchetto con Induno","Legnano","Casorezzo","Bareggio","Baranzate","Cesano Boscone","Trezzano sul Naviglio","Marcallo con Casone","Vernate","Cusago","Cormano","Cologno Monzese","Grezzago","Bollate","Rozzano","Cisliano","San Giuliano Milanese","Sesto San Giovanni","Pozzuolo Martesana","Gorgonzola","Santo Stefano Ticino","Bresso","Gessate","Parabiago","Pantigliate","Canegrate","Casarile","Bernate Ticino","Rescaldina","Melegnano","Pregnana Milanese","Truccazzano","Vignate","Besate","Vanzago","Pioltello","Corsico","Bussero","Garbagnate Milanese","San Vittore Olona","Paderno Dugnano","Vaprio d'Adda","Gaggiano","Assago","Novate Milanese","Inveruno","Zibido San Giacomo","Carpiano","Cassina de' Pecchi","Robecco sul Naviglio","Basiano","Cambiago","San Donato Milanese","Cerro Maggiore","Masate","San Zenone al Lambro","Trezzo sull'Adda","Pessano con Bornago","Pero","Villa Cortese","Buccinasco","Vanzaghello","Arese","Paullo","Cernusco sul Naviglio","Melzo"],"Bergamo":["Stezzano","Castro","Verdellino","Sant'Omobono Terme","Zogno","Pognano","Chiuduno","Torre Boldone","Urgnano","Madone","Piazzolo","Arcene","Taleggio","Lovere","Bossico","Bedulita","Carvico","Fara Olivana con Sola","Roncobello","Castelli Calepio","Selvino","Predore","Brembate","Almenno San Salvatore","Filago","Pontida","Treviolo","Zandobbio","Ghisalba","Lallio","Pagazzano","Brumano","Bonate Sotto","Ardesio","Ranzanico","Telgate","Sedrina","Ponteranica","Costa Serina","Cene","Calcinate","Gorlago","Ambivere","San Paolo d'Argon","Leffe","Ranica","Sovere","Pumenengo","Branzi","Fino del Monte","Gazzaniga","Palosco","Albino","Sarnico","Casirate d'Adda","Parre","Valbondione","Albano Sant'Alessandro","Fornovo San Giovanni","Vigano San Martino","Fontanella","Oneta","Mozzo","Solto Collina","Almenno San Bartolomeo","Brignano Gera d'Adda","Gromo","Antegnate","Verdello","Cornalba","Scanzorosciate","Romano di Lombardia","Costa di Mezzate","Spinone al Lago","Corna Imagna","Grone","Clusone","Trescore Balneario","Pontirolo Nuovo","Serina","San Pellegrino Terme","Alm","Moio de' Calvi","Borgo di Terzo","Torre de' Roveri","Presezzo","Gorno","Onore","Dalmine","Paladina","Montello","Lenna","Rota d'Imagna","San Giovanni Bianco","Bergamo","Carona","Casazza","Lurano","Brembate di Sopra","Mozzanica","Gandellino","Pedrengo","Parzanica","Cenate Sopra","Strozza","Colere","Ponte Nossa","Roncola","Villa d'Adda","Bottanuco","Villa d'Ogna","Schilpario","Cusio","Cividate al Piano","Seriate","Alzano Lombardo","Piario","Fonteno","Orio al Serio","Calvenzano","Ubiale Clanezzo","Valtorta","Vilminore di Scalve","Blello","Adrara San Martino","Fuipiano Valle Imagna","Isso","Dossena","Arzago d'Adda","Barzana","Levate","Ornica","Capizzone","Capriate San Gervasio","Palazzago","Valleve","Averara","Bariano","Val Brembilla","Premolo","Comun Nuovo","Cerete","Rovetta","Mezzoldo","Morengo","Olmo al Brembo","Camerata Cornello","Bonate Sopra","Endine Gaiano","Medolago","Pianico","Ciserano","Cavernago","Castel Rozzone","Isola di Fondra","Algua","Caravaggio","Gorle","Cologno al Serio","Fara Gera d'Adda","Treviglio","Cenate Sotto","Curno","Bracca","Cortenuova","Cisano Bergamasco","Credaro","Costa Valle Imagna","Monasterolo del Castello","Songavazzo","Sotto il Monte Giovanni XXIII","Torre Pallavicina","Valgoglio","Chignolo d'Isola","Oltressenda Alta","Rogno","Mapello","Valnegra","Canonica d'Adda","Barbata","Berbenno","Castione della Presolana","Zanica","Entratico","Vedeseta","Gandino","Misano di Gera d'Adda","Cazzano Sant'Andrea","Villa di Serio","Viadanica","Calcio","Calusco d'Adda","Grassobbio","Osio Sopra","Torre de' Busi","Caprino Bergamasco","Villongo","Foppolo","Peia","Gaverina Terme","Colzate","Oltre il Colle","Fiorano al Serio","Cassiglio","Vertova","Aviatico","Adrara San Rocco","Locatello","Santa Brigida","Spirano","Riva di Solto","Osio Sotto","Vigolo","Terno d'Isola","Brusaporto","Sorisole","Carobbio degli Angeli","Azzone","Berzo San Fermo","Villa d'Alm","Bianzano","Piazzatorre","Ponte San Pietro","Casnigo","Grumello del Monte","Suisio","Piazza Brembana","Bolgare","Covo","Luzzana","Gandosso","Nembro","Pradalunga","Valbrembo","Costa Volpino","Martinengo","Azzano San Paolo","Boltiere","Bagnatica","Mornico al Serio","Tavernola Bergamasca","Solza","Foresto Sparso"],"Brescia":["Castel Mella","Provaglio d'Iseo","Coccaglio","Sabbio Chiese","Muscoline","Botticino","Brescia","Odolo","Paisco Loveno","Puegnago del Garda","Bovezzo","Villachiara","Passirano","Darfo Boario Terme","Flero","Orzivecchi","Irma","Pezzaze","Pompiano","Azzano Mella","Urago d'Oglio","Casto","Pontevico","Ospitaletto","Pertica Alta","Monte Isola","Verolavecchia","Marmentino","Caino","Erbusco","Collebeato","Anfo","Marone","Cigole","Manerba del Garda","Orzinuovi","Polaveno","Gussago","Cevo","Magasa","Villa Carcina","Idro","Angolo Terme","Chiari","Gianico","Manerbio","Corzano","Fiesse","Nuvolento","Pavone del Mella","Cellatica","Rezzato","Villanuova sul Clisi","Comezzano-Cizzago","Capriolo","Borno","Milzano","Brione","Lonato del Garda","Pontoglio","Vallio Terme","San Paolo","Palazzolo sull'Oglio","San Felice del Benaco","Niardo","Pralboino","Corteno Golgi","Borgo San Giacomo","Castenedolo","Sarezzo","Mairano","Lodrino","Collio","Alfianello","Monticelli Brusati","Sale Marasino","Bione","Bovegno","Gardone Val Trompia","Montichiari","Castrezzato","Lozio","Sonico","Berlingo","Carpenedolo","Acquafredda","Ceto","Maclodio","Tavernole sul Mella","Cedegolo","Ossimo","Capo di Ponte","Vestone","Vezza d'Oglio","Nuvolera","Barbariga","Sulzano","Bagnolo Mella","Rovato","Limone sul Garda","Pian Camuno","Poncarale","Castegnato","Ponte di Legno","Pertica Bassa","Dello","San Gervasio Bresciano","Desenzano del Garda","Berzo Inferiore","Barghe","Calcinato","Offlaga","Leno","Capriano del Colle","Brandico","Preseglie","Ome","Iseo","Padenghe sul Garda","Gambara","Breno","Lavenone","Ono San Pietro","Piancogno","Tremosine sul Garda","Malonno","Monno","Toscolano-Maderno","Provaglio Val Sabbia","Isorella","Borgosatollo","Edolo","Travagliato","Visano","Lograto","Berzo Demo","Tem","Mazzano","Vobarno","Treviso Bresciano","Longhena","Lumezzane","Gottolengo","Concesio","Malegno","Gardone Riviera","Ghedi","Cerveno","Braone","Montirone","Soiano del Lago","Losine","Remedello","Agnosine","Capovalle","Castelcovati","Valvestino","Gargnano","Cazzago San Martino","Calvagese della Riviera","Paspardo","Sal","Sellero","Trenzano","Torbole Casaglia","Corte Franca","Nave","Polpenazze del Garda","Marcheno","Esine","Incudine","Paratico","Serle","Pisogne","Paitone","Bassano Bresciano","Mura","Cimbergo","Ro Volciano","Prevalle","Cividate Camuno","Vione","Calvisano","Roncadelle","Rodengo Saiano","Seniga","Roccafranca","Verolanuova","Rudiano","Gavardo","Moniga del Garda","Quinzano d'Oglio","Saviore dell'Adamello","Bienno","Cologne","Pozzolengo","Sirmione","Zone","Artogne","Bedizzole","Tignale","San Zeno Naviglio","Bagolino","Paderno Franciacorta","Adro"],"Pavia":["Montalto Pavese","Cilavegna","Casteggio","Valle Salimbene","Albuzzano","Corvino San Quirico","Gambarana","Certosa di Pavia","Pieve del Cairo","Santa Margherita di Staffora","Velezzo Lomellina","Suardi","Spessa","Cassolnovo","Robbio","Giussago","Romagnese","Zenevredo","Corana","Mede","Costa de' Nobili","Mont Beccaria","Rea","Casei Gerola","San Zenone al Po","Battuda","Nicorvo","Lirio","Oliva Gessi","Bastida Pancarana","Rocca Susella","Bagnaria","San Genesio ed Uniti","Godiasco Salice Terme","San Cipriano Po","Zeccone","Santa Maria della Versa","Voghera","Golferenzo","Badia Pavese","Broni","Cecima","Pinarolo Po","Roncaro","Lardirago","Fortunago","Zerbol","Vistarino","Rovescala","Ponte Nizza","Sartirana Lomellina","Marzano","Confienza","Castelnovetto","Canneto Pavese","Garlasco","Marcignago","Sommo","Varzi","San Damiano al Colle","Borgoratto Mormorolo","Langosco","Vellezzo Bellini","Scaldasole","Colli Verdi","Verretto","Santa Cristina e Bissone","Verrua Po","Olevano di Lomellina","Lomello","Zeme","Bascap","Brallo di Pregola","Ceranova","Gravellona Lomellina","Cozzo","Semiana","Albonese","Siziano","Borgo Priolo","Trivolzio","Rivanazzano Terme","Barbianello","Villanterio","Galliavola","Silvano Pietra","Menconico","Montesegale","Frascarolo","Magherno","Montescano","Torre d'Arese","Trovo","Castelletto di Branduzzo","Ferrera Erbognone","Candia Lomellina","Torricella Verzate","Tromello","Castana","Inverno e Monteleone","Arena Po","Cervesina","Mezzana Rabattone","Bosnasco","Zinasco","Bereguardo","Casorate Primo","Sannazzaro de' Burgondi","Stradella","Vigevano","Gambol","Castello d'Agogna","Portalbera","Pancarana","Val di Nizza","Pietra de' Giorgi","Landriano","Valle Lomellina","Volpara","Pavia","Santa Giuletta","Retorbido","Redavalle","Torrevecchia Pia","Robecco Pavese","Cava Manara","Palestro","Dorno","Codevilla","Casatisma","Zerbo","Montebello della Battaglia","Sant'Angelo Lomellina","Pieve Albignola","Monticelli Pavese","Torre Beretti e Castellaro","Mezzana Bigli","Cigognola","Borgarello","Lungavilla","Corteolona e Genzone","Bressana Bottarone","Borgo San Siro","Cura Carpignano","Chignolo Po","Rosasco","Montecalvo Versiggia","Calvignano","Mornico Losana","Cornale e Bastida","Parona","Mezzanino","Breme","Copiano","Casanova Lonati","Sant'Alessio con Vialone","Rognano","San Martino Siccomario","Pizzale","Vidigulfo","Travac Siccomario","Miradolo Terme","Campospinoso Albaredo","Gerenzago","Alagna","Torre de' Negri","Cergnago","Villa Biscossi","Torre d'Isola","Belgioioso","Torrazza Coste","Zavattarello","Rocca de' Giorgi","Villanova d'Ardenghi","Valeggio","Mortara","San Giorgio di Lomellina","Carbonara al Ticino","Bornasco","Pieve Porto Morone","Ceretto Lomellina","Linarolo","Gropello Cairoli","Filighera","Ottobiano"],"Cremona":["Cumignano sul Naviglio","Casalmorano","Quintano","Gombito","Spineda","Pozzaglio ed Uniti","Agnadello","Chieve","Camisano","Casaletto di Sopra","Casalbuttano ed Uniti","Pianengo","Robecco d'Oglio","Gussola","Sesto ed Uniti","Corte de' Cortesi con Cignone","Vescovato","Castelleone","Trigolo","Pieranica","Torlino Vimercati","Crema","Martignana di Po","Cappella Cantone","Casalmaggiore","Ostiano","Cella Dati","Trescore Cremasco","Spinadesco","Torre de' Picenardi","Offanengo","Casaletto Vaprio","Formigara","Rivarolo del Re ed Uniti","Capralba","Campagnola Cremasca","San Giovanni in Croce","Cappella de' Picenardi","Gerre de' Caprioli","Crotta d'Adda","Voltido","Sospiro","San Daniele Po","Bonemerse","Calvatone","Paderno Ponchielli","Solarolo Rainerio","Bagnolo Cremasco","Capergnanica","Vailate","Izano","Cicognolo","Pizzighettone","Dovera","San Bassano","Castel Gabbiano","Soresina","Rivolta d'Adda","Sergnano","Pessina Cremonese","Casale Cremasco-Vidolasco","Spino d'Adda","Ripalta Guerina","San Martino del Lago","Gadesco-Pieve Delmona","Corte de' Frati","Volongo","Ripalta Cremasca","Cremosano","Ricengo","Grumello Cremonese ed Uniti","Romanengo","Persico Dosimo","Pescarolo ed Uniti","Montodine","Azzanello","Salvirola","Scandolara Ripa d'Oglio","Moscazzano","Castelvisconti","Motta Baluffi","Piadena Drizzona","Annicco","Isola Dovarese","Genivolta","Credera Rubbiano","Scandolara Ravara","Pieve San Giacomo","Madignano","Ripalta Arpina","Casaletto Ceredano","Castelverde","Stagno Lombardo","Gabbioneta-Binanuova","Derovere","Cingia de' Botti","Torricella del Pizzo","Soncino","Casteldidone","Pieve d'Olmi","Tornata","Fiesco","Pandino","Ticengo","Vaiano Cremasco","Cremona","Bordolano","Olmeneta","Grontardo","Palazzo Pignano","Acquanegra Cremonese","Monte Cremasco","Malagnino"],"Mantova":["San Giorgio Bigarello","Curtatone","Volta Mantovana","Monzambano","Castel Goffredo","Castiglione delle Stiviere","Mantova","Roncoferraro","San Giacomo delle Segnate","Cavriana","Suzzara","Casalmoro","Commessaggio","Rodigo","Quistello","Sabbioneta","Gazoldo degli Ippoliti","Borgo Virgilio","Goito","Pegognaga","Moglia","Villimpenta","Acquanegra sul Chiese","Ceresara","Quingentole","San Giovanni del Dosso","Ostiglia","Mariana Mantovana","Medole","Gazzuolo","Schivenoglia","Asola","Poggio Rusco","Casaloldo","Ponti sul Mincio","Bagnolo San Vito","Solferino","Pomponesco","Castel d'Ario","Guidizzolo","Bozzolo","Castellucchio","Marcaria","Magnacavallo","Casalromano","Porto Mantovano","Redondesco","San Martino dall'Argine","Sustinente","Canneto sull'Oglio","Castelbelforte","Sermide e Felonica","Viadana","Gonzaga","Piubega","Borgo Mantovano","Serravalle a Po","Dosolo","Borgocarbonara","Marmirolo","Roverbella","Rivarolo Mantovano","San Benedetto Po","Motteggiana"],"Lecco":["Margno","Costa Masnaga","Garlate","Calco","Valgreghentino","Nibionno","Premana","Barzan","Oliveto Lario","Ballabio","Cremeno","Garbagnate Monastero","Pagnona","Dolzago","Brivio","Vercurago","Airuno","Colico","Esino Lario","Primaluna","Valvarrone","Cassago Brianza","Colle Brianza","Monticello Brianza","Missaglia","Suello","Castello di Brianza","Cesana Brianza","Pasturo","Malgrate","Valmadrera","Montevecchia","Molteno","Bellano","Carenno","Dervio","Casargo","Monte Marenzo","Bulciago","Cassina Valsassina","Rogeno","Cernusco Lombardone","Varenna","Verderio","Lierna","Olgiate Molgora","Casatenovo","Santa Maria Ho","Cortenova","Moggio","Robbiate","Merate","Crandola Valsassina","Galbiate","Lecco","Parlasco","Annone di Brianza","Sueglio","Oggiono","La Valletta Brianza","Olginate","Morterone","Erve","Ello","Calolziocorte","Dorio","Imbersago","Paderno d'Adda","Taceno","Sirone","Mandello del Lario","Pescate","Bosisio Parini","Perledo","Osnago","Sirtori","Barzio","Civate","Abbadia Lariana","Barzago","Lomagna","Vigan","Cremella","Introbio"],"Lodi":["Maccastorna","Brembio","Borgo San Giovanni","Castelnuovo Bocca d'Adda","Tavazzano con Villavesco","Caselle Landi","Marudo","San Rocco al Porto","Caselle Lurani","Cavenago d'Adda","Meleti","Comazzo","Valera Fratta","San Fiorano","Salerano sul Lambro","Boffalora d'Adda","Castiraga Vidardo","Terranova dei Passerini","Bertonico","Cornovecchio","Somaglia","Crespiatica","Livraga","Villanova del Sillaro","San Martino in Strada","Orio Litta","Abbadia Cerreto","Cornegliano Laudense","Fombio","Lodi","Ospedaletto Lodigiano","Massalengo","Corno Giovine","Mairago","Mulazzano","Merlino","Borghetto Lodigiano","Galgagnano","Senna Lodigiana","Secugnago","Zelo Buon Persico","Turano Lodigiano","Cervignano d'Adda","Sant'Angelo Lodigiano","Castiglione d'Adda","Pieve Fissiraga","Casalmaiocco","Lodi Vecchio","Casalpusterlengo","Castelgerundo","Guardamiglio","Montanaso Lombardo","Corte Palasio","Graffignana","Ossago Lodigiano","Santo Stefano Lodigiano","Codogno","Sordio","Maleo","Casaletto Lodigiano"],"Monza e della Brianza":["Lentate sul Seveso","Bernareggio","Roncello","Albiate","Usmate Velate","Barlassina","Cesano Maderno","Aicurzio","Vimercate","Limbiate","Monza","Lazzate","Cornate d'Adda","Mezzago","Briosco","Correzzana","Burago di Molgora","Vedano al Lambro","Ornago","Carate Brianza","Giussano","Concorezzo","Bellusco","Arcore","Besana in Brianza","Brugherio","Camparada","Nova Milanese","Lissone","Seregno","Sulbiate","Ronco Briantino","Ceriano Laghetto","Carnate","Cavenago di Brianza","Seveso","Triuggio","Cogliate","Caponago","Agrate Brianza","Verano Brianza","Macherio","Lesmo","Misinto","Muggi","Varedo","Bovisio-Masciago","Biassono","Meda","Renate","Sovico","Desio","Veduggio con Colzano","Villasanta","Busnago"]}`), av = { Verona: ["Erbezzo", "Sanguinetto", "Villa Bartolomea", "San Giovanni Ilarione", "Caldiero", "Nogara", "Mezzane di Sotto", "Castel d'Azzano", "Lazise", "Pescantina", "Bonavigo", "Cerro Veronese", "Verona", "Boschi Sant'Anna", "Fumane", "Oppeano", "Povegliano Veronese", "Cerea", "Bardolino", "Isola della Scala", "Castelnuovo del Garda", "Nogarole Rocca", "Bussolengo", "San Pietro in Cariano", "Affi", "Angiari", "San Bonifacio", "Badia Calavena", "Valeggio sul Mincio", "Zevio", "Castagnaro", "Soave", "Terrazzo", "Velo Veronese", "Lavagno", "Rivoli Veronese", "Bevilacqua", "Erb", "Isola Rizza", "Montecchia di Crosara", "Ronco all'Adige", "Torri del Benaco", "Selva di Progno", "Veronella", "Arcole", "Colognola ai Colli", "Casaleone", "Legnago", "Vestenanova", "San Martino Buon Albergo", "Ferrara di Monte Baldo", "San Giovanni Lupatoto", "Dolc", "Brentino Belluno", "Pal", "Roverchiara", "Pastrengo", "Peschiera del Garda", "Brenzone sul Garda", "Sona", "San Zeno di Montagna", "Vigasio", "Rover Veronese", "Monteforte d'Alpone", "Concamarise", "Albaredo d'Adige", "Sant'Ambrogio di Valpolicella", "Sorg", "Caprino Veronese", "Gazzo Veronese", "Illasi", "Malcesine", "Garda", "Cologna Veneta", "Pressana", "Tregnago", "Grezzana", "Zimella", "Belfiore", "Sant'Anna d'Alfaedo", "Ronc", "San Mauro di Saline", "Sommacampagna", "Trevenzuolo", "Minerbe", "Villafranca di Verona", "Roveredo di Gu", "Salizzole", "Cavaion Veronese", "Marano di Valpolicella", "Mozzecane", "Costermano sul Garda", "Negrar di Valpolicella", "Cazzano di Tramigna", "Bosco Chiesanuova", "Bovolone", "Buttapietra", "San Pietro di Morubio"], Vicenza: ["Asigliano Veneto", "Val Liona", "Sandrigo", "Posina", "Carr", "Barbarano Mossano", "Montegaldella", "Costabissara", "Grumolo delle Abbadesse", "Lonigo", "Sovizzo", "San Pietro Mussolino", "Nanto", "Solagna", "Marano Vicentino", "Foza", "Altissimo", "Bressanvido", "Dueville", "Longare", "Caldogno", "Roana", "Orgiano", "Agugliaro", "Valli del Pasubio", "Villaga", "Bolzano Vicentino", "Arzignano", "Mussolente", "Monticello Conte Otto", "Breganze", "Chiampo", "Zan", "Malo", "Schiavon", "Romano d'Ezzelino", "Castegnero", "Grisignano di Zocco", "Zugliano", "Noventa Vicentina", "Brendola", "Valdagno", "Albettone", "Vicenza", "Asiago", "Creazzo", "Cornedo Vicentino", "Ros", "Arsiero", "Montecchio Maggiore", "Cartigliano", "Crespadoro", "Lastebasse", "Villaverla", "Montorso Vicentino", "Camisano Vicentino", "Isola Vicentina", "Pojana Maggiore", "Tezze sul Brenta", "Valbrenta", "Gambellara", "Brogliano", "Piovene Rocchette", "Arcugnano", "Castelgomberto", "Gallio", "Pove del Grappa", "Valdastico", "Montecchio Precalcino", "Schio", "Cassola", "Montegalda", "Thiene", "Marostica", "Sarcedo", "Zermeghedo", "Santorso", "Lusiana Conco", "Calvene", "Pozzoleone", "Bassano del Grappa", "Caltrano", "Salcedo", "Rossano Veneto", "Recoaro Terme", "Monteviale", "Chiuppano", "Nove", "Pianezze", "Cogollo del Cengio", "Colceresa", "Velo d'Astico", "Campiglia dei Berici", "Montebello Vicentino", "Trissino", "Torri di Quartesolo", "Alonte", "Sossano", "Laghi", "Nogarole Vicentino", "Altavilla Vicentina", "San Vito di Leguzzano", "Quinto Vicentino", "Zovencedo", "Fara Vicentino", "Tonezza del Cimone", "Sarego", "Torrebelvicino", "Rotzo", "Monte di Malo", "Pedemonte", "Lugo di Vicenza", "Enego"], Belluno: ["Cesiomaggiore", "Lamon", "La Valle Agordina", "Perarolo di Cadore", "Calalzo di Cadore", "Canale d'Agordo", "Pieve di Cadore", "Taibon Agordino", "Sospirolo", "Tambre", "Vallada Agordina", "Gosaldo", "Val di Zoldo", "Seren del Grappa", "Livinallongo del Col di Lana", "Valle di Cadore", "Alpago", "San Gregorio nelle Alpi", "Soverzene", "Falcade", "Arsi", "Cibiana di Cadore", "Ospitale di Cadore", "Alleghe", "Pedavena", "Rocca Pietore", "Comelico Superiore", "Feltre", "Fonzaso", "Borca di Cadore", "San Vito di Cadore", "Sovramonte", "Ponte nelle Alpi", "Borgo Valbelluna", "Santa Giustina", "Rivamonte Agordino", "Limana", "Sedico", "San Nicol di Comelico", "Cencenighe Agordino", "Vodo Cadore", "Zopp di Cadore", "Cortina d'Ampezzo", "Voltago Agordino", "Agordo", "Chies d'Alpago", "Auronzo di Cadore", "Lorenzago di Cadore", "San Tomaso Agordino", "Longarone", "Belluno", "Colle Santa Lucia", "Selva di Cadore", "Vigo di Cadore", "Domegge di Cadore", "Setteville", "Lozzo di Cadore", "Danta di Cadore", "Santo Stefano di Cadore", "San Pietro di Cadore"], Treviso: ["Treviso", "Gaiarine", "Segusino", "Sernaglia della Battaglia", "Vedelago", "Ponte di Piave", "Maserada sul Piave", "Povegliano", "San Vendemiano", "Codogn", "Possagno", "Riese Pio X", "Silea", "Motta di Livenza", "Roncade", "Borso del Grappa", "Sarmede", "Villorba", "Susegana", "San Pietro di Feletto", "Vazzola", "Castelfranco Veneto", "Casale sul Sile", "Salgareda", "Vidor", "Pieve di Soligo", "Ponzano Veneto", "Portobuffol", "Casier", "Revine Lago", "San Fior", "Follina", "Farra di Soligo", "Caerano di San Marco", "Godega di Sant'Urbano", "Resana", "Morgano", "Meduna di Livenza", "Spresiano", "Colle Umberto", "Cappella Maggiore", "Orsago", "Mogliano Veneto", "Zenson di Piave", "San Biagio di Callalta", "Paese", "Preganziol", "Maser", "Ormelle", "Cornuda", "Gorgo al Monticano", "Cavaso del Tomba", "Fontanelle", "Cimadolmo", "Conegliano", "Vittorio Veneto", "Breda di Piave", "Oderzo", "Nervesa della Battaglia", "San Zenone degli Ezzelini", "Zero Branco", "Chiarano", "Arcade", "Trevignano", "Fregona", "Cordignano", "Montebelluna", "Santa Lucia di Piave", "Monastier di Treviso", "Asolo", "Istrana", "Mareno di Piave", "Refrontolo", "Pederobba", "Valdobbiadene", "Altivole", "Mansu", "Tarzo", "Cessalto", "Giavera del Montello", "Castello di Godego", "Castelcucco", "San Polo di Piave", "Quinto di Treviso", "Pieve del Grappa", "Monfumo", "Moriago della Battaglia", "Crocetta del Montello", "Cison di Valmarino", "Loria", "Miane", "Volpago del Montello", "Carbonera", "Fonte"], Venezia: ["Jesolo", "Meolo", "Cavallino-Treporti", "Dolo", "Cona", "Mira", "Pianiga", "San Don di Piave", "Pramaggiore", "Mirano", "Noventa di Piave", "Stra", "Gruaro", "Teglio Veneto", "Martellago", "Ceggia", "Musile di Piave", "Santa Maria di Sala", "Venezia", "Quarto d'Altino", "Campagna Lupia", "Eraclea", "Annone Veneto", "Portogruaro", "San Stino di Livenza", "San Michele al Tagliamento", "Fossalta di Portogruaro", "Camponogara", "Concordia Sagittaria", "Cavarzere", "Caorle", "Campolongo Maggiore", "Fiesso d'Artico", "Vigonovo", "Chioggia", "Scorz", "Foss", "Spinea", "Cinto Caomaggiore", "Noale", "Salzano", "Fossalta di Piave", "Torre di Mosto", "Marcon"], Padova: ["Casalserugo", "Cartura", "Arzergrande", "Castelbaldo", "Stanghella", "Mestrino", "Ponso", "Camposampiero", "Legnaro", "Vo'", "Piove di Sacco", "Arre", "Campo San Martino", "Noventa Padovana", "Due Carrare", "Montagnana", "Arqu Petrarca", "San Martino di Lupari", "Vigonza", "Carmignano di Brenta", "Lozzo Atestino", "Tombolo", "Campodoro", "San Pietro in Gu", "Ospedaletto Euganeo", "Este", "Barbona", "Baone", "Sant'Elena", "Borgo Veneto", "Battaglia Terme", "Cervarese Santa Croce", "Correzzola", "Boara Pisani", "Veggiano", "Torreglia", "Piombino Dese", "Casale di Scodosia", "Villanova di Camposampiero", "Gazzo", "Trebaseleghe", "Villa Estense", "Galzignano Terme", "Montegrotto Terme", "Ponte San Nicol", "Saonara", "Villafranca Padovana", "Piacenza d'Adige", "Tribano", "Solesino", "Megliadino San Vitale", "Masi", "Rubano", "Granze", "Bovolenta", "Merlara", "Teolo", "Codevigo", "Vigodarzere", "Sant'Urbano", "Bagnoli di Sopra", "Conselve", "Cinto Euganeo", "Albignasego", "Terrassa Padovana", "Borgoricco", "Villa del Conte", "Anguillara Veneta", "Urbana", "Curtarolo", "Saccolongo", "Vescovana", "Brugine", "Pontelongo", "San Pietro Viminario", "Maser di Padova", "Limena", "Polverara", "Cadoneghe", "Padova", "Campodarsego", "Pozzonovo", "Massanzago", "Agna", "Loreggia", "Grantorto", "Rovolon", "Fontaniva", "Abano Terme", "Sant'Angelo di Piove di Sacco", "Pernumia", "Santa Caterina d'Este", "Candiana", "Piazzola sul Brenta", "Cittadella", "San Giorgio delle Pertiche", "Galliera Veneta", "Santa Giustina in Colle", "Selvazzano Dentro", "Monselice", "San Giorgio in Bosco"], Rovigo: ["Arqu Polesine", "Polesella", "Costa di Rovigo", "Ariano nel Polesine", "Porto Viro", "Papozze", "Stienta", "Occhiobello", "Canda", "Castelnovo Bariano", "San Bellino", "Villadose", "Ceneselli", "Ceregnano", "Salara", "Castelmassa", "Porto Tolle", "Guarda Veneta", "Bergantino", "Villanova del Ghebbo", "Pettorazza Grimani", "Canaro", "Castelguglielmo", "Villamarzana", "Badia Polesine", "Gavello", "Adria", "Ficarolo", "Bagnolo di Po", "Bosaro", "Corbola", "Giacciano con Baruchella", "Calto", "Fratta Polesine", "Lusia", "Melara", "San Martino di Venezze", "Pontecchio Polesine", "Pincara", "Lendinara", "Taglio di Po", "Trecenta", "Frassinelle Polesine", "Rovigo", "Loreo", "Fiesso Umbertiano", "Rosolina", "Crespino", "Gaiba", "Villanova Marchesana"] }, ov = { "Pesaro e Urbino": ["Fermignano", "Borgo Pace", "Pergola", "Serra Sant'Abbondio", "Urbania", "San Costanzo", "Mercatino Conca", "Piandimeleto", "Pesaro", "Gabicce Mare", "Mondolfo", "Gradara", "Urbino", "Sassocorvaro Auditore", "Petriano", "Lunano", "Frontone", "Tavullia", "Fratte Rosa", "Peglio", "Montelabbate", "Cantiano", "Sant'Ippolito", "Vallefoglia", "Sant'Angelo in Vado", "San Lorenzo in Campo", "Fano", "Montecalvo in Foglia", "Monte Grimano Terme", "Fossombrone", "Piobbico", "Terre Roveresche", "Monte Porzio", "Monte Cerignone", "Mombaroccio", "Belforte all'Isauro", "Mercatello sul Metauro", "Apecchio", "Pietrarubbia", "Isola del Piano", "Carpegna", "Montefelcino", "Tavoleto", "Colli al Metauro", "Macerata Feltria", "Cartoceto", "Cagli", "Acqualagna", "Frontino", "Mondavio"], Ancona: ["Ancona", "Agugliano", "Monsano", "Polverigi", "Sirolo", "Cerreto d'Esi", "Chiaravalle", "Arcevia", "Monte San Vito", "Filottrano", "Santa Maria Nuova", "Staffolo", "Fabriano", "Poggio San Marcello", "Mergo", "Falconara Marittima", "Osimo", "Castelleone di Suasa", "San Paolo di Jesi", "Castelbellino", "Jesi", "Camerano", "Belvedere Ostrense", "Serra de' Conti", "Morro d'Alba", "Castelplanio", "Maiolati Spontini", "Camerata Picena", "Sassoferrato", "Corinaldo", "Ostra", "Genga", "Monte Roberto", "Castelfidardo", "Rosora", "Trecastelli", "Cupramontana", "Montemarciano", "Serra San Quirico", "Numana", "Montecarotto", "Loreto", "Ostra Vetere", "San Marcello", "Senigallia", "Barbara", "Offagna"], Macerata: ["Corridonia", "Sarnano", "Valfornace", "Pollenza", "Pioraco", "Macerata", "Ussita", "Appignano", "Apiro", "Mogliano", "Muccia", "Poggio San Vicino", "Penna San Giovanni", "Sant'Angelo in Pontano", "Camporotondo di Fiastrone", "San Severino Marche", "Fiuminata", "Tolentino", "Recanati", "Ripe San Ginesio", "Urbisaglia", "Montefano", "Montecosaro", "Belforte del Chienti", "Treia", "Fiastra", "Sefro", "Potenza Picena", "Bolognola", "Pieve Torina", "Morrovalle", "Castelraimondo", "Loro Piceno", "Monte Cavallo", "Serrapetrona", "Porto Recanati", "Gagliole", "Cessapalombo", "Matelica", "Montecassiano", "Monte San Giusto", "Monte San Martino", "Esanatoglia", "Montelupone", "Visso", "Cingoli", "Gualdo", "Caldarola", "Camerino", "Petriolo", "Colmurano", "San Ginesio", "Civitanova Marche", "Castelsantangelo sul Nera", "Serravalle di Chienti"], "Ascoli Piceno": ["Carassai", "Monteprandone", "Castorano", "Arquata del Tronto", "Grottammare", "Cupra Marittima", "Montalto delle Marche", "Maltignano", "Appignano del Tronto", "Roccafluvione", "Acquaviva Picena", "Castignano", "Montedinove", "Montegallo", "Force", "Montemonaco", "Rotella", "Montefiore dell'Aso", "Cossignano", "Monsampolo del Tronto", "Massignano", "Palmiano", "Colli del Tronto", "Spinetoli", "Folignano", "San Benedetto del Tronto", "Venarotta", "Ripatransone", "Comunanza", "Offida", "Acquasanta Terme", "Castel di Lama", "Ascoli Piceno"], Fermo: ["Monte San Pietrangeli", "Amandola", "Montottone", "Monsampietro Morico", "Monterubbiano", "Sant'Elpidio a Mare", "Rapagnano", "Monte Vidon Combatte", "Pedaso", "Montefalcone Appennino", "Belmonte Piceno", "Montefortino", "Fermo", "Montelparo", "Servigliano", "Santa Vittoria in Matenano", "Monteleone di Fermo", "Lapedona", "Falerone", "Porto Sant'Elpidio", "Monte Urano", "Petritoli", "Moresco", "Montappone", "Porto San Giorgio", "Montegranaro", "Monte Rinaldo", "Monte Giberto", "Ortezzano", "Torre San Patrizio", "Francavilla d'Ete", "Magliano di Tenna", "Montegiorgio", "Massa Fermana", "Campofilone", "Monte Vidon Corrado", "Altidona", "Grottazzolina", "Ponzano di Fermo", "Smerillo"] }, rv = { "Massa-Carrara": ["Bagnone", "Montignoso", "Aulla", "Podenzana", "Fosdinovo", "Licciana Nardi", "Pontremoli", "Villafranca in Lunigiana", "Zeri", "Comano", "Tresana", "Mulazzo", "Massa", "Casola in Lunigiana", "Fivizzano", "Filattiera", "Carrara"], Lucca: ["Camaiore", "Castelnuovo di Garfagnana", "Lucca", "San Romano in Garfagnana", "Fosciandora", "Sillano Giuncugnano", "Altopascio", "Coreglia Antelminelli", "Piazza al Serchio", "Pescaglia", "Pietrasanta", "Gallicano", "Borgo a Mozzano", "Pieve Fosciana", "Molazzana", "Barga", "Castiglione di Garfagnana", "Massarosa", "Villa Basilica", "Careggine", "Vagli Sotto", "Bagni di Lucca", "Camporgiano", "Montecarlo", "Viareggio", "Capannori", "Stazzema", "Forte dei Marmi", "Minucciano", "Fabbriche di Vergemoli", "Seravezza", "Villa Collemandina", "Porcari"], Pistoia: ["Lamporecchio", "Marliana", "Agliana", "Pieve a Nievole", "Quarrata", "Sambuca Pistoiese", "Pistoia", "Larciano", "Ponte Buggianese", "Serravalle Pistoiese", "Pescia", "Uzzano", "Monsummano Terme", "Buggiano", "Abetone Cutigliano", "Montecatini-Terme", "Chiesina Uzzanese", "Montale", "San Marcello Piteglio", "Massa e Cozzile"], Firenze: ["Signa", "San Godenzo", "Greve in Chianti", "Vicchio", "Palazzuolo sul Senio", "Empoli", "Capraia e Limite", "Montespertoli", "Londa", "Firenze", "Barberino Tavarnelle", "Castelfiorentino", "Dicomano", "Gambassi Terme", "Rufina", "Cerreto Guidi", "Rignano sull'Arno", "Pontassieve", "Figline e Incisa Valdarno", "Certaldo", "Bagno a Ripoli", "San Casciano in Val di Pesa", "Scandicci", "Calenzano", "Barberino di Mugello", "Impruneta", "Montelupo Fiorentino", "Fiesole", "Sesto Fiorentino", "Vinci", "Borgo San Lorenzo", "Firenzuola", "Pelago", "Scarperia e San Piero", "Campi Bisenzio", "Vaglia", "Fucecchio", "Montaione", "Reggello", "Lastra a Signa", "Marradi"], Livorno: ["Porto Azzurro", "Marciana Marina", "Capoliveri", "Capraia Isola", "Campo nell'Elba", "Sassetta", "Collesalvetti", "Portoferraio", "Suvereto", "Campiglia Marittima", "Livorno", "Piombino", "Bibbona", "San Vincenzo", "Castagneto Carducci", "Rosignano Marittimo", "Cecina", "Rio", "Marciana"], Pisa: ["San Giuliano Terme", "Pontedera", "Palaia", "Castelnuovo di Val di Cecina", "Lajatico", "Vecchiano", "Peccioli", "Monteverdi Marittimo", "Castellina Marittima", "Buti", "Pisa", "Santa Croce sull'Arno", "Riparbella", "Fauglia", "Calci", "Terricciola", "Casale Marittimo", "Pomarance", "Santa Luce", "Chianni", "Bientina", "Castelfranco di Sotto", "Vicopisano", "Montopoli in Val d'Arno", "Santa Maria a Monte", "Cascina", "Volterra", "Montecatini Val di Cecina", "Capannoli", "Crespina Lorenzana", "Casciana Terme Lari", "Guardistallo", "Montescudaio", "San Miniato", "Calcinaia", "Ponsacco", "Orciano Pisano"], Arezzo: ["Foiano della Chiana", "Montevarchi", "Sansepolcro", "Civitella in Val di Chiana", "Chiusi della Verna", "Caprese Michelangelo", "Montemignaio", "Bucine", "Arezzo", "Sestino", "Ortignano Raggiolo", "Cavriglia", "San Giovanni Valdarno", "Marciano della Chiana", "Poppi", "Talla", "Capolona", "Terranuova Bracciolini", "Castiglion Fibocchi", "Castel San Niccol", "Cortona", "Laterina Pergine Valdarno", "Chitignano", "Monterchi", "Loro Ciuffenna", "Anghiari", "Badia Tedalda", "Subbiano", "Pratovecchio Stia", "Castel Focognano", "Castiglion Fiorentino", "Castelfranco Piandisc", "Monte San Savino", "Lucignano", "Pieve Santo Stefano", "Bibbiena"], Siena: ["Monteriggioni", "Sinalunga", "Chiusi", "Sarteano", "Montalcino", "Rapolano Terme", "Radda in Chianti", "Chiusdino", "Gaiole in Chianti", "Castellina in Chianti", "Torrita di Siena", "Pienza", "Casole d'Elsa", "Piancastagnaio", "Abbadia San Salvatore", "Monticiano", "Siena", "San Quirico d'Orcia", "Chianciano Terme", "San Gimignano", "Radicondoli", "Radicofani", "Cetona", "Sovicille", "Castelnuovo Berardenga", "Buonconvento", "Castiglione d'Orcia", "Montepulciano", "Trequanda", "Asciano", "Murlo", "Poggibonsi", "San Casciano dei Bagni", "Colle di Val d'Elsa", "Monteroni d'Arbia"], Grosseto: ["Monte Argentario", "Roccastrada", "Monterotondo Marittimo", "Castell'Azzara", "Arcidosso", "Campagnatico", "Civitella Paganico", "Capalbio", "Pitigliano", "Sorano", "Seggiano", "Gavorrano", "Castel del Piano", "Montieri", "Scarlino", "Santa Fiora", "Roccalbegna", "Scansano", "Isola del Giglio", "Cinigiano", "Massa Marittima", "Grosseto", "Orbetello", "Semproniano", "Manciano", "Castiglione della Pescaia", "Magliano in Toscana", "Follonica"], Prato: ["Cantagallo", "Poggio a Caiano", "Vaiano", "Vernio", "Montemurlo", "Carmignano", "Prato"] }, lv = { Perugia: ["Monte Santa Maria Tiberina", "Passignano sul Trasimeno", "Valtopina", "Marsciano", "Cerreto di Spoleto", "Cannara", "Bettona", "Piegaro", "Sant'Anatolia di Narco", "Preci", "Scheggino", "Torgiano", "Magione", "Bastia Umbra", "Assisi", "Spello", "Campello sul Clitunno", "Collazzone", "Foligno", "Nocera Umbra", "Massa Martana", "Montone", "Panicale", "Trevi", "Corciano", "San Giustino", "Costacciaro", "Pietralunga", "Norcia", "Paciano", "Gualdo Cattaneo", "Todi", "Monte Castello di Vibio", "Montefalco", "Bevagna", "Gualdo Tadino", "Monteleone di Spoleto", "Castiglione del Lago", "Cascia", "Scheggia e Pascelupo", "Fossato di Vico", "Castel Ritaldi", "Sellano", "Tuoro sul Trasimeno", "Perugia", "Citerna", "Citt di Castello", "Fratta Todina", "Giano dell'Umbria", "Gubbio", "Lisciano Niccone", "Citt della Pieve", "Spoleto", "Poggiodomo", "Deruta", "Vallo di Nera", "Valfabbrica", "Umbertide", "Sigillo"], Terni: ["Parrano", "Ferentillo", "Montecastrilli", "Attigliano", "Calvi dell'Umbria", "Guardea", "San Venanzo", "Narni", "Monteleone d'Orvieto", "Montegabbione", "Alviano", "Orvieto", "Castel Viscardo", "Montefranco", "Arrone", "Polino", "Otricoli", "Ficulle", "San Gemini", "Fabro", "Amelia", "Penna in Teverina", "Castel Giorgio", "Lugnano in Teverina", "Baschi", "Porano", "Avigliano Umbro", "Montecchio", "Allerona", "Acquasparta", "Stroncone", "Giove", "Terni"] }, sv = { Viterbo: ["Civitella d'Agliano", "Cellere", "Canepina", "Piansano", "Soriano nel Cimino", "Gradoli", "Castiglione in Teverina", "Carbognano", "Ronciglione", "Orte", "Civita Castellana", "Tuscania", "Valentano", "Vignanello", "Fabrica di Roma", "Capranica", "Barbarano Romano", "Celleno", "Latera", "Villa San Giovanni in Tuscia", "Tarquinia", "Vallerano", "Tessennano", "Arlena di Castro", "Blera", "Bassano in Teverina", "Castel Sant'Elia", "Montalto di Castro", "Nepi", "Vetralla", "Gallese", "Oriolo Romano", "Marta", "Monterosi", "Bolsena", "Grotte di Castro", "Vasanello", "Montefiascone", "Bomarzo", "Onano", "Viterbo", "Bassano Romano", "Caprarola", "Corchiano", "Lubriano", "Proceno", "Vitorchiano", "Acquapendente", "San Lorenzo Nuovo", "Sutri", "Bagnoregio", "Faleria", "Ischia di Castro", "Vejano", "Canino", "Capodimonte", "Monte Romano", "Calcata", "Farnese", "Graffignano"], Rieti: ["Fara in Sabina", "Fiamignano", "Castelnuovo di Farfa", "Rocca Sinibalda", "Labro", "Vacone", "Rivodutri", "Montopoli di Sabina", "Greccio", "Pescorocchiano", "Poggio San Lorenzo", "Borbona", "Salisano", "Poggio Bustone", "Poggio Mirteto", "Tarano", "Borgorose", "Monteleone Sabino", "Frasso Sabino", "Morro Reatino", "Cottanello", "Leonessa", "Roccantica", "Selci", "Belmonte in Sabina", "Montasola", "Pozzaglia Sabina", "Antrodoco", "Collegiove", "Forano", "Montebuono", "Casperia", "Castel Sant'Angelo", "Poggio Nativo", "Cittareale", "Colle di Tora", "Poggio Moiano", "Magliano Sabina", "Stimigliano", "Monte San Giovanni in Sabina", "Torricella in Sabina", "Borgo Velino", "Mompeo", "Colli sul Velino", "Nespolo", "Longone Sabino", "Casaprota", "Paganico Sabino", "Scandriglia", "Varco Sabino", "Montenero Sabino", "Marcetelli", "Collalto Sabino", "Contigliano", "Poggio Catino", "Torri in Sabina", "Orvinio", "Castel di Tora", "Concerviano", "Cantalupo in Sabina", "Cantalice", "Cittaducale", "Toffia", "Posta", "Amatrice", "Collevecchio", "Configni", "Micigliano", "Rieti", "Accumoli", "Turania", "Petrella Salto", "Ascrea"], Roma: ["San Polo dei Cavalieri", "Bellegra", "Filacciano", "Nettuno", "Palombara Sabina", "Vallinfreda", "Cineto Romano", "Lariano", "Nemi", "Affile", "Rocca Canterano", "Poli", "Grottaferrata", "Marcellina", "Monterotondo", "Montelanico", "Pisoniano", "Riofreddo", "Mazzano Romano", "Fiano Romano", "Anticoli Corrado", "Ponzano Romano", "Montorio Romano", "Gerano", "Mandela", "Bracciano", "Roccagiovine", "Roma", "Palestrina", "Casape", "Carpineto Romano", "Roviano", "Tolfa", "Formello", "Ariccia", "Cerveteri", "Allumiere", "Subiaco", "Gavignano", "Lanuvio", "Rocca Priora", "Mentana", "Valmontone", "Colonna", "Monte Compatri", "Ardea", "Castel San Pietro Romano", "Zagarolo", "Civitella San Paolo", "Cervara di Roma", "Marano Equo", "Magliano Romano", "Moricone", "Monteflavio", "Torrita Tiberina", "San Cesareo", "Anzio", "Civitavecchia", "Rignano Flaminio", "Artena", "Jenne", "Arsoli", "Percile", "Rocca Santo Stefano", "Sambuci", "Agosta", "Saracinesco", "Sant'Angelo Romano", "Cerreto Laziale", "Castel Madama", "Sant'Oreste", "Arcinazzo Romano", "Ciciliano", "Vivaro Romano", "Vicovaro", "Velletri", "Olevano Romano", "Ladispoli", "Pomezia", "Rocca di Cave", "San Vito Romano", "Nerola", "Sacrofano", "Albano Laziale", "Morlupo", "Nazzano", "Monte Porzio Catone", "Castel Gandolfo", "Rocca di Papa", "Fiumicino", "Castelnuovo di Porto", "Santa Marinella", "Colleferro", "Canterano", "Tivoli", "Capena", "Cave", "Genzano di Roma", "Trevignano Romano", "Camerata Nuova", "Frascati", "Vallepietra", "Roiate", "Genazzano", "San Gregorio da Sassola", "Campagnano di Roma", "Guidonia Montecelio", "Fonte Nuova", "Montelibretti", "Ciampino", "Canale Monterano", "Gorga", "Gallicano nel Lazio", "Labico", "Manziana", "Capranica Prenestina", "Licenza", "Marino", "Anguillara Sabazia", "Riano", "Segni"], Latina: ["Castelforte", "Maenza", "Prossedi", "Minturno", "Formia", "Sabaudia", "Aprilia", "Campodimele", "Rocca Massima", "Lenola", "Cori", "Roccasecca dei Volsci", "Latina", "Pontinia", "Cisterna di Latina", "Terracina", "Santi Cosma e Damiano", "Roccagorga", "Sonnino", "Norma", "Sezze", "Ponza", "Spigno Saturnia", "Sermoneta", "Itri", "San Felice Circeo", "Fondi", "Ventotene", "Bassiano", "Priverno", "Gaeta", "Monte San Biagio", "Sperlonga"], Frosinone: ["Pignataro Interamna", "Torre Cajetani", "Viticuso", "Ripi", "Paliano", "Sant'Elia Fiumerapido", "Vico nel Lazio", "Boville Ernica", "Rocca d'Arce", "Villa Santa Lucia", "Alvito", "Fumone", "San Biagio Saracinisco", "Picinisco", "Ausonia", "Aquino", "Campoli Appennino", "Pofi", "San Giovanni Incarico", "Supino", "Villa Santo Stefano", "Piedimonte San Germano", "Castro dei Volsci", "Esperia", "Cassino", "Villa Latina", "Roccasecca", "Pontecorvo", "Ferentino", "Posta Fibreno", "Vicalvi", "Arce", "Santopadre", "Broccostella", "Coreno Ausonio", "Sgurgola", "Piglio", "Acuto", "Sant'Apollinare", "Casalattico", "Colfelice", "Vallerotonda", "Belmonte Castello", "Collepardo", "Sant'Ambrogio sul Garigliano", "Arpino", "Sora", "Gallinaro", "Trivigliano", "Castelliri", "Casalvieri", "Monte San Giovanni Campano", "Ceprano", "Settefrati", "Pico", "Castelnuovo Parano", "Trevi nel Lazio", "Vallemaio", "Morolo", "Amaseno", "San Donato Val di Comino", "Acquafondata", "Atina", "Filettino", "Vallecorsa", "Torrice", "Castrocielo", "Isola del Liri", "Cervaro", "Veroli", "Fontechiari", "San Vittore del Lazio", "Ceccano", "Alatri", "Giuliano di Roma", "Arnara", "Serrone", "Fontana Liri", "Falvaterra", "Sant'Andrea del Garigliano", "Anagni", "Colle San Magno", "Pastena", "Patrica", "Terelle", "Fiuggi", "Guarcino", "San Giorgio a Liri", "Frosinone", "Pescosolido", "Strangolagalli"] }, uv = { Caserta: ["Cervino", "Marcianise", "Cesa", "Ailano", "Rocchetta e Croce", "Valle di Maddaloni", "Alvignano", "Capriati a Volturno", "Santa Maria la Fossa", "Casal di Principe", "Riardo", "Sant'Arpino", "Frignano", "Liberi", "Gallo Matese", "Castel Volturno", "Aversa", "Succivo", "Teano", "Roccamonfina", "Grazzanise", "Presenzano", "Castel Morrone", "San Marco Evangelista", "San Prisco", "Vairano Patenora", "Carinaro", "Villa di Briano", "Letino", "Marzano Appio", "Sparanise", "Casagiove", "Ruviano", "San Gregorio Matese", "Sant'Angelo d'Alife", "Valle Agricola", "Arienzo", "Curti", "Cellole", "Piedimonte Matese", "Piana di Monte Verna", "San Pietro Infine", "Castello del Matese", "Pontelatone", "Falciano del Massico", "Caserta", "Calvi Risorta", "Pastorano", "Casapesenna", "Mondragone", "Casapulla", "Cancello ed Arnone", "Pignataro Maggiore", "San Felice a Cancello", "Castel di Sasso", "Baia e Latina", "Santa Maria a Vico", "San Nicola la Strada", "Formicola", "Parete", "Roccaromana", "Galluccio", "Alife", "Dragoni", "Orta di Atella", "Pratella", "Caianello", "Lusciano", "San Potito Sannitico", "Pietravairano", "Ciorlano", "Mignano Monte Lungo", "Casaluce", "Capua", "San Tammaro", "Tora e Piccilli", "Portico di Caserta", "Recale", "Macerata Campania", "Gioia Sannitica", "San Cipriano d'Aversa", "Trentola Ducenta", "Villa Literno", "Gricignano di Aversa", "Teverola", "Giano Vetusto", "Rocca d'Evandro", "Conca della Campania", "San Marcellino", "Sessa Aurunca", "Fontegreca", "Carinola", "Prata Sannita", "Pietramelara", "Bellona", "Vitulazio", "Castel Campagnano", "Caiazzo", "Camigliano", "Capodrise", "Santa Maria Capua Vetere", "Francolise", "Maddaloni", "Raviscanina"], Benevento: ["Foglianise", "Circello", "Ponte", "Forchia", "Sant'Agata de' Goti", "Fragneto Monforte", "Limatola", "Molinara", "Cusano Mutri", "Reino", "San Giorgio del Sannio", "Vitulano", "Paupisi", "Calvi", "San Lupo", "Castelpoto", "San Leucio del Sannio", "Montesarchio", "Solopaca", "San Lorenzo Maggiore", "Airola", "Pannarano", "Colle Sannita", "Arpaise", "Durazzano", "Tocco Caudio", "Fragneto l'Abate", "Paolisi", "San Nazzaro", "Santa Croce del Sannio", "Guardia Sanframondi", "Castelfranco in Miscano", "Montefalcone di Val Fortore", "San Giorgio La Molara", "San Lorenzello", "Buonalbergo", "Puglianello", "San Bartolomeo in Galdo", "Telese Terme", "Frasso Telesino", "Moiano", "Casalduni", "San Nicola Manfredi", "Benevento", "Paduli", "San Marco dei Cavoti", "Cautano", "Arpaia", "Baselice", "Cerreto Sannita", "Ginestra degli Schiavoni", "Castelpagano", "Morcone", "Bucciano", "Pietrelcina", "Pago Veiano", "Amorosi", "Torrecuso", "Sant'Arcangelo Trimonte", "Castelvetere in Val Fortore", "Apollosa", "San Martino Sannita", "San Salvatore Telesino", "Campoli del Monte Taburno", "Pontelandolfo", "Apice", "Bonea", "Castelvenere", "Sant'Angelo a Cupolo", "Pietraroja", "Sassinoro", "Foiano di Val Fortore", "Melizzano", "Faicchio", "Ceppaloni", "Campolattaro", "Pesco Sannita", "Dugenta"], Napoli: ["Scisciano", "Striano", "Pozzuoli", "Castellammare di Stabia", "Frattamaggiore", "Forio", "Frattaminore", "Cicciano", "Sant'Antonio Abate", "San Vitaliano", "Somma Vesuviana", "Pomigliano d'Arco", "Caivano", "Castello di Cisterna", "Cardito", "Gragnano", "Calvizzano", "Casamarciano", "Marano di Napoli", "Roccarainola", "Sant'Anastasia", "Tufino", "Poggiomarino", "Volla", "Casola di Napoli", "Portici", "Villaricca", "Capri", "Anacapri", "Lacco Ameno", "Piano di Sorrento", "Melito di Napoli", "Mariglianella", "Crispano", "Meta", "Pimonte", "Acerra", "Camposano", "Pollena Trocchia", "Boscoreale", "Casamicciola Terme", "Grumo Nevano", "Saviano", "Carbonara di Nola", "San Paolo Bel Sito", "Arzano", "Cercola", "Comiziano", "Mugnano di Napoli", "Afragola", "Torre Annunziata", "San Sebastiano al Vesuvio", "Casavatore", "Massa Lubrense", "Bacoli", "Vico Equense", "Ercolano", "San Giorgio a Cremano", "Serrara Fontana", "Visciano", "Torre del Greco", "Sant'Antimo", "Procida", "Casoria", "Quarto", "Napoli", "San Gennaro Vesuviano", "Ischia", "Terzigno", "Casalnuovo di Napoli", "Brusciano", "San Giuseppe Vesuviano", "Boscotrecase", "Santa Maria la Carit", "Marigliano", "Sant'Agnello", "Nola", "Palma Campania", "Cimitile", "Giugliano in Campania", "Trecase", "Pompei", "Monte di Procida", "Sorrento", "Qualiano", "Casandrino", "Lettere", "Barano d'Ischia", "Ottaviano", "Agerola", "Liveri", "Massa di Somma"], Avellino: ["Castelvetere sul Calore", "Atripalda", "Baiano", "Montoro", "Grottolella", "Tufo", "Fontanarosa", "Santo Stefano del Sole", "Monteforte Irpino", "Teora", "Greci", "Trevico", "Vallata", "Montaguto", "Gesualdo", "Cesinali", "Vallesaccarda", "Conza della Campania", "Venticano", "Moschiano", "Pietrastornina", "Paternopoli", "Pietradefusi", "Torrioni", "Senerchia", "Casalbore", "Montemiletto", "Sirignano", "Zungoli", "Sperone", "Rotondi", "Caposele", "Scampitella", "Guardia Lombardi", "San Potito Ultra", "Domicella", "Calabritto", "Chiusano di San Domenico", "Salza Irpina", "Manocalzati", "Cairano", "Quadrelle", "Cassano Irpino", "Quindici", "San Nicola Baronia", "Sant'Andrea di Conza", "Sant'Angelo dei Lombardi", "Montemarano", "Cervinara", "Ospedaletto d'Alpinolo", "San Sossio Baronia", "Serino", "Solofra", "Chianche", "Montefusco", "Mercogliano", "Sorbo Serpico", "Carife", "Forino", "Mirabella Eclano", "Parolise", "Savignano Irpino", "Bagnoli Irpino", "Roccabascerana", "Contrada", "Lacedonia", "Montefalcione", "Grottaminarda", "Lauro", "Montecalvo Irpino", "Summonte", "Pago del Vallo di Lauro", "Castel Baronia", "Aquilonia", "Taurano", "Castelfranci", "Capriglia Irpina", "Volturara Irpina", "Villanova del Battista", "Prata di Principato Ultra", "Sant'Angelo a Scala", "Santa Paolina", "Ariano Irpino", "Villamaina", "Avella", "Montefredane", "Luogosano", "Aiello del Sabato", "Taurasi", "Nusco", "Monteverde", "Avellino", "Rocca San Felice", "Andretta", "Flumeri", "Frigento", "Bonito", "Melito Irpino", "Sant'Angelo all'Esca", "Pratola Serra", "Santa Lucia di Serino", "Mugnano del Cardinale", "Torella dei Lombardi", "Calitri", "Sturno", "San Mango sul Calore", "San Michele di Serino", "Petruro Irpino", "Lapio", "Montella", "Bisaccia", "San Martino Valle Caudina", "Lioni", "Altavilla Irpina", "Morra De Sanctis", "Marzano di Nola", "Candida", "Torre Le Nocelle"], Salerno: ["Cannalonga", "Castelnuovo Cilento", "Romagnano al Monte", "Prignano Cilento", "Scala", "Castel San Giorgio", "Auletta", "Giungano", "Cava de' Tirreni", "Casal Velino", "Casalbuono", "Laurino", "Ravello", "Casaletto Spartano", "San Cipriano Picentino", "Serre", "Tramonti", "Scafati", "Torraca", "Tortorella", "Bellizzi", "Camerota", "Celle di Bulgheria", "Salento", "Monteforte Cilento", "Baronissi", "Sant'Angelo a Fasanella", "Altavilla Silentina", "Salvitelle", "Omignano", "Furore", "Montesano sulla Marcellana", "Castelcivita", "Buonabitacolo", "Sala Consilina", "Santa Marina", "Pellezzano", "Castiglione del Genovesi", "Monte San Giacomo", "Sessa Cilento", "Colliano", "Valva", "Praiano", "Mercato San Severino", "Caggiano", "Battipaglia", "Campora", "San Valentino Torio", "Aquara", "Castellabate", "Lustra", "Moio della Civitella", "Torchiara", "Giffoni Valle Piana", "Sapri", "Capaccio Paestum", "Fisciano", "Stio", "Bellosguardo", "Novi Velia", "Sarno", "Roscigno", "San Marzano sul Sarno", "Roccadaspide", "Postiglione", "Castel San Lorenzo", "San Giovanni a Piro", "Castelnuovo di Conza", "Ispani", "Piaggine", "Controne", "Ottati", "Positano", "Campagna", "Cetara", "Corleto Monforte", "San Mauro la Bruca", "Sacco", "Caselle in Pittari", "Ricigliano", "Minori", "Acerno", "Siano", "Calvanico", "Ascea", "Contursi Terme", "Felitto", "Morigerati", "Salerno", "Orria", "Valle dell'Angelo", "San Rufo", "Corbara", "San Gregorio Magno", "Pisciotta", "Palomonte", "Teggiano", "Petina", "Rutino", "Olevano sul Tusciano", "Roccagloriosa", "Futani", "Vibonati", "Agropoli", "Bracigliano", "Perdifumo", "Angri", "Nocera Superiore", "Roccapiemonte", "Cicerale", "Atrani", "Pontecagnano Faiano", "Giffoni Sei Casali", "Laureana Cilento", "San Mauro Cilento", "San Pietro al Tanagro", "Albanella", "Pollica", "Sant'Arsenio", "Vietri sul Mare", "Oliveto Citra", "Sanza", "Sicignano degli Alburni", "Trentinara", "Buccino", "Conca dei Marini", "Stella Cilento", "Atena Lucana", "San Mango Piemonte", "Magliano Vetere", "Amalfi", "Centola", "Gioi", "Ogliastro Cilento", "Pertosa", "Serramezzana", "Eboli", "Torre Orsaia", "Pagani", "Santomenna", "Montecorice", "Padula", "Perito", "Cuccaro Vetere", "Ceraso", "Montecorvino Rovella", "Nocera Inferiore", "Laurito", "Maiori", "Vallo della Lucania", "Laviano", "Sant'Egidio del Monte Albino", "Montano Antilia", "Polla", "Alfano", "Sassano", "Montecorvino Pugliano", "Rofrano"] }, cv = { "L'Aquila": ["Castel di Ieri", "Collelongo", "Capistrello", "Scontrone", "Montereale", "Opi", "San Benedetto in Perillis", "Fontecchio", "Rivisondoli", "Fagnano Alto", "Castellafiume", "Carapelle Calvisio", "Introdacqua", "Cocullo", "Pereto", "Rocca di Cambio", "San Benedetto dei Marsi", "Pettorano sul Gizio", "Rocca di Botte", "Cappadocia", "Rocca di Mezzo", "Villavallelonga", "Caporciano", "Pescasseroli", "Anversa degli Abruzzi", "Bisegna", "Santo Stefano di Sessanio", "Rocca Pia", "Celano", "Scoppito", "Capestrano", "Roccaraso", "Ofena", "Villalago", "San Vincenzo Valle Roveto", "Gioia dei Marsi", "Avezzano", "Ocre", "Collepietro", "Trasacco", "Poggio Picenze", "Barrea", "Ortucchio", "Aielli", "Canistro", "Pacentro", "Villa Sant'Angelo", "Ovindoli", "Prata d'Ansidonia", "Villetta Barrea", "Villa Santa Lucia degli Abruzzi", "Raiano", "Castelvecchio Calvisio", "Bugnara", "Castelvecchio Subequo", "Lecce nei Marsi", "Scanno", "Sulmona", "Capitignano", "Pescocostanzo", "Sante Marie", "Alfedena", "Civitella Roveto", "Cerchio", "Carsoli", "Lucoli", "Balsorano", "Pizzoli", "Fossa", "Acciano", "Ateleta", "Barisciano", "Scurcola Marsicana", "Campo di Giove", "Gagliano Aterno", "L'Aquila", "Roccacasale", "Castel di Sangro", "Civita d'Antino", "Pratola Peligna", "Calascio", "Navelli", "Sant'Eusanio Forconese", "Vittorito", "Magliano de' Marsi", "Castel del Monte", "Molina Aterno", "Tornimparte", "San Demetrio ne' Vestini", "Tagliacozzo", "Barete", "Campotosto", "Tione degli Abruzzi", "Civitella Alfedena", "Pescina", "Collarmele", "San Pio delle Camere", "Prezza", "Massa d'Albe", "Morino", "Cansano", "Secinaro", "Corfinio", "Goriano Sicoli", "Luco dei Marsi", "Cagnano Amiterno", "Ortona dei Marsi", "Oricola"], Teramo: ["Tortoreto", "Giulianova", "Pietracamela", "Civitella del Tronto", "Teramo", "Torricella Sicura", "Rocca Santa Maria", "Campli", "Morro d'Oro", "Tossicia", "Arsita", "Ancarano", "Cortino", "Bisenti", "Atri", "Corropoli", "Sant'Omero", "Pineto", "Basciano", "Cellino Attanasio", "Alba Adriatica", "Mosciano Sant'Angelo", "Silvi", "Castellalto", "Crognaleto", "Montorio al Vomano", "Sant'Egidio alla Vibrata", "Notaresco", "Torano Nuovo", "Montefino", "Colonnella", "Castelli", "Controguerra", "Colledara", "Canzano", "Isola del Gran Sasso d'Italia", "Penna Sant'Andrea", "Martinsicuro", "Roseto degli Abruzzi", "Bellante", "Cermignano", "Castel Castagna", "Fano Adriano", "Valle Castellana", "Nereto", "Castiglione Messer Raimondo", "Castilenti"], Pescara: ["Carpineto della Nora", "Penne", "Salle", "Nocciano", "Pietranico", "Pescosansonesco", "Montebello di Bertona", "Turrivalignani", "Brittoli", "Citt Sant'Angelo", "Alanno", "Collecorvino", "Tocco da Casauria", "Torre de' Passeri", "Castiglione a Casauria", "Cepagatti", "Montesilvano", "Caramanico Terme", "Corvara", "Scafa", "Manoppello", "Roccamorice", "Loreto Aprutino", "Moscufo", "Spoltore", "Rosciano", "Bolognano", "San Valentino in Abruzzo Citeriore", "Popoli Terme", "Lettomanoppello", "Picciano", "Elice", "Villa Celiera", "Pescara", "Vicoli", "Serramonacesca", "Sant'Eufemia a Maiella", "Catignano", "Civitaquana", "Abbateggio", "Cappelle sul Tavo", "Pianella", "Farindola", "Bussi sul Tirino", "Civitella Casanova", "Cugnoli"], Chieti: ["Castel Frentano", "Paglieta", "Fara Filiorum Petri", "Casacanditella", "Poggiofiorito", "Villamagna", "San Martino sulla Marrucina", "Carunchio", "Torrebruna", "Roccamontepiano", "Tornareccio", "Atessa", "San Giovanni Lipioni", "Lentella", "San Salvo", "Crecchio", "Palena", "Fossacesia", "Chieti", "Furci", "Fallo", "Sant'Eusanio del Sangro", "Carpineto Sinello", "Roccaspinalveti", "Quadri", "Taranta Peligna", "Fara San Martino", "Cupello", "Casalincontrada", "Rapino", "Scerni", "Treglio", "Mozzagrogna", "Rocca San Giovanni", "Santa Maria Imbaro", "Miglianico", "Gissi", "Colledimezzo", "Monteferrante", "Montebello sul Sangro", "Fresagrandinaria", "Canosa Sannita", "Castelguidone", "Pietraferrazzana", "Torricella Peligna", "Schiavi di Abruzzo", "Pennadomo", "Lettopalena", "Filetto", "Ari", "Pretoro", "Gessopalena", "Civitaluparella", "Montazzoli", "San Buono", "Palombaro", "Civitella Messer Raimondo", "Colledimacine", "Vasto", "Frisa", "Pennapiedimonte", "Borrello", "Giuliano Teatino", "Lanciano", "Ortona", "Tufillo", "Gamberale", "Fraine", "Bucchianico", "Pollutri", "Torino di Sangro", "Montelapiano", "Montenerodomo", "Archi", "Roio del Sangro", "Celenza sul Trigno", "Ripa Teatina", "Monteodorisio", "Dogliola", "Villa Santa Maria", "Guilmi", "Palmoli", "Guardiagrele", "Casalanguida", "Perano", "Francavilla al Mare", "San Giovanni Teatino", "Lama dei Peligni", "Casalbordino", "Roccascalegna", "Casoli", "Vacri", "Villalfonsina", "Pizzoferrato", "Arielli", "Altino", "Liscia", "Rosello", "Torrevecchia Teatina", "Orsogna", "Castiglione Messer Marino", "San Vito Chietino", "Tollo", "Bomba"] }, dv = { Campobasso: ["Campolieto", "Campochiaro", "Castellino del Biferno", "Spinete", "Bonefro", "Campomarino", "Portocannone", "Toro", "Ripabottoni", "Morrone del Sannio", "Ferrazzano", "Oratino", "Roccavivara", "Guardiaregia", "Mirabello Sannitico", "Vinchiaturo", "Montenero di Bisaccia", "Montorio nei Frentani", "Guardialfiera", "Jelsi", "Cercepiccola", "Pietracatella", "Larino", "Campodipietra", "Pietracupa", "Riccia", "Baranello", "Tavenna", "Lucito", "Matrice", "Provvidenti", "Santa Croce di Magliano", "Campobasso", "Trivento", "Ururi", "Sant'Angelo Limosano", "Cercemaggiore", "San Giacomo degli Schiavoni", "Montefalcone nel Sannio", "Gildone", "Busso", "San Polo Matese", "Montemitro", "Tufara", "Fossalto", "Montelongo", "Palata", "Termoli", "Sepino", "Lupara", "Casacalenda", "San Giuliano di Puglia", "Petrella Tifernina", "Colletorto", "Sant'Elia a Pianisi", "San Martino in Pensilis", "Rotello", "Molise", "Mafalda", "Castropignano", "Ripalimosani", "Macchia Valfortore", "Casalciprano", "Gambatesa", "San Biase", "San Giovanni in Galdo", "Castelmauro", "Petacciato", "Colle d'Anchise", "Limosano", "Civitacampomarano", "Salcito", "Monacilioni", "Bojano", "Montagano", "Torella del Sannio", "Montecilfone", "Guglionesi", "Acquaviva Collecroce", "San Felice del Molise", "San Giuliano del Sannio", "Castelbottaccio", "Duronia", "San Massimo"], Isernia: ["Bagnoli del Trigno", "Carovilli", "Castelpizzuto", "Conca Casale", "Civitanova del Sannio", "Castel San Vincenzo", "Sesto Campano", "Belmonte del Sannio", "Sessano del Molise", "Longano", "Scapoli", "Castel del Giudice", "Isernia", "Acquaviva d'Isernia", "Agnone", "Montaquila", "Carpinone", "Chiauci", "Sant'Agapito", "Miranda", "Pozzilli", "Rionero Sannitico", "Pescopennataro", "Pettoranello del Molise", "Macchiagodena", "Monteroduni", "Pietrabbondante", "Sant'Angelo del Pesco", "Cantalupo nel Sannio", "Colli a Volturno", "Fornelli", "Rocchetta a Volturno", "Pescolanciano", "Sant'Elena Sannita", "Macchia d'Isernia", "Pesche", "Castelverrino", "Frosolone", "Forl del Sannio", "Montenero Val Cocchiara", "San Pietro Avellana", "Vastogirardi", "Roccamandolfi", "Venafro", "Santa Maria del Molise", "Castelpetroso", "Pizzone", "Roccasicura", "Capracotta", "Poggio Sannita", "Filignano", "Cerro al Volturno"] }, hv = { Foggia: ["San Nicandro Garganico", "Carapelle", "Ordona", "Ascoli Satriano", "Peschici", "Chieuti", "Castelnuovo della Daunia", "San Severo", "Poggio Imperiale", "Castelluccio dei Sauri", "Castelluccio Valmaggiore", "Cerignola", "Anzano di Puglia", "Ischitella", "Zapponeta", "Sant'Agata di Puglia", "San Marco la Catola", "Troia", "Lucera", "Cagnano Varano", "Serracapriola", "San Giovanni Rotondo", "Volturara Appula", "Bovino", "Orsara di Puglia", "Torremaggiore", "Biccari", "Carlantino", "Celenza Valfortore", "Vico del Gargano", "Orta Nova", "Lesina", "Pietramontecorvino", "Apricena", "San Marco in Lamis", "Volturino", "Candela", "Carpino", "Casalnuovo Monterotaro", "Isole Tremiti", "Faeto", "Rodi Garganico", "Rignano Garganico", "Monte Sant'Angelo", "Mattinata", "Celle di San Vito", "Motta Montecorvino", "Panni", "Casalvecchio di Puglia", "Vieste", "Stornarella", "Monteleone di Puglia", "Accadia", "Alberona", "Roseto Valfortore", "San Paolo di Civitate", "Manfredonia", "Deliceto", "Rocchetta Sant'Antonio", "Foggia", "Stornara"], Bari: ["Altamura", "Palo del Colle", "Poggiorsini", "Acquaviva delle Fonti", "Modugno", "Molfetta", "Terlizzi", "Polignano a Mare", "Bitritto", "Putignano", "Triggiano", "Sammichele di Bari", "Castellana Grotte", "Cassano delle Murge", "Noicattaro", "Rutigliano", "Conversano", "Gioia del Colle", "Adelfia", "Capurso", "Cellamare", "Ruvo di Puglia", "Gravina in Puglia", "Valenzano", "Locorotondo", "Corato", "Bitetto", "Binetto", "Sannicandro di Bari", "Mola di Bari", "Toritto", "Giovinazzo", "Alberobello", "Bitonto", "Monopoli", "Grumo Appula", "Noci", "Turi", "Bari", "Casamassima", "Santeramo in Colle"], Taranto: ["Martina Franca", "Fragagnano", "Castellaneta", "Sava", "Crispiano", "San Giorgio Ionico", "Pulsano", "Mottola", "Montemesola", "San Marzano di San Giuseppe", "Avetrana", "Lizzano", "Palagianello", "Taranto", "Manduria", "Massafra", "Monteiasi", "Laterza", "Carosino", "Statte", "Monteparano", "Torricella", "Grottaglie", "Roccaforzata", "Faggiano", "Maruggio", "Ginosa", "Leporano", "Palagiano"], Brindisi: ["Mesagne", "Ostuni", "Torre Santa Susanna", "Cisternino", "San Vito dei Normanni", "Erchie", "Francavilla Fontana", "Cellino San Marco", "San Donaci", "San Pietro Vernotico", "Carovigno", "Fasano", "Torchiarolo", "Ceglie Messapica", "Oria", "Brindisi", "San Michele Salentino", "San Pancrazio Salentino", "Villa Castelli", "Latiano"], Lecce: ["Castri di Lecce", "Santa Cesarea Terme", "Castro", "Melpignano", "San Pietro in Lama", "Secl", "Copertino", "Soleto", "Diso", "Alessano", "Spongano", "Guagnano", "Surano", "Squinzano", "Sternatia", "Arnesano", "Presicce-Acquarica", "Neviano", "Castrignano del Capo", "Casarano", "Leverano", "Ortelle", "Novoli", "Taviano", "Galatina", "Surbo", "Alliste", "Andrano", "Martignano", "Maglie", "Giuggianello", "Veglie", "Ruffano", "Corigliano d'Otranto", "Miggiano", "Carpignano Salentino", "Botrugno", "Minervino di Lecce", "Sogliano Cavour", "Tuglie", "Taurisano", "Monteroni di Lecce", "Lequile", "Salve", "Racale", "Tricase", "Martano", "Castrignano de' Greci", "Ugento", "Matino", "Carmiano", "Vernole", "Cutrofiano", "Salice Salentino", "Scorrano", "San Cassiano", "Cursi", "Bagnolo del Salento", "Specchia", "Nard", "Morciano di Leuca", "Porto Cesareo", "Pat", "Trepuzzi", "Montesano Salentino", "San Cesario di Lecce", "Corsano", "Caprarica di Lecce", "Lizzanello", "Parabita", "Sannicola", "Aradeo", "Otranto", "Collepasso", "Campi Salentina", "Calimera", "Tiggiano", "Galatone", "Giurdignano", "Poggiardo", "Muro Leccese", "Supersano", "Cavallino", "Lecce", "Sanarica", "Zollino", "Melendugno", "Alezio", "San Donato di Lecce", "Gallipoli", "Cannole", "Uggiano la Chiesa", "Gagliano del Capo", "Palmariggi", "Melissano", "Nociglia"], "Barletta-Andria-Trani": ["Canosa di Puglia", "Trani", "Andria", "Spinazzola", "Trinitapoli", "Barletta", "Margherita di Savoia", "Minervino Murge", "San Ferdinando di Puglia", "Bisceglie"] }, fv = { Potenza: ["San Severino Lucano", "Ruvo del Monte", "Lagonegro", "Calvera", "Carbone", "Satriano di Lucania", "Montemilone", "Rivello", "Moliterno", "Balvano", "Fardella", "Francavilla in Sinni", "Castelmezzano", "Tolve", "Chiaromonte", "Cersosimo", "Tramutola", "Corleto Perticara", "Lavello", "Brienza", "Venosa", "Banzi", "Calvello", "Savoia di Lucania", "Teana", "Pietrapertosa", "Montemurro", "Castelluccio Inferiore", "Avigliano", "Castelluccio Superiore", "Ruoti", "Genzano di Lucania", "San Martino d'Agri", "Potenza", "Episcopia", "Castelgrande", "Vaglio Basilicata", "Viggianello", "Anzi", "Maschito", "Baragiano", "Castelsaraceno", "Rotonda", "Sasso di Castalda", "Albano di Lucania", "Viggiano", "San Paolo Albanese", "Nemoli", "Rapolla", "Paterno", "San Costantino Albanese", "Pietragalla", "Melfi", "Sant'Angelo Le Fratte", "Castronuovo di Sant'Andrea", "Acerenza", "Campomaggiore", "Vietri di Potenza", "Trecchina", "Picerno", "Rapone", "Armento", "Gallicchio", "Pescopagano", "San Chirico Raparo", "Roccanova", "Maratea", "Missanello", "San Chirico Nuovo", "Spinoso", "Ripacandida", "Sarconi", "Tito", "Rionero in Vulture", "Bella", "Latronico", "Palazzo San Gervasio", "Noepoli", "Trivigno", "Barile", "Ginestra", "Sant'Arcangelo", "Atella", "Filiano", "Muro Lucano", "Marsico Nuovo", "Oppido Lucano", "San Fele", "Guardia Perticara", "Brindisi Montagna", "Lauria", "Cancellara", "Forenza", "Laurenzana", "Grumento Nova", "Abriola", "Terranova di Pollino", "Pignola", "Senise", "Marsicovetere"], Matera: ["Calciano", "Montescaglioso", "Montalbano Jonico", "Colobraro", "Pisticci", "Oliveto Lucano", "Accettura", "Garaguso", "Matera", "Grottole", "Irsina", "Tricarico", "San Giorgio Lucano", "Craco", "Pomarico", "Gorgoglione", "San Mauro Forte", "Nova Siri", "Miglionico", "Bernalda", "Ferrandina", "Salandra", "Tursi", "Cirigliano", "Policoro", "Valsinni", "Stigliano", "Aliano", "Rotondella", "Grassano", "Scanzano Jonico"] }, gv = { Cosenza: ["Fuscaldo", "Amendolara", "Santa Domenica Talao", "Nocara", "Acri", "Mormanno", "Bisignano", "Carolei", "Altilia", "Firmo", "San Fili", "Rota Greca", "Santa Maria del Cedro", "Lago", "Castrolibero", "Aieta", "Plataci", "Cetraro", "San Giorgio Albanese", "Lattarico", "Mendicino", "Pietrapaola", "Marano Principato", "Panettieri", "Bonifati", "Bocchigliero", "Rocca Imperiale", "Santo Stefano di Rogliano", "Roseto Capo Spulico", "Calopezzati", "Casali del Manco", "Paola", "Grimaldi", "Rende", "Cellara", "Campana", "Parenti", "Paterno Calabro", "Sangineto", "Cerisano", "Santa Caterina Albanese", "Falconara Albanese", "Lappano", "Caloveto", "Malvito", "Frascineto", "Oriolo", "San Lorenzo Bellizzi", "Belvedere Marittimo", "Scalea", "Amantea", "Paludi", "Villapiana", "Scigliano", "San Marco Argentano", "San Sosti", "Longobucco", "Carpanzano", "Pietrafitta", "Cropalati", "Alessandria del Carretto", "Zumpano", "San Cosmo Albanese", "Castiglione Cosentino", "San Donato di Ninea", "Civita", "Cerchiara di Calabria", "Altomonte", "Mandatoriccio", "Canna", "Vaccarizzo Albanese", "Fiumefreddo Bruzio", "Fagnano Castello", "Sant'Agata di Esaro", "Terravecchia", "Tortora", "Mangone", "Marzi", "San Pietro in Amantea", "San Vincenzo La Costa", "Verbicaro", "Trebisacce", "Celico", "Praia a Mare", "Belmonte Calabro", "Malito", "Castroregio", "Cervicati", "Torano Castello", "Grisolia", "Morano Calabro", "Bianchi", "Scala Coeli", "Montegiordano", "Aiello Calabro", "Albidona", "Domanico", "San Basile", "Rovito", "Luzzi", "Guardia Piemontese", "San Demetrio Corone", "Aprigliano", "Cassano all'Ionio", "Acquappesa", "Buonvicino", "San Benedetto Ullano", "Crosia", "San Nicola Arcella", "San Martino di Finita", "Roggiano Gravina", "Laino Borgo", "Cosenza", "Serra d'Aiello", "Figline Vegliaturo", "Pedivigliano", "Francavilla Marittima", "San Lucido", "Maier", "Longobardi", "Cleto", "Castrovillari", "Lungro", "San Pietro in Guarano", "Terranova da Sibari", "Montalto Uffugo", "Santa Sofia d'Epiro", "Diamante", "Orsomarso", "Marano Marchesato", "Cerzeto", "Laino Castello", "Corigliano-Rossano", "Cariati", "Mongrassano", "Piane Crati", "Spezzano Albanese", "Rose", "Mottafollone", "Dipignano", "Tarsia", "Saracena", "Belsito", "Papasidero", "Spezzano della Sila", "San Giovanni in Fiore", "Rogliano", "Acquaformosa", "Colosimi", "San Lorenzo del Vallo"], Catanzaro: ["Settingiano", "Pianopoli", "Stalett", "Tiriolo", "Cenadi", "Marcellinara", "Amato", "Curinga", "San Pietro a Maida", "Badolato", "Girifalco", "Fossato Serralta", "Miglierina", "Belcastro", "Falerna", "Petron", "Gagliato", "Carlopoli", "Marcedusa", "Martirano Lombardo", "Platania", "Gizzeria", "Soverato", "Cardinale", "Davoli", "Gasperina", "Cicala", "Soveria Mannelli", "Santa Caterina dello Ionio", "Motta Santa Lucia", "Feroleto Antico", "Petrizzi", "Cortale", "Montauro", "Argusto", "Centrache", "Chiaravalle Centrale", "Taverna", "Montepaone", "Caraffa di Catanzaro", "Amaroni", "Catanzaro", "Soveria Simeri", "Sersale", "Magisano", "Sant'Andrea Apostolo dello Ionio", "San Vito sullo Ionio", "San Mango d'Aquino", "Satriano", "Albi", "Jacurso", "Simeri Crichi", "Conflenti", "Botricello", "Sellia Marina", "Cerva", "Borgia", "San Pietro Apostolo", "Nocera Terinese", "Palermiti", "Maida", "Vallefiorita", "Pentone", "Lamezia Terme", "Isca sullo Ionio", "Torre di Ruggiero", "Cropani", "Decollatura", "Gimigliano", "Martirano", "San Sostene", "Olivadi", "Squillace", "San Floro", "Sorbo San Basile", "Serrastretta", "Andali", "Guardavalle", "Zagarise", "Sellia"], "Reggio Calabria": ["Campo Calabro", "Candidoni", "San Giorgio Morgeto", "Placanica", "Sant'Alessio in Aspromonte", "Laureana di Borrello", "Caulonia", "Ardore", "Grotteria", "Palizzi", "Condofuri", "Pazzano", "Marina di Gioiosa Ionica", "Motta San Giovanni", "Sant'Agata del Bianco", "Gioiosa Ionica", "Varapodio", "Riace", "Sant'Eufemia d'Aspromonte", "Locri", "Laganadi", "San Giovanni di Gerace", "Caraffa del Bianco", "Canolo", "Roccaforte del Greco", "Mammola", "Bianco", "Ferruzzano", "Martone", "Scido", "Cinquefrondi", "Terranova Sappo Minulio", "Bivongi", "Santa Cristina d'Aspromonte", "Seminara", "Sinopoli", "Cosoleto", "Giffone", "Rosarno", "Molochio", "Gioia Tauro", "Maropati", "Monasterace", "Benestare", "Africo", "Samo", "Melicucc", "Bova", "Cardeto", "San Procopio", "Stignano", "Bagnara Calabra", "Cittanova", "San Lorenzo", "Brancaleone", "Roghudi", "Roccella Ionica", "Polistena", "Oppido Mamertina", "Galatro", "Siderno", "Scilla", "San Luca", "San Roberto", "San Pietro di Carid", "Careri", "Sant'Ilario dello Ionio", "Rizziconi", "Camini", "Melicucco", "Portigliola", "Bovalino", "Delianuova", "Cimin", "Gerace", "Santo Stefano in Aspromonte", "Staiti", "Taurianova", "Fiumara", "Plat", "Palmi", "Antonimina", "Bagaladi", "Bova Marina", "Montebello Jonico", "Calanna", "Bruzzano Zeffirio", "Melito di Porto Salvo", "Serrata", "Agnana Calabra", "San Ferdinando", "Stilo", "Feroleto della Chiesa", "Reggio di Calabria", "Casignana", "Anoia", "Villa San Giovanni"], Crotone: ["Roccabernarda", "Verzino", "Scandale", "Cir", "Isola di Capo Rizzuto", "Savelli", "Castelsilano", "Strongoli", "Rocca di Neto", "Cir Marina", "Cutro", "San Nicola dell'Alto", "Cerenzia", "Carfizzi", "Belvedere di Spinello", "San Mauro Marchesato", "Crucoli", "Umbriatico", "Mesoraca", "Santa Severina", "Crotone", "Pallagorio", "Petilia Policastro", "Casabona", "Caccuri", "Melissa", "Cotronei"], "Vibo Valentia": ["Filandari", "Pizzo", "Ricadi", "Joppolo", "Vallelonga", "Nardodipace", "Rombiolo", "Brognaturo", "Spadola", "Maierato", "Simbario", "Fabrizia", "Sorianello", "Zungri", "Jonadi", "Soriano Calabro", "Spilinga", "Tropea", "San Calogero", "Vazzano", "Drapia", "Gerocarne", "Briatico", "Cessaniti", "Zaccanopoli", "Limbadi", "Das", "Parghelia", "Mileto", "Francica", "Dinami", "Capistrano", "Arena", "Sant'Onofrio", "Pizzoni", "Nicotera", "Polia", "Francavilla Angitola", "Acquaro", "Vibo Valentia", "Stefanaconi", "Zambrone", "San Gregorio d'Ippona", "San Costantino Calabro", "Filadelfia", "Monterosso Calabro", "Serra San Bruno", "San Nicola da Crissa", "Mongiana", "Filogaso"] }, mv = { Trapani: ["Alcamo", "Buseto Palizzolo", "Paceco", "Salaparuta", "Castelvetrano", "Santa Ninfa", "Custonaci", "Poggioreale", "San Vito Lo Capo", "Petrosino", "Trapani", "Vita", "Salemi", "Mazara del Vallo", "Pantelleria", "Castellammare del Golfo", "Marsala", "Favignana", "Misiliscemi", "Campobello di Mazara", "Erice", "Valderice", "Gibellina", "Partanna", "Calatafimi-Segesta"], Palermo: ["Montemaggiore Belsito", "Lercara Friddi", "Carini", "San Giuseppe Jato", "Termini Imerese", "Campofelice di Roccella", "Vicari", "Palazzo Adriano", "Caltavuturo", "Alia", "Bompietro", "Prizzi", "Isnello", "Campofiorito", "Chiusa Sclafani", "Gratteri", "Balestrate", "Campofelice di Fitalia", "Altavilla Milicia", "Belmonte Mezzagno", "Borgetto", "Pollina", "Santa Flavia", "Alimena", "Cefal Diana", "Palermo", "Torretta", "Casteldaccia", "Sciara", "Roccapalumba", "Villabate", "Baucina", "San Mauro Castelverde", "Trabia", "Partinico", "Cinisi", "San Cipirello", "Santa Cristina Gela", "Ficarazzi", "Caccamo", "Castronovo di Sicilia", "Cerda", "Valledolmo", "Camporeale", "Bisacquino", "Cefal", "Capaci", "Corleone", "Villafrati", "Castellana Sicula", "Roccamena", "Terrasini", "Isola delle Femmine", "Misilmeri", "Giuliana", "Bolognetta", "Piana degli Albanesi", "Gangi", "Trappeto", "Sclafani Bagni", "Bagheria", "Petralia Sottana", "Godrano", "Geraci Siculo", "Castelbuono", "Ciminna", "Polizzi Generosa", "Blufi", "Lascari", "Giardinello", "Ustica", "Ventimiglia di Sicilia", "Collesano", "Mezzojuso", "Contessa Entellina", "Marineo", "Scillato", "Petralia Soprana", "Monreale", "Montelepre", "Altofonte", "Aliminusa"], Messina: ["Floresta", "Al", "Santa Domenica Vittoria", "San Salvatore di Fitalia", "Torrenova", "Valdina", "Tusa", "Messina", "Castel di Lucio", "Malvagna", "Barcellona Pozzo di Gotto", "Caronia", "Itala", "San Marco d'Alunzio", "Motta Camastra", "Saponara", "Pagliara", "Gaggi", "Piraino", "San Filippo del Mela", "Rod Milici", "Mazzarr Sant'Andrea", "Rometta", "Scaletta Zanclea", "Santa Teresa di Riva", "Roccafiorita", "Sant'Alessio Siculo", "Naso", "Capizzi", "Militello Rosmarino", "Villafranca Tirrena", "Roccella Valdemone", "Sant'Angelo di Brolo", "Venetico", "Torregrotta", "Casalvecchio Siculo", "Mer", "Furci Siculo", "Gallodoro", "Capri Leone", "Montagnareale", "Francavilla di Sicilia", "Mistretta", "Furnari", "Santa Marina Salina", "Falcone", "Patti", "Librizzi", "Tortorici", "Montalbano Elicona", "Roccavaldina", "Antillo", "Castell'Umberto", "Ficarra", "Novara di Sicilia", "San Piero Patti", "Raccuja", "Motta d'Affermo", "Mandanici", "Nizza di Sicilia", "Ucria", "Savoca", "Condr", "Capo d'Orlando", "San Fratello", "Forza d'Agr", "Gualtieri Sicamin", "Oliveri", "Spadafora", "San Pier Niceto", "Sinagra", "Gioiosa Marea", "Fiumedinisi", "Alcara li Fusi", "Taormina", "Monforte San Giorgio", "Giardini-Naxos", "Leni", "Basic", "Sant'Agata di Militello", "Terme Vigliatore", "Castroreale", "Santo Stefano di Camastra", "Graniti", "Lipari", "Milazzo", "San Teodoro", "Acquedolci", "Santa Lucia del Mela", "Galati Mamertino", "Reitano", "Frazzan", "Al Terme", "Tripi", "Roccalumera", "Moio Alcantara", "Cesar", "Limina", "Castelmola", "Longi", "Malfa", "Fondachelli-Fantina", "Letojanni", "Mongiuffi Melia", "Pace del Mela", "Brolo", "Mirto", "Pettineo"], Agrigento: ["Licata", "Ribera", "Alessandria della Rocca", "Santa Elisabetta", "Grotte", "Montallegro", "Menfi", "Montevago", "Calamonaci", "San Biagio Platani", "Castrofilippo", "Santa Margherita di Belice", "Ravanusa", "Cianciana", "Lucca Sicula", "Sant'Angelo Muxaro", "Realmonte", "Porto Empedocle", "Lampedusa e Linosa", "Villafranca Sicula", "Canicatt", "Naro", "San Giovanni Gemini", "Santo Stefano Quisquina", "Cammarata", "Comitini", "Raffadali", "Burgio", "Agrigento", "Sciacca", "Siculiana", "Bivona", "Joppolo Giancaxio", "Racalmuto", "Camastra", "Sambuca di Sicilia", "Campobello di Licata", "Caltabellotta", "Casteltermini", "Aragona", "Cattolica Eraclea", "Favara", "Palma di Montechiaro"], Caltanissetta: ["Sommatino", "Delia", "San Cataldo", "Marianopoli", "Mazzarino", "Acquaviva Platani", "Gela", "Mussomeli", "Butera", "Villalba", "Vallelunga Pratameno", "Bompensiere", "Resuttano", "Serradifalco", "Caltanissetta", "Campofranco", "Niscemi", "Montedoro", "Milena", "Sutera", "Santa Caterina Villarmosa", "Riesi"], Enna: ["Aidone", "Valguarnera Caropepe", "Agira", "Pietraperzia", "Gagliano Castelferrato", "Leonforte", "Catenanuova", "Villarosa", "Regalbuto", "Barrafranca", "Centuripe", "Troina", "Enna", "Sperlinga", "Cerami", "Assoro", "Nicosia", "Piazza Armerina", "Nissoria", "Calascibetta"], Catania: ["Aci Sant'Antonio", "Tremestieri Etneo", "Fiumefreddo di Sicilia", "Castiglione di Sicilia", "Gravina di Catania", "Bronte", "Camporotondo Etneo", "San Pietro Clarenza", "Scordia", "Mineo", "Caltagirone", "Giarre", "Mazzarrone", "Palagonia", "Santa Maria di Licodia", "Raddusa", "Riposto", "Milo", "Viagrande", "Licodia Eubea", "Calatabiano", "Nicolosi", "Grammichele", "Mascali", "Belpasso", "Castel di Iudica", "Aci Catena", "Catania", "Biancavilla", "Ragalna", "Piedimonte Etneo", "Trecastagni", "Sant'Agata li Battiati", "San Gregorio di Catania", "San Cono", "Aci Bonaccorsi", "Pedara", "Randazzo", "Patern", "San Michele di Ganzaria", "Motta Sant'Anastasia", "Zafferana Etnea", "Vizzini", "Acireale", "San Giovanni la Punta", "Linguaglossa", "Misterbianco", "Ramacca", "Valverde", "Sant'Alfio", "Santa Venerina", "Mascalucia", "Militello in Val di Catania", "Aci Castello", "Maletto", "Maniace", "Mirabella Imbaccari", "Adrano"], Ragusa: ["Modica", "Ispica", "Acate", "Ragusa", "Comiso", "Vittoria", "Giarratana", "Chiaramonte Gulfi", "Monterosso Almo", "Pozzallo", "Santa Croce Camerina", "Scicli"], Siracusa: ["Augusta", "Floridia", "Melilli", "Buccheri", "Siracusa", "Cassaro", "Canicattini Bagni", "Rosolini", "Lentini", "Buscemi", "Carlentini", "Sortino", "Ferla", "Palazzolo Acreide", "Avola", "Francofonte", "Priolo Gargallo", "Portopalo di Capo Passero", "Solarino", "Pachino", "Noto"] }, vv = { Sassari: ["Bonorva", "Bultei", "Mara", "Ozieri", "Illorai", "Chiaramonti", "Ploaghe", "Torralba", "Putifigari", "Stintino", "Codrongianos", "Sorso", "Padria", "Palau", "Nule", "Luras", "Muros", "Anela", "Bottidda", "Uri", "Ittiri", "Borutta", "Mores", "Pozzomaggiore", "Nulvi", "Al dei Sardi", "Banari", "Usini", "Laerru", "Bonnanaro", "Villanova Monteleone", "Budoni", "Tula", "Florinas", "Bulzi", "Romana", "Ossi", "Tergu", "Cargeghe", "Badesi", "Benetutti", "Tissi", "Aggius", "Luogosanto", "Sassari", "Esporlatu", "Cossoine", "Padru", "Thiesi", "Semestene", "Monteleone Rocca Doria", "Bortigiadas", "La Maddalena", "Arzachena", "Santa Teresa Gallura", "Martis", "Pattada", "Loiri Porto San Paolo", "Erula", "Burgos", "Bono", "Osilo", "Tempio Pausania", "Santa Maria Coghinas", "Aglientu", "Castelsardo", "Cheremule", "Telti", "Siligo", "Nughedu San Nicol", "Giave", "Viddalba", "Trinit d'Agultu e Vignola", "San Teodoro", "Sedini", "Valledoria", "Olbia", "Porto Torres", "Alghero", "Bessude", "Calangianus", "Ittireddu", "Berchidda", "Golfo Aranci", "Sant'Antonio di Gallura", "Buddus", "Ardara", "Sennori", "Monti", "Olmedo", "Oschiri", "Perfugas"], Nuoro: ["Dualchi", "Meana Sardo", "Loculi", "Tiana", "Atzara", "Lodine", "Loceri", "Orune", "Orotelli", "Bitti", "Girasole", "Macomer", "Oniferi", "Lotzorai", "Gadoni", "Ovodda", "Tortol", "Lula", "Galtell", "Olzai", "Bortigali", "Onifai", "Lei", "Aritzo", "Desulo", "Perdasdefogu", "Baunei", "Gavoi", "Lanusei", "Belv", "Triei", "Jerzu", "Posada", "Birori", "Lod", "Teti", "Orani", "Silanus", "Ollolai", "Orgosolo", "Sindia", "Talana", "Noragugume", "Irgoli", "Austis", "Borore", "Gairo", "Nuoro", "Dorgali", "Cardedu", "Tonara", "Ilbono", "Sarule", "Urzulei", "Tertenia", "Osini", "Ussassai", "Mamoiada", "Orosei", "Sorgono", "Torp", "Villagrande Strisaili", "Elini", "Ulassai", "Ottana", "Oliena", "Bari Sardo", "Arzana", "Onan", "Siniscola", "Ortueri", "Osidda", "Fonni", "Bolotana"], Cagliari: ["Capoterra", "Sestu", "Maracalagonis", "Villa San Pietro", "Quartucciu", "Settimo San Pietro", "Decimomannu", "Selargius", "Elmas", "Assemini", "Sinnai", "Uta", "Monserrato", "Cagliari", "Quartu Sant'Elena", "Sarroch", "Pula"], Oristano: ["Sedilo", "Morgongiori", "Marrubiu", "Simaxis", "Palmas Arborea", "Simala", "Uras", "Sennariolo", "Pompu", "Tinnura", "Abbasanta", "Albagiara", "Sodd", "Siris", "Milis", "Siamaggiore", "Tramatza", "Senis", "Cabras", "Gonnostramatza", "Bosa", "Seneghe", "Assolo", "Bauladu", "Sorradile", "Ghilarza", "Nughedu Santa Vittoria", "Boroneddu", "Asuni", "Santu Lussurgiu", "Flussio", "Mogoro", "Ul Tirso", "Ardauli", "San Nicol d'Arcidano", "Montresta", "Ruinas", "Narbolia", "Zeddiani", "Tadasuni", "Ales", "Scano di Montiferro", "Laconi", "San Vero Milis", "Neoneli", "Norbello", "Ollastra", "Gonnoscodina", "Fordongianus", "Magomadas", "Nureci", "Terralba", "Paulilatino", "Solarussa", "Oristano", "Nurachi", "Suni", "Zerfaliu", "Baratili San Pietro", "Bonarcado", "Allai", "Usellus", "Masullas", "Villa Sant'Antonio", "Baradili", "Busachi", "Curcuris", "Villanova Truschedu", "Sini", "Villaurbana", "Baressa", "Mogorella", "Tresnuraghes", "Bidon", "Aidomaggiore", "Gonnosn", "Siapiccia", "Modolo", "Pau", "Riola Sardo", "Arborea", "Cuglieri", "Villa Verde", "Samugheo", "Santa Giusta", "Siamanna", "Sagama"], "Sud Sardegna": ["Ussaramanna", "Escolca", "Donori", "Isili", "Arbus", "Giba", "Segariu", "Guamaggiore", "Carloforte", "Perdaxius", "San Sperate", "Masainas", "Nurri", "Muravera", "Iglesias", "Villaspeciosa", "Burcei", "Pauli Arbarei", "Nuraminis", "San Basilio", "Genuri", "Villanova Tulo", "Nuragus", "Serrenti", "Vallermosa", "Senorb", "Barumini", "Monastir", "Santadi", "Domus de Maria", "Tratalias", "Nurallao", "Ballao", "Siddi", "Siurgus Donigala", "Sant'Andrea Frius", "Guspini", "Guasila", "Fluminimaggiore", "San Vito", "Silius", "Soleminis", "Villamassargia", "Escalaplano", "Samatzai", "Gonnesa", "San Nicol Gerrei", "Selegas", "Gergei", "Villaperuccio", "Sardara", "Villamar", "Turri", "Las Plassas", "Teulada", "Nuxis", "Gesturi", "Villacidro", "Setzu", "Domusnovas", "Seui", "Portoscuso", "Sanluri", "Genoni", "Goni", "Villanovaforru", "Musei", "Ortacesus", "Seulo", "Tuili", "Serri", "Serdiana", "Piscinas", "Gonnosfanadiga", "Siliqua", "Villasalto", "Calasetta", "Barrali", "Decimoputzu", "Sant'Anna Arresi", "Collinas", "Narcao", "Serramanna", "Esterzili", "Sant'Antioco", "Mandas", "Buggerru", "Villanovafranca", "Villasor", "Carbonia", "Gesico", "Villasimius", "Sadali", "Samassi", "Pabillonis", "Ussana", "San Gavino Monreale", "Castiadas", "San Giovanni Suergiu", "Furtei", "Lunamatrona", "Villaputzu", "Dolianova", "Armungia", "Orroli", "Suelli", "Pimentel"] }, xn = {
  Piemonte: tv,
  "Valle d'Aosta": { Aosta: ["Pollein", "Bard", "Saint-Nicolas", "Cogne", "Gignod", "Saint-Christophe", "Challand-Saint-Victor", "Saint-Rhmy-en-Bosses", "Valgrisenche", "Sarre", "Valsavarenche", "Gressan", "Allein", "Torgnon", "Nus", "Bionaz", "Pont-Saint-Martin", "Introd", "Villeneuve", "Valtournenche", "Saint-Denis", "Pontey", "Arvier", "Jovenan", "Fontainemore", "La Salle", "Emarse", "Saint-Pierre", "Aosta", "Montjovet", "Pontboset", "Brissogne", "Verrs", "Chamois", "Donnas", "Champdepraz", "Gressoney-La-Trinit", "Rhmes-Saint-Georges", "Gaby", "Saint-Vincent", "Champorcher", "Chtillon", "Avise", "Charvensod", "Fnis", "La Magdeleine", "Saint-Marcel", "Aymavilles", "Ollomont", "Gressoney-Saint-Jean", "Chambave", "Brusson", "Doues", "Rhmes-Notre-Dame", "Challand-Saint-Anselme", "La Thuile", "Morgex", "Issogne", "Antey-Saint-Andr", "Perloz", "Ayas", "Roisan", "Valpelline", "Pr-Saint-Didier", "Quart", "Lillianes", "Oyace", "Verrayes", "Saint-Oyen", "Courmayeur", "Etroubles", "Arnad", "Hne", "Issime"] },
  Liguria: nv,
  Lombardia: iv,
  "Trentino-Alto Adige": { Bolzano: ["San Genesio Atesino", "Scena", "Varna", "Bronzolo", "Castelrotto", "Martello", "Proves", "Campo di Trens", "Prato allo Stelvio", "Racines", "Terlano", "Brunico", "Cortaccia sulla strada del vino", "Parcines", "Perca", "Cermes", "Ponte Gardena", "Montagna sulla Strada del Vino", "Senales", "Bressanone", "Nova Ponente", "Chienes", "Merano", "Trodena nel parco naturale", "Nova Levante", "Gais", "Caldaro sulla strada del vino", "Naz-Sciaves", "Marebbe", "Selva dei Molini", "Sluderno", "Ora", "Laion", "Aldino", "San Lorenzo di Sebato", "Magr sulla strada del vino", "Meltina", "Salorno sulla strada del vino", "Plaus", "La Valle", "Villabassa", "Avelengo", "Senale-San Felice", "Malles Venosta", "Postal", "Bolzano", "Braies", "Marlengo", "Rasun-Anterselva", "Lana", "Vandoies", "San Pancrazio", "Silandro", "Sesto", "Villandro", "San Martino in Passiria", "Rio di Pusteria", "Egna", "Tubre", "Lauregno", "Chiusa", "Vipiteno", "Nalles", "Lagundo", "Tirolo", "Funes", "Badia", "San Candido", "Valle Aurina", "Tires", "San Martino in Badia", "Sarentino", "Cornedo all'Isarco", "Laces", "Anterivo", "Gargazzone", "Renon", "Selva di Val Gardena", "San Leonardo in Passiria", "Cortina sulla strada del vino", "Terento", "Brennero", "Corvara in Badia", "Ultimo", "Fi allo Sciliar", "Lasa", "Caines", "Velturno", "Luson", "Vadena", "Glorenza", "Stelvio", "Laives", "Valdaora", "Santa Cristina Valgardena", "Monguelfo-Tesido", "Barbiano", "Falzes", "Rifiano", "Termeno sulla strada del vino", "Ortisei", "Fortezza", "Curon Venosta", "Dobbiaco", "Val di Vizze", "Predoi", "Castelbello-Ciardes", "Moso in Passiria", "Campo Tures", "Rodengo", "Tesimo", "Verano", "Naturno", "Valle di Casies", "Andriano", "Appiano sulla strada del vino"], Trento: ["Sover", "Sporminore", "Tesero", "Ruffr-Mendola", "Lavarone", "Ville di Fiemme", "Albiano", "San Lorenzo Dorsino", "Cavizzana", "Terre d'Adige", "Peio", "Pieve Tesino", "Pellizzano", "Stenico", "Canal San Bovo", "Cavedine", "Croviana", "San Giovanni di Fassa", "Livo", "Trento", "Sella Giudicarie", "Valfloriana", "Volano", "Cles", "Avio", "Rover della Luna", "Carzano", "Mezzolombardo", "Borgo Chiese", "Cavalese", "Caderzone Terme", "Mori", "Pieve di Bono-Prezzo", "Tione di Trento", "Campodenno", "Molveno", "Spormaggiore", "Calceranica al Lago", "Spiazzo", "Storo", "Borgo d'Anaunia", "Fierozzo", "Pomarolo", "Capriana", "Castelnuovo", "Castel Condino", "Dambel", "Giovo", "Massimeno", "Soraga di Fassa", "Aldeno", "Vallarsa", "Predaia", "Ossana", "Drena", "Ronchi Valsugana", "Tre Ville", "Bresimo", "Pal del Fersina", "Luserna", "Bocenago", "Caldonazzo", "Sanzeno", "Cimone", "Samone", "Vermiglio", "Ziano di Fiemme", "Moena", "Pinzolo", "Sarnonico", "Besenello", "Grigno", "Cont", "Bondone", "Terragnolo", "Torcegno", "Madruzzo", "Ledro", "Cembra Lisignago", "Bieno", "Porte di Rendena", "Fiav", "Panchi", "Sagron Mis", "Terzolas", "Carisolo", "Mezzocorona", "Nago-Torbole", "Riva del Garda", "Primiero San Martino di Castrozza", "Amblar-Don", "Ala", "Borgo Valsugana", "Villa Lagarina", "Nogaredo", "Fornace", "Garniga Terme", "Vallelaghi", "Altavalle", "Ronzo-Chienis", "Mal", "Sfruz", "Tenno", "Trambileno", "Commezzadura", "Folgaria", "Ton", "Pelugo", "Levico Terme", "Pergine Valsugana", "Novaledo", "Ospedaletto", "Segonzano", "Ville d'Anaunia", "Civezzano", "Comano Terme", "Mezzano", "Mezzana", "Lavis", "Giustino", "Mazzin", "Telve", "Tenna", "Dro", "Imer", "Predazzo", "San Michele all'Adige", "Isera", "Dimaro Folgarida", "Castello-Molina di Fiemme", "Borgo Lares", "Arco", "Baselga di Pin", "Calliano", "Castello Tesino", "Cis", "Canazei", "Bedollo", "Cavareno", "Denno", "Fai della Paganella", "Romeno", "Valdaone", "Rabbi", "Vignola-Falesina", "Altopiano della Vigolana", "Castel Ivano", "Brentonico", "Rumo", "Roncegno Terme", "Telve di Sopra", "Andalo", "Ronzone", "Strembo", "Cinte Tesino", "Nomi", "Rovereto", "Cavedago", "Lona-Lases", "Sant'Orsola Terme", "Bleggio Superiore", "Novella", "Frassilongo", "Campitello di Fassa", "Caldes", "Scurelle"] },
  Veneto: av,
  "Friuli-Venezia Giulia": { Udine: ["Pradamano", "Forni di Sotto", "Venzone", "Pontebba", "Forni di Sopra", "Bagnaria Arsa", "Resia", "Povoletto", "Savogna", "Fagagna", "Malborghetto Valbruna", "Flaibano", "Aquileia", "Drenchia", "Chiusaforte", "Taipana", "Torreano", "Trivignano Udinese", "Pavia di Udine", "Precenicco", "Cervignano del Friuli", "Mereto di Tomba", "Marano Lagunare", "Trasaghis", "Resiutta", "Palazzolo dello Stella", "Castions di Strada", "Ampezzo", "Remanzacco", "San Giovanni al Natisone", "Visco", "Gonars", "Montenars", "Cavazzo Carnico", "Prato Carnico", "Buttrio", "San Vito di Fagagna", "Dogna", "Ronchis", "Ruda", "Grimacco", "Sauris", "Majano", "Bordano", "Santa Maria la Longa", "Rivignano Teor", "Ragogna", "Socchieve", "Moggio Udinese", "Arta Terme", "Camino al Tagliamento", "Dignano", "Sappada", "Pagnacco", "Enemonzo", "Rive d'Arcano", "Bicinicco", "Rigolato", "Muzzana del Turgnano", "Basiliano", "Amaro", "Corno di Rosazzo", "Carlino", "Pocenia", "Cercivento", "Campolongo Tapogliano", "Tarcento", "Manzano", "Tavagnacco", "Premariacco", "Udine", "Verzegnis", "Zuglio", "Gemona del Friuli", "Pulfero", "Reana del Rojale", "Buja", "Preone", "Pasian di Prato", "Artegna", "Aiello del Friuli", "Moruzzo", "Coseano", "Cividale del Friuli", "Terzo d'Aquileia", "Lestizza", "San Pietro al Natisone", "Bertiolo", "Torviscosa", "Moimacco", "Osoppo", "San Giorgio di Nogaro", "Chiopris-Viscone", "Faedis", "Paluzza", "Magnano in Riviera", "Lignano Sabbiadoro", "Codroipo", "Latisana", "Porpetto", "Tricesimo", "Pozzuolo del Friuli", "San Daniele del Friuli", "Lauco", "Attimis", "Talmassons", "Nimis", "Forni Avoltri", "Fiumicello Villa Vicentina", "Comeglians", "Ovaro", "Paularo", "Varmo", "Raveo", "Prepotto", "Lusevera", "San Leonardo", "San Vito al Torre", "Forgaria nel Friuli", "Sedegliano", "Tolmezzo", "Palmanova", "Treppo Ligosullo", "Ravascletto", "Sutrio", "Tarvisio", "Cassacco", "Mortegliano", "Martignacco", "Villa Santina", "Colloredo di Monte Albano", "Treppo Grande", "Stregna", "Campoformido"], Gorizia: ["Mossa", "Staranzano", "Moraro", "Mariano del Friuli", "San Lorenzo Isontino", "Grado", "Capriva del Friuli", "San Pier d'Isonzo", "Farra d'Isonzo", "Fogliano Redipuglia", "Turriaco", "Cormons", "San Canzian d'Isonzo", "Ronchi dei Legionari", "Savogna d'Isonzo", "Romans d'Isonzo", "Sagrado", "Medea", "Doberd del Lago", "Gradisca d'Isonzo", "San Floriano del Collio", "Gorizia", "Dolegna del Collio", "Villesse", "Monfalcone"], Trieste: ["Muggia", "Monrupino", "Sgonico", "Duino Aurisina", "Trieste", "San Dorligo della Valle"], Pordenone: ["Porcia", "Caneva", "Fontanafredda", "Aviano", "Cimolais", "Pravisdomini", "Meduno", "Brugnera", "Polcenigo", "Pordenone", "Zoppola", "Arba", "Clauzetto", "Cavasso Nuovo", "Pasiano di Pordenone", "Tramonti di Sotto", "Castelnovo del Friuli", "Spilimbergo", "Budoia", "Roveredo in Piano", "San Giorgio della Richinvelda", "Vivaro", "Fiume Veneto", "Chions", "San Martino al Tagliamento", "Barcis", "Pinzano al Tagliamento", "Azzano Decimo", "Cordenons", "Casarsa della Delizia", "Prata di Pordenone", "Vajont", "Valvasone Arzene", "Maniago", "Montereale Valcellina", "San Quirino", "San Vito al Tagliamento", "Erto e Casso", "Claut", "Morsano al Tagliamento", "Andreis", "Frisanco", "Sacile", "Tramonti di Sopra", "Sesto al Reghena", "Fanna", "Vito d'Asio", "Sequals", "Travesio", "Cordovado"] },
  "Emilia-Romagna": { Piacenza: ["Vigolzone", "Cortemaggiore", "Rivergaro", "Gazzola", "Borgonovo Val Tidone", "Monticelli d'Ongina", "Piacenza", "Ponte dell'Olio", "Ferriere", "Bobbio", "Morfasso", "Ziano Piacentino", "Caorso", "Farini", "Pianello Val Tidone", "Calendasco", "Alseno", "Vernasca", "Agazzano", "Castell'Arquato", "Sarmato", "San Giorgio Piacentino", "Rottofreno", "Alta Val Tidone", "Castelvetro Piacentino", "Besenzone", "Castel San Giovanni", "Gragnano Trebbiense", "Travo", "Lugagnano Val d'Arda", "San Pietro in Cerro", "Carpaneto Piacentino", "Cadeo", "Corte Brugnatella", "Zerba", "Fiorenzuola d'Arda", "Podenzano", "Coli", "Bettola", "Pontenure", "Ottone", "Villanova sull'Arda", "Gropparello", "Piozzano", "Gossolengo", "Cerignale"], Parma: ["Tornolo", "Bore", "Borgo Val di Taro", "Sorbolo Mezzani", "Fidenza", "Collecchio", "Busseto", "Terenzo", "Varano de' Melegari", "Bardi", "Pellegrino Parmense", "Corniglio", "Felino", "Roccabianca", "Montechiarugolo", "Compiano", "Fontanellato", "Salsomaggiore Terme", "Berceto", "San Secondo Parmense", "Traversetolo", "Fontevivo", "Fornovo di Taro", "Neviano degli Arduini", "Palanzano", "Colorno", "Calestano", "Noceto", "Sala Baganza", "Lesignano de' Bagni", "Langhirano", "Sissa Trecasali", "Torrile", "Valmozzola", "Albareto", "Medesano", "Bedonia", "Parma", "Monchio delle Corti", "Tizzano Val Parma", "Polesine Zibello", "Varsi", "Solignano", "Soragna"], "Reggio nell'Emilia": ["Bagnolo in Piano", "Vetto", "Campagnola Emilia", "San Polo d'Enza", "Toano", "Gualtieri", "Canossa", "Scandiano", "Cadelbosco di Sopra", "Rubiera", "Guastalla", "Castelnovo di Sotto", "Vezzano sul Crostolo", "Casina", "Campegine", "Cavriago", "Brescello", "Luzzara", "Rolo", "Correggio", "Carpineti", "Gattatico", "Poviglio", "Rio Saliceto", "Boretto", "Villa Minozzo", "Castelnovo ne' Monti", "Reggio nell'Emilia", "Albinea", "Quattro Castella", "Novellara", "San Martino in Rio", "Bibbiano", "Ventasso", "Casalgrande", "Montecchio Emilia", "Viano", "Sant'Ilario d'Enza", "Baiso", "Fabbrico", "Reggiolo", "Castellarano"], Modena: ["Campogalliano", "Montecreto", "Bomporto", "Soliera", "Fiorano Modenese", "Ravarino", "Lama Mocogno", "Frassinoro", "Modena", "San Felice sul Panaro", "San Prospero", "Medolla", "Sassuolo", "Riolunato", "Pavullo nel Frignano", "Zocca", "Formigine", "Cavezzo", "Nonantola", "Serramazzoni", "Mirandola", "Bastiglia", "Prignano sulla Secchia", "Finale Emilia", "Guiglia", "Fiumalbo", "Fanano", "Spilamberto", "Polinago", "Castelnuovo Rangone", "Carpi", "Palagano", "San Cesario sul Panaro", "San Possidonio", "Castelfranco Emilia", "Pievepelago", "Montese", "Montefiorino", "Novi di Modena", "Sestola", "Vignola", "Camposanto", "Concordia sulla Secchia", "Savignano sul Panaro", "Marano sul Panaro", "Maranello", "Castelvetro di Modena"], Bologna: ["Casalfiumanese", "San Benedetto Val di Sambro", "San Giorgio di Piano", "Castiglione dei Pepoli", "Budrio", "Gaggio Montano", "Loiano", "Grizzana Morandi", "Medicina", "Ozzano dell'Emilia", "Pieve di Cento", "San Lazzaro di Savena", "San Pietro in Casale", "Zola Predosa", "Castel Guelfo di Bologna", "Castel del Rio", "Bentivoglio", "Argelato", "Sasso Marconi", "Casalecchio di Reno", "Camugnano", "Lizzano in Belvedere", "San Giovanni in Persiceto", "Castel di Casio", "Fontanelice", "Castenaso", "Monte San Pietro", "Castel d'Aiano", "Pianoro", "Galliera", "Malalbergo", "Sala Bolognese", "Calderara di Reno", "Valsamoggia", "Monzuno", "Alto Reno Terme", "Dozza", "Mordano", "Monterenzio", "Bologna", "Imola", "Vergato", "Castello d'Argile", "Castel San Pietro Terme", "Molinella", "Marzabotto", "Baricella", "Crevalcore", "Minerbio", "Anzola dell'Emilia", "Castel Maggiore", "Sant'Agata Bolognese", "Granarolo dell'Emilia", "Monghidoro", "Borgo Tossignano"], Ferrara: ["Cento", "Comacchio", "Bondeno", "Riva del Po", "Voghiera", "Lagosanto", "Mesola", "Portomaggiore", "Ferrara", "Goro", "Masi Torello", "Poggio Renatico", "Terre del Reno", "Fiscaglia", "Jolanda di Savoia", "Argenta", "Ostellato", "Tresignana", "Copparo", "Codigoro", "Vigarano Mainarda"], Ravenna: ["Bagnacavallo", "Massa Lombarda", "Conselice", "Ravenna", "Casola Valsenio", "Bagnara di Romagna", "Lugo", "Solarolo", "Castel Bolognese", "Cotignola", "Alfonsine", "Riolo Terme", "Russi", "Cervia", "Faenza", "Fusignano", "Brisighella", "Sant'Agata sul Santerno"], "Forl-Cesena": ["Cesenatico", "Modigliana", "Portico e San Benedetto", "Sarsina", "Roncofreddo", "Meldola", "Gatteo", "Castrocaro Terme e Terra del Sole", "Rocca San Casciano", "Santa Sofia", "Predappio", "Sogliano al Rubicone", "Longiano", "Verghereto", "Borghi", "Civitella di Romagna", "Forl", "Bagno di Romagna", "Galeata", "Montiano", "Tredozio", "Savignano sul Rubicone", "San Mauro Pascoli", "Forlimpopoli", "Premilcuore", "Bertinoro", "Gambettola", "Dovadola", "Cesena", "Mercato Saraceno"], Rimini: ["Montefiore Conca", "Saludecio", "Mondaino", "Pennabilli", "Montegridolfo", "Poggio Torriana", "Sassofeltrio", "Bellaria-Igea Marina", "Verucchio", "Misano Adriatico", "Casteldelci", "Gemmano", "Cattolica", "San Leo", "Sant'Agata Feltria", "Montecopiolo", "Montescudo-Monte Colombo", "Talamello", "Riccione", "San Clemente", "Santarcangelo di Romagna", "Morciano di Romagna", "Coriano", "Rimini", "Maiolo", "Novafeltria", "San Giovanni in Marignano"] },
  Marche: ov,
  Toscana: rv,
  Umbria: lv,
  Lazio: sv,
  Campania: uv,
  Abruzzo: cv,
  Molise: dv,
  Puglia: hv,
  Basilicata: fv,
  Calabria: gv,
  Sicilia: mv,
  Sardegna: vv
}, nt = typeof window < "u", Ts = nt && "IntersectionObserver" in window;
function Hu(t, e, n) {
  yv(t, e), e.set(t, n);
}
function yv(t, e) {
  if (e.has(t)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Zu(t, e, n) {
  return t.set(oh(t, e), n), n;
}
function $n(t, e) {
  return t.get(oh(t, e));
}
function oh(t, e, n) {
  if (typeof t == "function" ? t === e : t.has(e)) return arguments.length < 3 ? e : n;
  throw new TypeError("Private element is not present on this object");
}
function rh(t, e, n) {
  const i = e.length - 1;
  if (i < 0) return t === void 0 ? n : t;
  for (let a = 0; a < i; a++) {
    if (t == null)
      return n;
    t = t[e[a]];
  }
  return t == null || t[e[i]] === void 0 ? n : t[e[i]];
}
function en(t, e) {
  if (t === e) return !0;
  if (t instanceof Date && e instanceof Date && t.getTime() !== e.getTime() || t !== Object(t) || e !== Object(e))
    return !1;
  const n = Object.keys(t);
  return n.length !== Object.keys(e).length ? !1 : n.every((i) => en(t[i], e[i]));
}
function Cv(t, e, n) {
  return t == null || !e || typeof e != "string" ? n : t[e] !== void 0 ? t[e] : (e = e.replace(/\[(\w+)\]/g, ".$1"), e = e.replace(/^\./, ""), rh(t, e.split("."), n));
}
function Jt(t, e, n) {
  if (e === !0) return t === void 0 ? n : t;
  if (e == null || typeof e == "boolean") return n;
  if (t !== Object(t)) {
    if (typeof e != "function") return n;
    const a = e(t, n);
    return typeof a > "u" ? n : a;
  }
  if (typeof e == "string") return Cv(t, e, n);
  if (Array.isArray(e)) return rh(t, e, n);
  if (typeof e != "function") return n;
  const i = e(t, n);
  return typeof i > "u" ? n : i;
}
function he(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (t == null || t === "")
    return;
  const n = Number(t);
  return isNaN(n) ? String(t) : isFinite(n) ? `${n}${e}` : void 0;
}
function Nl(t) {
  return t !== null && typeof t == "object" && !Array.isArray(t);
}
function Ku(t) {
  let e;
  return t !== null && typeof t == "object" && ((e = Object.getPrototypeOf(t)) === Object.prototype || e === null);
}
function lh(t) {
  if (t && "$el" in t) {
    const e = t.$el;
    return (e == null ? void 0 : e.nodeType) === Node.TEXT_NODE ? e.nextElementSibling : e;
  }
  return t;
}
function sh(t) {
  return Object.keys(t);
}
function dl(t, e) {
  return e.every((n) => t.hasOwnProperty(n));
}
function bo(t, e) {
  const n = {};
  for (const i of e)
    Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
  return n;
}
function qu(t, e, n) {
  const i = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null);
  for (const o in t)
    e.some((r) => r instanceof RegExp ? r.test(o) : r === o) ? i[o] = t[o] : a[o] = t[o];
  return [i, a];
}
function Xi(t, e) {
  const n = {
    ...t
  };
  return e.forEach((i) => delete n[i]), n;
}
const uh = /^on[^a-z]/, ch = (t) => uh.test(t), pv = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
function ws(t) {
  const [e, n] = qu(t, [uh]), i = Xi(e, pv), [a, o] = qu(n, ["class", "style", "id", /^data-/]);
  return Object.assign(a, e), Object.assign(o, i), [a, o];
}
function Vt(t) {
  return t == null ? [] : Array.isArray(t) ? t : [t];
}
function _v(t, e) {
  let n = 0;
  const i = function() {
    for (var a = arguments.length, o = new Array(a), r = 0; r < a; r++)
      o[r] = arguments[r];
    clearTimeout(n), n = setTimeout(() => t(...o), W(e));
  };
  return i.clear = () => {
    clearTimeout(n);
  }, i.immediate = t, i;
}
function Gt(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(e, Math.min(n, t));
}
function Ju(t, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return t + n.repeat(Math.max(0, e - t.length));
}
function Sv(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const n = [];
  let i = 0;
  for (; i < t.length; )
    n.push(t.substr(i, e)), i += e;
  return n;
}
function qn() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  const i = {};
  for (const a in t)
    i[a] = t[a];
  for (const a in e) {
    const o = t[a], r = e[a];
    if (Ku(o) && Ku(r)) {
      i[a] = qn(o, r, n);
      continue;
    }
    if (n && Array.isArray(o) && Array.isArray(r)) {
      i[a] = n(o, r);
      continue;
    }
    i[a] = r;
  }
  return i;
}
function dh(t) {
  return t.map((e) => e.type === pe ? dh(e.children) : e).flat();
}
function Gi() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (Gi.cache.has(t)) return Gi.cache.get(t);
  const e = t.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  return Gi.cache.set(t, e), e;
}
Gi.cache = /* @__PURE__ */ new Map();
function la(t, e) {
  if (!e || typeof e != "object") return [];
  if (Array.isArray(e))
    return e.map((n) => la(t, n)).flat(1);
  if (e.suspense)
    return la(t, e.ssContent);
  if (Array.isArray(e.children))
    return e.children.map((n) => la(t, n)).flat(1);
  if (e.component) {
    if (Object.getOwnPropertySymbols(e.component.provides).includes(t))
      return [e.component];
    if (e.component.subTree)
      return la(t, e.component.subTree).flat(1);
  }
  return [];
}
var Hi = /* @__PURE__ */ new WeakMap(), Ii = /* @__PURE__ */ new WeakMap();
class hh {
  constructor(e) {
    Hu(this, Hi, []), Hu(this, Ii, 0), this.size = e;
  }
  get isFull() {
    return $n(Hi, this).length === this.size;
  }
  push(e) {
    $n(Hi, this)[$n(Ii, this)] = e, Zu(Ii, this, ($n(Ii, this) + 1) % this.size);
  }
  values() {
    return $n(Hi, this).slice($n(Ii, this)).concat($n(Hi, this).slice(0, $n(Ii, this)));
  }
  clear() {
    $n(Hi, this).length = 0, Zu(Ii, this, 0);
  }
}
function Es(t) {
  const e = cn({});
  Pt(() => {
    const i = t();
    for (const a in i)
      e[a] = i[a];
  }, {
    flush: "sync"
  });
  const n = {};
  for (const i in e)
    n[i] = O(() => e[i]);
  return n;
}
function or(t, e) {
  return t.includes(e);
}
function fh(t) {
  return t[2].toLowerCase() + t.slice(3);
}
const Bt = () => [Function, Array];
function Qu(t, e) {
  return e = "on" + _o(e), !!(t[e] || t[`${e}Once`] || t[`${e}Capture`] || t[`${e}OnceCapture`] || t[`${e}CaptureOnce`]);
}
function As(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
    n[i - 1] = arguments[i];
  if (Array.isArray(t))
    for (const a of t)
      a(...n);
  else typeof t == "function" && t(...n);
}
function rr(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const n = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((i) => `${i}${e ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
  return [...t.querySelectorAll(n)];
}
function gh(t, e, n) {
  let i, a = t.indexOf(document.activeElement);
  const o = e === "next" ? 1 : -1;
  do
    a += o, i = t[a];
  while ((!i || i.offsetParent == null || !((n == null ? void 0 : n(i)) ?? !0)) && a < t.length && a >= 0);
  return i;
}
function Ha(t, e) {
  var i, a, o, r;
  const n = rr(t);
  if (e == null)
    (t === document.activeElement || !t.contains(document.activeElement)) && ((i = n[0]) == null || i.focus());
  else if (e === "first")
    (a = n[0]) == null || a.focus();
  else if (e === "last")
    (o = n.at(-1)) == null || o.focus();
  else if (typeof e == "number")
    (r = n[e]) == null || r.focus();
  else {
    const l = gh(n, e);
    l ? l.focus() : Ha(t, e === "next" ? "first" : "last");
  }
}
function bv() {
}
function ya(t, e) {
  if (!(nt && typeof CSS < "u" && typeof CSS.supports < "u" && CSS.supports(`selector(${e})`))) return null;
  try {
    return !!t && t.matches(e);
  } catch {
    return null;
  }
}
function Rs(t) {
  return t.some((e) => Bm(e) ? e.type === Fm ? !1 : e.type !== pe || Rs(e.children) : !0) ? t : null;
}
function Mv(t, e) {
  if (!nt || t === 0)
    return e(), () => {
    };
  const n = window.setTimeout(e, t);
  return () => window.clearTimeout(n);
}
function xv(t, e) {
  const n = t.clientX, i = t.clientY, a = e.getBoundingClientRect(), o = a.left, r = a.top, l = a.right, s = a.bottom;
  return n >= o && n <= l && i >= r && i <= s;
}
function Wl() {
  const t = Q(), e = (n) => {
    t.value = n;
  };
  return Object.defineProperty(e, "value", {
    enumerable: !0,
    get: () => t.value,
    set: (n) => t.value = n
  }), Object.defineProperty(e, "el", {
    enumerable: !0,
    get: () => lh(t.value)
  }), e;
}
function lr(t) {
  const e = t.key.length === 1, n = !t.ctrlKey && !t.metaKey && !t.altKey;
  return e && n;
}
function $l(t) {
  return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "bigint";
}
function Pv(t) {
  const e = {};
  for (const n in t)
    e[Ss(n)] = t[n];
  return e;
}
function Tv(t) {
  const e = ["checked", "disabled"];
  return Object.fromEntries(Object.entries(t).filter((n) => {
    let [i, a] = n;
    return e.includes(i) ? !!a : a !== void 0;
  }));
}
function Qe(t, e) {
  const n = Kd();
  if (!n)
    throw new Error(`[Vuetify] ${t} must be called from inside a setup function`);
  return n;
}
function On() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const e = Qe(t).type;
  return Gi((e == null ? void 0 : e.aliasName) || (e == null ? void 0 : e.name));
}
function wv(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Qe("injectSelf");
  const {
    provides: n
  } = e;
  if (n && t in n)
    return n[t];
}
const sr = Symbol.for("vuetify:defaults");
function Is() {
  const t = Ne(sr);
  if (!t) throw new Error("[Vuetify] Could not find defaults instance");
  return t;
}
function ai(t, e) {
  const n = Is(), i = Z(t), a = E(() => {
    if (W(e == null ? void 0 : e.disabled)) return n.value;
    const r = W(e == null ? void 0 : e.scoped), l = W(e == null ? void 0 : e.reset), s = W(e == null ? void 0 : e.root);
    if (i.value == null && !(r || l || s)) return n.value;
    let u = qn(i.value, {
      prev: n.value
    });
    if (r) return u;
    if (l || s) {
      const c = Number(l || 1 / 0);
      for (let d = 0; d <= c && !(!u || !("prev" in u)); d++)
        u = u.prev;
      return u && typeof s == "string" && s in u && (u = qn(qn(u, {
        prev: u
      }), u[s])), u;
    }
    return u.prev ? qn(u.prev, u) : u;
  });
  return ht(sr, a), a;
}
function Ev(t, e) {
  return t.props && (typeof t.props[e] < "u" || typeof t.props[Gi(e)] < "u");
}
function Av() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Is();
  const i = Qe("useDefaults");
  if (e = e ?? i.type.name ?? i.type.__name, !e)
    throw new Error("[Vuetify] Could not determine component name");
  const a = E(() => {
    var s;
    return (s = n.value) == null ? void 0 : s[t._as ?? e];
  }), o = new Proxy(t, {
    get(s, u) {
      var f, g, m, v;
      const c = Reflect.get(s, u);
      if (u === "class" || u === "style")
        return [(f = a.value) == null ? void 0 : f[u], c].filter((y) => y != null);
      if (Ev(i.vnode, u)) return c;
      const d = (g = a.value) == null ? void 0 : g[u];
      if (d !== void 0) return d;
      const h = (v = (m = n.value) == null ? void 0 : m.global) == null ? void 0 : v[u];
      return h !== void 0 ? h : c;
    }
  }), r = Q();
  Pt(() => {
    if (a.value) {
      const s = Object.entries(a.value).filter((u) => {
        let [c] = u;
        return c.startsWith(c[0].toUpperCase());
      });
      r.value = s.length ? Object.fromEntries(s) : void 0;
    } else
      r.value = void 0;
  });
  function l() {
    const s = wv(sr, i);
    ht(sr, E(() => r.value ? qn((s == null ? void 0 : s.value) ?? {}, r.value) : s == null ? void 0 : s.value));
  }
  return {
    props: o,
    provideSubDefaults: l
  };
}
const mh = ["top", "bottom"], Rv = ["start", "end", "left", "right"];
function Xl(t, e) {
  let [n, i] = t.split(" ");
  return i || (i = or(mh, n) ? "start" : or(Rv, n) ? "top" : "center"), {
    side: Ul(n, e),
    align: Ul(i, e)
  };
}
function Ul(t, e) {
  return t === "start" ? e ? "right" : "left" : t === "end" ? e ? "left" : "right" : t;
}
function hl(t) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[t.side],
    align: t.align
  };
}
function fl(t) {
  return {
    side: t.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[t.align]
  };
}
function ec(t) {
  return {
    side: t.align,
    align: t.side
  };
}
function tc(t) {
  return or(mh, t.side) ? "y" : "x";
}
class Rn {
  constructor(e) {
    let {
      x: n,
      y: i,
      width: a,
      height: o
    } = e;
    this.x = n, this.y = i, this.width = a, this.height = o;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function nc(t, e) {
  return {
    x: {
      before: Math.max(0, e.left - t.left),
      after: Math.max(0, t.right - e.right)
    },
    y: {
      before: Math.max(0, e.top - t.top),
      after: Math.max(0, t.bottom - e.bottom)
    }
  };
}
function vh(t) {
  return Array.isArray(t) ? new Rn({
    x: t[0],
    y: t[1],
    width: 0,
    height: 0
  }) : t.getBoundingClientRect();
}
function Iv(t) {
  if (t === document.documentElement)
    return visualViewport ? new Rn({
      x: visualViewport.scale > 1 ? 0 : visualViewport.offsetLeft,
      y: visualViewport.scale > 1 ? 0 : visualViewport.offsetTop,
      width: visualViewport.width * visualViewport.scale,
      height: visualViewport.height * visualViewport.scale
    }) : new Rn({
      x: 0,
      y: 0,
      width: document.documentElement.clientWidth,
      height: document.documentElement.clientHeight
    });
  {
    const e = t.getBoundingClientRect();
    return new Rn({
      x: e.x,
      y: e.y,
      width: t.clientWidth,
      height: t.clientHeight
    });
  }
}
function zs(t) {
  const e = t.getBoundingClientRect(), n = getComputedStyle(t), i = n.transform;
  if (i) {
    let a, o, r, l, s;
    if (i.startsWith("matrix3d("))
      a = i.slice(9, -1).split(/, /), o = Number(a[0]), r = Number(a[5]), l = Number(a[12]), s = Number(a[13]);
    else if (i.startsWith("matrix("))
      a = i.slice(7, -1).split(/, /), o = Number(a[0]), r = Number(a[3]), l = Number(a[4]), s = Number(a[5]);
    else
      return new Rn(e);
    const u = n.transformOrigin, c = e.x - l - (1 - o) * parseFloat(u), d = e.y - s - (1 - r) * parseFloat(u.slice(u.indexOf(" ") + 1)), h = o ? e.width / o : t.offsetWidth + 1, f = r ? e.height / r : t.offsetHeight + 1;
    return new Rn({
      x: c,
      y: d,
      width: h,
      height: f
    });
  } else
    return new Rn(e);
}
function sa(t, e, n) {
  if (typeof t.animate > "u") return {
    finished: Promise.resolve()
  };
  let i;
  try {
    i = t.animate(e, n);
  } catch {
    return {
      finished: Promise.resolve()
    };
  }
  return typeof i.finished > "u" && (i.finished = new Promise((a) => {
    i.onfinish = () => {
      a(i);
    };
  })), i;
}
const nr = /* @__PURE__ */ new WeakMap();
function zv(t, e) {
  Object.keys(e).forEach((n) => {
    if (ch(n)) {
      const i = fh(n), a = nr.get(t);
      if (e[n] == null)
        a == null || a.forEach((o) => {
          const [r, l] = o;
          r === i && (t.removeEventListener(i, l), a.delete(o));
        });
      else if (!a || ![...a].some((o) => o[0] === i && o[1] === e[n])) {
        t.addEventListener(i, e[n]);
        const o = a || /* @__PURE__ */ new Set();
        o.add([i, e[n]]), nr.has(t) || nr.set(t, o);
      }
    } else
      e[n] == null ? t.removeAttribute(n) : t.setAttribute(n, e[n]);
  });
}
function Lv(t, e) {
  Object.keys(e).forEach((n) => {
    if (ch(n)) {
      const i = fh(n), a = nr.get(t);
      a == null || a.forEach((o) => {
        const [r, l] = o;
        r === i && (t.removeEventListener(i, l), a.delete(o));
      });
    } else
      t.removeAttribute(n);
  });
}
const Zi = 2.4, ic = 0.2126729, ac = 0.7151522, oc = 0.072175, Vv = 0.55, Bv = 0.58, Fv = 0.57, kv = 0.62, Wo = 0.03, rc = 1.45, Ov = 5e-4, Dv = 1.25, Gv = 1.25, lc = 0.078, sc = 12.82051282051282, $o = 0.06, uc = 1e-3;
function cc(t, e) {
  const n = (t.r / 255) ** Zi, i = (t.g / 255) ** Zi, a = (t.b / 255) ** Zi, o = (e.r / 255) ** Zi, r = (e.g / 255) ** Zi, l = (e.b / 255) ** Zi;
  let s = n * ic + i * ac + a * oc, u = o * ic + r * ac + l * oc;
  if (s <= Wo && (s += (Wo - s) ** rc), u <= Wo && (u += (Wo - u) ** rc), Math.abs(u - s) < Ov) return 0;
  let c;
  if (u > s) {
    const d = (u ** Vv - s ** Bv) * Dv;
    c = d < uc ? 0 : d < lc ? d - d * sc * $o : d - $o;
  } else {
    const d = (u ** kv - s ** Fv) * Gv;
    c = d > -uc ? 0 : d > -lc ? d - d * sc * $o : d + $o;
  }
  return c * 100;
}
function In(t) {
  Ar(`Vuetify: ${t}`);
}
function yh(t) {
  Ar(`Vuetify error: ${t}`);
}
function Nv(t, e) {
  e = Array.isArray(e) ? e.slice(0, -1).map((n) => `'${n}'`).join(", ") + ` or '${e.at(-1)}'` : `'${e}'`, Ar(`[Vuetify UPGRADE] '${t}' is deprecated, use ${e} instead.`);
}
function Yl(t) {
  return !!t && /^(#|var\(--|(rgb|hsl)a?\()/.test(t);
}
function Wv(t) {
  return Yl(t) && !/^((rgb|hsl)a?\()?var\(--/.test(t);
}
const dc = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/, $v = {
  rgb: (t, e, n, i) => ({
    r: t,
    g: e,
    b: n,
    a: i
  }),
  rgba: (t, e, n, i) => ({
    r: t,
    g: e,
    b: n,
    a: i
  }),
  hsl: (t, e, n, i) => hc({
    h: t,
    s: e,
    l: n,
    a: i
  }),
  hsla: (t, e, n, i) => hc({
    h: t,
    s: e,
    l: n,
    a: i
  }),
  hsv: (t, e, n, i) => eo({
    h: t,
    s: e,
    v: n,
    a: i
  }),
  hsva: (t, e, n, i) => eo({
    h: t,
    s: e,
    v: n,
    a: i
  })
};
function Xa(t) {
  if (typeof t == "number")
    return (isNaN(t) || t < 0 || t > 16777215) && In(`'${t}' is not a valid hex color`), {
      r: (t & 16711680) >> 16,
      g: (t & 65280) >> 8,
      b: t & 255
    };
  if (typeof t == "string" && dc.test(t)) {
    const {
      groups: e
    } = t.match(dc), {
      fn: n,
      values: i
    } = e, a = i.split(/,\s*|\s*\/\s*|\s+/).map((o, r) => o.endsWith("%") || // unitless slv are %
    r > 0 && r < 3 && ["hsl", "hsla", "hsv", "hsva"].includes(n) ? parseFloat(o) / 100 : parseFloat(o));
    return $v[n](...a);
  } else if (typeof t == "string") {
    let e = t.startsWith("#") ? t.slice(1) : t;
    [3, 4].includes(e.length) ? e = e.split("").map((i) => i + i).join("") : [6, 8].includes(e.length) || In(`'${t}' is not a valid hex(a) color`);
    const n = parseInt(e, 16);
    return (isNaN(n) || n < 0 || n > 4294967295) && In(`'${t}' is not a valid hex(a) color`), Xv(e);
  } else if (typeof t == "object") {
    if (dl(t, ["r", "g", "b"]))
      return t;
    if (dl(t, ["h", "s", "l"]))
      return eo(Ch(t));
    if (dl(t, ["h", "s", "v"]))
      return eo(t);
  }
  throw new TypeError(`Invalid color: ${t == null ? t : String(t) || t.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function eo(t) {
  const {
    h: e,
    s: n,
    v: i,
    a
  } = t, o = (l) => {
    const s = (l + e / 60) % 6;
    return i - i * n * Math.max(Math.min(s, 4 - s, 1), 0);
  }, r = [o(5), o(3), o(1)].map((l) => Math.round(l * 255));
  return {
    r: r[0],
    g: r[1],
    b: r[2],
    a
  };
}
function hc(t) {
  return eo(Ch(t));
}
function Ch(t) {
  const {
    h: e,
    s: n,
    l: i,
    a
  } = t, o = i + n * Math.min(i, 1 - i), r = o === 0 ? 0 : 2 - 2 * i / o;
  return {
    h: e,
    s: r,
    v: o,
    a
  };
}
function Xv(t) {
  t = Uv(t);
  let [e, n, i, a] = Sv(t, 2).map((o) => parseInt(o, 16));
  return a = a === void 0 ? a : a / 255, {
    r: e,
    g: n,
    b: i,
    a
  };
}
function Uv(t) {
  return t.startsWith("#") && (t = t.slice(1)), t = t.replace(/([^0-9a-f])/gi, "F"), (t.length === 3 || t.length === 4) && (t = t.split("").map((e) => e + e).join("")), t.length !== 6 && (t = Ju(Ju(t, 6), 8, "F")), t;
}
function Yv(t) {
  const e = Math.abs(cc(Xa(0), Xa(t)));
  return Math.abs(cc(Xa(16777215), Xa(t))) > Math.min(e, 50) ? "#fff" : "#000";
}
function U(t, e) {
  return (n) => Object.keys(t).reduce((i, a) => {
    const r = typeof t[a] == "object" && t[a] != null && !Array.isArray(t[a]) ? t[a] : {
      type: t[a]
    };
    return n && a in n ? i[a] = {
      ...r,
      default: n[a]
    } : i[a] = r, e && !i[a].source && (i[a].source = e), i;
  }, {});
}
const ve = U({
  class: [String, Array, Object],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component");
function Mo(t) {
  if (t._setup = t._setup ?? t.setup, !t.name)
    return In("The component is missing an explicit name, unable to generate default prop value"), t;
  if (t._setup) {
    t.props = U(t.props ?? {}, t.name)();
    const e = Object.keys(t.props).filter((n) => n !== "class" && n !== "style");
    t.filterProps = function(i) {
      return bo(i, e);
    }, t.props._as = String, t.setup = function(i, a) {
      const o = Is();
      if (!o.value) return t._setup(i, a);
      const {
        props: r,
        provideSubDefaults: l
      } = Av(i, i._as ?? t.name, o), s = t._setup(r, a);
      return l(), s;
    };
  }
  return t;
}
function ee() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  return (e) => (t ? Mo : km)(e);
}
function ph(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div", n = arguments.length > 2 ? arguments[2] : void 0;
  return ee()({
    name: n ?? _o(Ss(t.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: e
      },
      ...ve()
    },
    setup(i, a) {
      let {
        slots: o
      } = a;
      return () => {
        var r;
        return Ta(i.tag, {
          class: [t, i.class],
          style: i.style
        }, (r = o.default) == null ? void 0 : r.call(o));
      };
    }
  });
}
function _h(t) {
  if (typeof t.getRootNode != "function") {
    for (; t.parentNode; ) t = t.parentNode;
    return t !== document ? null : document;
  }
  const e = t.getRootNode();
  return e !== document && e.getRootNode({
    composed: !0
  }) !== document ? null : e;
}
const ur = "cubic-bezier(0.4, 0, 0.2, 1)", jv = "cubic-bezier(0.0, 0, 0.2, 1)", Hv = "cubic-bezier(0.4, 0, 1, 1)";
function Sh(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  for (; t; ) {
    if (e ? Zv(t) : Ls(t)) return t;
    t = t.parentElement;
  }
  return document.scrollingElement;
}
function cr(t, e) {
  const n = [];
  if (e && t && !e.contains(t)) return n;
  for (; t && (Ls(t) && n.push(t), t !== e); )
    t = t.parentElement;
  return n;
}
function Ls(t) {
  if (!t || t.nodeType !== Node.ELEMENT_NODE) return !1;
  const e = window.getComputedStyle(t);
  return e.overflowY === "scroll" || e.overflowY === "auto" && t.scrollHeight > t.clientHeight;
}
function Zv(t) {
  if (!t || t.nodeType !== Node.ELEMENT_NODE) return !1;
  const e = window.getComputedStyle(t);
  return ["scroll", "auto"].includes(e.overflowY);
}
function Kv(t) {
  for (; t; ) {
    if (window.getComputedStyle(t).position === "fixed")
      return !0;
    t = t.offsetParent;
  }
  return !1;
}
function le(t) {
  const e = Qe("useRender");
  e.render = t;
}
const qv = U({
  defaults: Object,
  disabled: Boolean,
  reset: [Number, String],
  root: [Boolean, String],
  scoped: Boolean
}, "VDefaultsProvider"), We = ee(!1)({
  name: "VDefaultsProvider",
  props: qv(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      defaults: i,
      disabled: a,
      reset: o,
      root: r,
      scoped: l
    } = Om(t);
    return ai(i, {
      reset: o,
      root: r,
      scoped: l,
      disabled: a
    }), () => {
      var s;
      return (s = n.default) == null ? void 0 : s.call(n);
    };
  }
});
function Vs(t) {
  return Es(() => {
    const e = Vn(t), n = [], i = {};
    if (e.background)
      if (Yl(e.background)) {
        if (i.backgroundColor = e.background, !e.text && Wv(e.background)) {
          const a = Xa(e.background);
          if (a.a == null || a.a === 1) {
            const o = Yv(a);
            i.color = o, i.caretColor = o;
          }
        }
      } else
        n.push(`bg-${e.background}`);
    return e.text && (Yl(e.text) ? (i.color = e.text, i.caretColor = e.text) : n.push(`text-${e.text}`)), {
      colorClasses: n,
      colorStyles: i
    };
  });
}
function Bn(t) {
  const {
    colorClasses: e,
    colorStyles: n
  } = Vs(() => ({
    text: Vn(t)
  }));
  return {
    textColorClasses: e,
    textColorStyles: n
  };
}
function xt(t) {
  const {
    colorClasses: e,
    colorStyles: n
  } = Vs(() => ({
    background: Vn(t)
  }));
  return {
    backgroundColorClasses: e,
    backgroundColorStyles: n
  };
}
const Pe = [String, Function, Object, Array], Jv = Symbol.for("vuetify:icons"), zr = U({
  icon: {
    type: Pe
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: [String, Object, Function],
    required: !0
  }
}, "icon"), fc = ee()({
  name: "VComponentIcon",
  props: zr(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return () => {
      const i = t.icon;
      return S(t.tag, null, {
        default: () => {
          var a;
          return [t.icon ? S(i, null, null) : (a = n.default) == null ? void 0 : a.call(n)];
        }
      });
    };
  }
}), Qv = Mo({
  name: "VSvgIcon",
  inheritAttrs: !1,
  props: zr(),
  setup(t, e) {
    let {
      attrs: n
    } = e;
    return () => S(t.tag, oe(n, {
      style: null
    }), {
      default: () => [w("svg", {
        class: "v-icon__svg",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        role: "img",
        "aria-hidden": "true"
      }, [Array.isArray(t.icon) ? t.icon.map((i) => Array.isArray(i) ? w("path", {
        d: i[0],
        "fill-opacity": i[1]
      }, null) : w("path", {
        d: i
      }, null)) : w("path", {
        d: t.icon
      }, null)])]
    });
  }
});
Mo({
  name: "VLigatureIcon",
  props: zr(),
  setup(t) {
    return () => S(t.tag, null, {
      default: () => [t.icon]
    });
  }
});
Mo({
  name: "VClassIcon",
  props: zr(),
  setup(t) {
    return () => S(t.tag, {
      class: te(t.icon)
    }, null);
  }
});
const ey = (t) => {
  const e = Ne(Jv);
  if (!e) throw new Error("Missing Vuetify Icons provide!");
  return {
    iconData: E(() => {
      var s;
      const i = Vn(t);
      if (!i) return {
        component: fc
      };
      let a = i;
      if (typeof a == "string" && (a = a.trim(), a.startsWith("$") && (a = (s = e.aliases) == null ? void 0 : s[a.slice(1)])), a || In(`Could not find aliased icon "${i}"`), Array.isArray(a))
        return {
          component: Qv,
          icon: a
        };
      if (typeof a != "string")
        return {
          component: fc,
          icon: a
        };
      const o = Object.keys(e.sets).find((u) => typeof a == "string" && a.startsWith(`${u}:`)), r = o ? a.slice(o.length + 1) : a;
      return {
        component: e.sets[o ?? e.defaultSet].component,
        icon: r
      };
    })
  };
}, ty = ["x-small", "small", "default", "large", "x-large"], xo = U({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function Po(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : On();
  return Es(() => {
    const n = t.size;
    let i, a;
    return or(ty, n) ? i = `${e}--size-${n}` : n && (a = {
      width: he(n),
      height: he(n)
    }), {
      sizeClasses: i,
      sizeStyles: a
    };
  });
}
const Oe = U({
  tag: {
    type: [String, Object, Function],
    default: "div"
  }
}, "tag"), jl = Symbol.for("vuetify:theme"), Ue = U({
  theme: String
}, "theme");
function et(t) {
  Qe("provideTheme");
  const e = Ne(jl, null);
  if (!e) throw new Error("Could not find Vuetify theme injection");
  const n = O(() => t.theme ?? e.name.value), i = O(() => e.themes.value[n.value]), a = O(() => e.isDisabled ? void 0 : `${e.prefix}theme--${n.value}`), o = {
    ...e,
    name: n,
    current: i,
    themeClasses: a
  };
  return ht(jl, o), o;
}
function ny() {
  Qe("useTheme");
  const t = Ne(jl, null);
  if (!t) throw new Error("Could not find Vuetify theme injection");
  return t;
}
const iy = U({
  color: String,
  disabled: Boolean,
  start: Boolean,
  end: Boolean,
  icon: Pe,
  opacity: [String, Number],
  ...ve(),
  ...xo(),
  ...Oe({
    tag: "i"
  }),
  ...Ue()
}, "VIcon"), Be = ee()({
  name: "VIcon",
  props: iy(),
  setup(t, e) {
    let {
      attrs: n,
      slots: i
    } = e;
    const a = Q(), {
      themeClasses: o
    } = ny(), {
      iconData: r
    } = ey(() => a.value || t.icon), {
      sizeClasses: l
    } = Po(t), {
      textColorClasses: s,
      textColorStyles: u
    } = Bn(() => t.color);
    return le(() => {
      var h, f;
      const c = (h = i.default) == null ? void 0 : h.call(i);
      c && (a.value = (f = dh(c).filter((g) => g.type === Dm && g.children && typeof g.children == "string")[0]) == null ? void 0 : f.children);
      const d = !!(n.onClick || n.onClickOnce);
      return S(r.value.component, {
        tag: t.tag,
        icon: r.value.icon,
        class: te(["v-icon", "notranslate", o.value, l.value, s.value, {
          "v-icon--clickable": d,
          "v-icon--disabled": t.disabled,
          "v-icon--start": t.start,
          "v-icon--end": t.end
        }, t.class]),
        style: re([{
          "--v-icon-opacity": t.opacity
        }, l.value ? void 0 : {
          fontSize: he(t.size),
          height: he(t.size),
          width: he(t.size)
        }, u.value, t.style]),
        role: d ? "button" : void 0,
        "aria-hidden": !d,
        tabindex: d ? t.disabled ? -1 : 0 : void 0
      }, {
        default: () => [c]
      });
    }), {};
  }
}), ln = U({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function sn(t) {
  return {
    dimensionStyles: E(() => {
      const n = {}, i = he(t.height), a = he(t.maxHeight), o = he(t.maxWidth), r = he(t.minHeight), l = he(t.minWidth), s = he(t.width);
      return i != null && (n.height = i), a != null && (n.maxHeight = a), o != null && (n.maxWidth = o), r != null && (n.minHeight = r), l != null && (n.minWidth = l), s != null && (n.width = s), n;
    })
  };
}
function ay(t) {
  return {
    aspectStyles: E(() => {
      const e = Number(t.aspectRatio);
      return e ? {
        paddingBottom: String(1 / e * 100) + "%"
      } : void 0;
    })
  };
}
const bh = U({
  aspectRatio: [String, Number],
  contentClass: null,
  inline: Boolean,
  ...ve(),
  ...ln()
}, "VResponsive"), gc = ee()({
  name: "VResponsive",
  props: bh(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      aspectStyles: i
    } = ay(t), {
      dimensionStyles: a
    } = sn(t);
    return le(() => {
      var o;
      return w("div", {
        class: te(["v-responsive", {
          "v-responsive--inline": t.inline
        }, t.class]),
        style: re([a.value, t.style])
      }, [w("div", {
        class: "v-responsive__sizer",
        style: re(i.value)
      }, null), (o = n.additional) == null ? void 0 : o.call(n), n.default && w("div", {
        class: te(["v-responsive__content", t.contentClass])
      }, [n.default()])]);
    }), {};
  }
}), Tt = U({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  },
  tile: Boolean
}, "rounded");
function wt(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : On();
  return {
    roundedClasses: E(() => {
      const i = Gl(t) ? t.value : t.rounded, a = Gl(t) ? t.value : t.tile, o = [];
      if (i === !0 || i === "")
        o.push(`${e}--rounded`);
      else if (typeof i == "string" || i === 0)
        for (const r of String(i).split(" "))
          o.push(`rounded-${r}`);
      else (a || i === !1) && o.push("rounded-0");
      return o;
    })
  };
}
const Ea = U({
  transition: {
    type: null,
    default: "fade-transition",
    validator: (t) => t !== !0
  }
}, "transition"), Jn = (t, e) => {
  let {
    slots: n
  } = e;
  const {
    transition: i,
    disabled: a,
    group: o,
    ...r
  } = t, {
    component: l = o ? bs : Si,
    ...s
  } = Nl(i) ? i : {};
  let u;
  return Nl(i) ? u = oe(s, Tv({
    disabled: a,
    group: o
  }), r) : u = oe({
    name: a || !i ? "" : i
  }, r), Ta(l, u, n);
};
function oy(t, e) {
  if (!Ts) return;
  const n = e.modifiers || {}, i = e.value, {
    handler: a,
    options: o
  } = typeof i == "object" ? i : {
    handler: i,
    options: {}
  }, r = new IntersectionObserver(function() {
    var d;
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], s = arguments.length > 1 ? arguments[1] : void 0;
    const u = (d = t._observe) == null ? void 0 : d[e.instance.$.uid];
    if (!u) return;
    const c = l.some((h) => h.isIntersecting);
    a && (!n.quiet || u.init) && (!n.once || c || u.init) && a(c, l, s), c && n.once ? Mh(t, e) : u.init = !0;
  }, o);
  t._observe = Object(t._observe), t._observe[e.instance.$.uid] = {
    init: !1,
    observer: r
  }, r.observe(t);
}
function Mh(t, e) {
  var i;
  const n = (i = t._observe) == null ? void 0 : i[e.instance.$.uid];
  n && (n.observer.unobserve(t), delete t._observe[e.instance.$.uid]);
}
const Ca = {
  mounted: oy,
  unmounted: Mh
}, xh = U({
  absolute: Boolean,
  alt: String,
  cover: Boolean,
  color: String,
  draggable: {
    type: [Boolean, String],
    default: void 0
  },
  eager: Boolean,
  gradient: String,
  lazySrc: String,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  sizes: String,
  src: {
    type: [String, Object],
    default: ""
  },
  crossorigin: String,
  referrerpolicy: String,
  srcset: String,
  position: String,
  ...bh(),
  ...ve(),
  ...Tt(),
  ...Ea()
}, "VImg"), nn = ee()({
  name: "VImg",
  directives: {
    vIntersect: Ca
  },
  props: xh(),
  emits: {
    loadstart: (t) => !0,
    load: (t) => !0,
    error: (t) => !0
  },
  setup(t, e) {
    let {
      emit: n,
      slots: i
    } = e;
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: o
    } = xt(() => t.color), {
      roundedClasses: r
    } = wt(t), l = Qe("VImg"), s = Q(""), u = Z(), c = Q(t.eager ? "loading" : "idle"), d = Q(), h = Q(), f = E(() => t.src && typeof t.src == "object" ? {
      src: t.src.src,
      srcset: t.srcset || t.src.srcset,
      lazySrc: t.lazySrc || t.src.lazySrc,
      aspect: Number(t.aspectRatio || t.src.aspect || 0)
    } : {
      src: t.src,
      srcset: t.srcset,
      lazySrc: t.lazySrc,
      aspect: Number(t.aspectRatio || 0)
    }), g = E(() => f.value.aspect || d.value / h.value || 0);
    ie(() => t.src, () => {
      m(c.value !== "idle");
    }), ie(g, (z, I) => {
      !z && I && u.value && p(u.value);
    }), Rr(() => m());
    function m(z) {
      if (!(t.eager && z) && !(Ts && !z && !t.eager)) {
        if (c.value = "loading", f.value.lazySrc) {
          const I = new Image();
          I.src = f.value.lazySrc, p(I, null);
        }
        f.value.src && Ye(() => {
          var I;
          n("loadstart", ((I = u.value) == null ? void 0 : I.currentSrc) || f.value.src), setTimeout(() => {
            var k;
            if (!l.isUnmounted)
              if ((k = u.value) != null && k.complete) {
                if (u.value.naturalWidth || y(), c.value === "error") return;
                g.value || p(u.value, null), c.value === "loading" && v();
              } else
                g.value || p(u.value), C();
          });
        });
      }
    }
    function v() {
      var z;
      l.isUnmounted || (C(), p(u.value), c.value = "loaded", n("load", ((z = u.value) == null ? void 0 : z.currentSrc) || f.value.src));
    }
    function y() {
      var z;
      l.isUnmounted || (c.value = "error", n("error", ((z = u.value) == null ? void 0 : z.currentSrc) || f.value.src));
    }
    function C() {
      const z = u.value;
      z && (s.value = z.currentSrc || z.src);
    }
    let M = -1;
    pt(() => {
      clearTimeout(M);
    });
    function p(z) {
      let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const k = () => {
        if (clearTimeout(M), l.isUnmounted) return;
        const {
          naturalHeight: G,
          naturalWidth: F
        } = z;
        G || F ? (d.value = F, h.value = G) : !z.complete && c.value === "loading" && I != null ? M = window.setTimeout(k, I) : (z.currentSrc.endsWith(".svg") || z.currentSrc.startsWith("data:image/svg+xml")) && (d.value = 1, h.value = 1);
      };
      k();
    }
    const b = O(() => ({
      "v-img__img--cover": t.cover,
      "v-img__img--contain": !t.cover
    })), P = () => {
      var k;
      if (!f.value.src || c.value === "idle") return null;
      const z = w("img", {
        class: te(["v-img__img", b.value]),
        style: {
          objectPosition: t.position
        },
        crossorigin: t.crossorigin,
        src: f.value.src,
        srcset: f.value.srcset,
        alt: t.alt,
        referrerpolicy: t.referrerpolicy,
        draggable: t.draggable,
        sizes: t.sizes,
        ref: u,
        onLoad: v,
        onError: y
      }, null), I = (k = i.sources) == null ? void 0 : k.call(i);
      return S(Jn, {
        transition: t.transition,
        appear: !0
      }, {
        default: () => [it(I ? w("picture", {
          class: "v-img__picture"
        }, [I, z]) : z, [[Pi, c.value === "loaded"]])]
      });
    }, x = () => S(Jn, {
      transition: t.transition
    }, {
      default: () => [f.value.lazySrc && c.value !== "loaded" && w("img", {
        class: te(["v-img__img", "v-img__img--preload", b.value]),
        style: {
          objectPosition: t.position
        },
        crossorigin: t.crossorigin,
        src: f.value.lazySrc,
        alt: t.alt,
        referrerpolicy: t.referrerpolicy,
        draggable: t.draggable
      }, null)]
    }), _ = () => i.placeholder ? S(Jn, {
      transition: t.transition,
      appear: !0
    }, {
      default: () => [(c.value === "loading" || c.value === "error" && !i.error) && w("div", {
        class: "v-img__placeholder"
      }, [i.placeholder()])]
    }) : null, T = () => i.error ? S(Jn, {
      transition: t.transition,
      appear: !0
    }, {
      default: () => [c.value === "error" && w("div", {
        class: "v-img__error"
      }, [i.error()])]
    }) : null, B = () => t.gradient ? w("div", {
      class: "v-img__gradient",
      style: {
        backgroundImage: `linear-gradient(${t.gradient})`
      }
    }, null) : null, L = Q(!1);
    {
      const z = ie(g, (I) => {
        I && (requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            L.value = !0;
          });
        }), z());
      });
    }
    return le(() => {
      const z = gc.filterProps(t);
      return it(S(gc, oe({
        class: ["v-img", {
          "v-img--absolute": t.absolute,
          "v-img--booting": !L.value
        }, a.value, r.value, t.class],
        style: [{
          width: he(t.width === "auto" ? d.value : t.width)
        }, o.value, t.style]
      }, z, {
        aspectRatio: g.value,
        "aria-label": t.alt,
        role: t.alt ? "img" : void 0
      }), {
        additional: () => w(pe, null, [S(P, null, null), S(x, null, null), S(B, null, null), S(_, null, null), S(T, null, null)]),
        default: i.default
      }), [[Ca, {
        handler: m,
        options: t.options
      }, null, {
        once: !0
      }]]);
    }), {
      currentSrc: s,
      image: u,
      state: c,
      naturalWidth: d,
      naturalHeight: h
    };
  }
}), vn = U({
  border: [Boolean, Number, String]
}, "border");
function yn(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : On();
  return {
    borderClasses: E(() => {
      const i = t.border;
      return i === !0 || i === "" ? `${e}--border` : typeof i == "string" || i === 0 ? String(i).split(" ").map((a) => `border-${a}`) : [];
    })
  };
}
const ry = [null, "default", "comfortable", "compact"], Dn = U({
  density: {
    type: String,
    default: "default",
    validator: (t) => ry.includes(t)
  }
}, "density");
function oi(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : On();
  return {
    densityClasses: O(() => `${e}--density-${t.density}`)
  };
}
const ly = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function To(t, e) {
  return w(pe, null, [t && w("span", {
    key: "overlay",
    class: te(`${e}__overlay`)
  }, null), w("span", {
    key: "underlay",
    class: te(`${e}__underlay`)
  }, null)]);
}
const wi = U({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (t) => ly.includes(t)
  }
}, "variant");
function wo(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : On();
  const n = O(() => {
    const {
      variant: o
    } = Vn(t);
    return `${e}--variant-${o}`;
  }), {
    colorClasses: i,
    colorStyles: a
  } = Vs(() => {
    const {
      variant: o,
      color: r
    } = Vn(t);
    return {
      [["elevated", "flat"].includes(o) ? "background" : "text"]: r
    };
  });
  return {
    colorClasses: i,
    colorStyles: a,
    variantClasses: n
  };
}
const sy = U({
  start: Boolean,
  end: Boolean,
  icon: Pe,
  image: String,
  text: String,
  ...vn(),
  ...ve(),
  ...Dn(),
  ...Tt(),
  ...xo(),
  ...Oe(),
  ...Ue(),
  ...wi({
    variant: "flat"
  })
}, "VAvatar"), bi = ee()({
  name: "VAvatar",
  props: sy(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      themeClasses: i
    } = et(t), {
      borderClasses: a
    } = yn(t), {
      colorClasses: o,
      colorStyles: r,
      variantClasses: l
    } = wo(t), {
      densityClasses: s
    } = oi(t), {
      roundedClasses: u
    } = wt(t), {
      sizeClasses: c,
      sizeStyles: d
    } = Po(t);
    return le(() => S(t.tag, {
      class: te(["v-avatar", {
        "v-avatar--start": t.start,
        "v-avatar--end": t.end
      }, i.value, a.value, o.value, s.value, u.value, c.value, l.value, t.class]),
      style: re([r.value, d.value, t.style])
    }, {
      default: () => [n.default ? S(We, {
        key: "content-defaults",
        defaults: {
          VImg: {
            cover: !0,
            src: t.image
          },
          VIcon: {
            icon: t.icon
          }
        }
      }, {
        default: () => [n.default()]
      }) : t.image ? S(nn, {
        key: "image",
        src: t.image,
        alt: "",
        cover: !0
      }, null) : t.icon ? S(Be, {
        key: "icon",
        icon: t.icon
      }, null) : t.text, To(!1, "v-avatar")]
    })), {};
  }
}), uy = U({
  text: String,
  onClick: Bt(),
  ...ve(),
  ...Ue()
}, "VLabel"), Ph = ee()({
  name: "VLabel",
  props: uy(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return le(() => {
      var i;
      return w("label", {
        class: te(["v-label", {
          "v-label--clickable": !!t.onClick
        }, t.class]),
        style: re(t.style),
        onClick: t.onClick
      }, [t.text, (i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
});
function Nt(t, e) {
  let n;
  function i() {
    n = Ms(), n.run(() => e.length ? e(() => {
      n == null || n.stop(), i();
    }) : e());
  }
  ie(t, (a) => {
    a && !n ? i() : a || (n == null || n.stop(), n = void 0);
  }, {
    immediate: !0
  }), _t(() => {
    n == null || n.stop();
  });
}
function Xe(t, e, n) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (d) => d, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (d) => d;
  const o = Qe("useProxiedModel"), r = Z(t[e] !== void 0 ? t[e] : n), l = Gi(e), u = l !== e ? E(() => {
    var d, h, f, g;
    return t[e], !!(((d = o.vnode.props) != null && d.hasOwnProperty(e) || (h = o.vnode.props) != null && h.hasOwnProperty(l)) && ((f = o.vnode.props) != null && f.hasOwnProperty(`onUpdate:${e}`) || (g = o.vnode.props) != null && g.hasOwnProperty(`onUpdate:${l}`)));
  }) : E(() => {
    var d, h;
    return t[e], !!((d = o.vnode.props) != null && d.hasOwnProperty(e) && ((h = o.vnode.props) != null && h.hasOwnProperty(`onUpdate:${e}`)));
  });
  Nt(() => !u.value, () => {
    ie(() => t[e], (d) => {
      r.value = d;
    });
  });
  const c = E({
    get() {
      const d = t[e];
      return i(u.value ? d : r.value);
    },
    set(d) {
      const h = a(d), f = lt(u.value ? t[e] : r.value);
      f === h || i(f) === d || (r.value = h, o == null || o.emit(`update:${e}`, h));
    }
  });
  return Object.defineProperty(c, "externalValue", {
    get: () => u.value ? t[e] : r.value
  }), c;
}
const Th = Symbol.for("vuetify:selection-control-group"), wh = U({
  color: String,
  disabled: {
    type: Boolean,
    default: null
  },
  defaultsTarget: String,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: Pe,
  trueIcon: Pe,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: {
    type: Boolean,
    default: null
  },
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: en
  },
  ...ve(),
  ...Dn(),
  ...Ue()
}, "SelectionControlGroup"), cy = U({
  ...wh({
    defaultsTarget: "VSelectionControl"
  })
}, "VSelectionControlGroup");
ee()({
  name: "VSelectionControlGroup",
  props: cy(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Xe(t, "modelValue"), a = Ti(), o = O(() => t.id || `v-selection-control-group-${a}`), r = O(() => t.name || o.value), l = /* @__PURE__ */ new Set();
    return ht(Th, {
      modelValue: i,
      forceUpdate: () => {
        l.forEach((s) => s());
      },
      onForceUpdate: (s) => {
        l.add(s), _t(() => {
          l.delete(s);
        });
      }
    }), ai({
      [t.defaultsTarget]: {
        color: O(() => t.color),
        disabled: O(() => t.disabled),
        density: O(() => t.density),
        error: O(() => t.error),
        inline: O(() => t.inline),
        modelValue: i,
        multiple: O(() => !!t.multiple || t.multiple == null && Array.isArray(i.value)),
        name: r,
        falseIcon: O(() => t.falseIcon),
        trueIcon: O(() => t.trueIcon),
        readonly: O(() => t.readonly),
        ripple: O(() => t.ripple),
        type: O(() => t.type),
        valueComparator: O(() => t.valueComparator)
      }
    }), le(() => {
      var s;
      return w("div", {
        class: te(["v-selection-control-group", {
          "v-selection-control-group--inline": t.inline
        }, t.class]),
        style: re(t.style),
        role: t.type === "radio" ? "radiogroup" : void 0
      }, [(s = n.default) == null ? void 0 : s.call(n)]);
    }), {};
  }
});
const Hl = Symbol("rippleStop"), dy = 80;
function mc(t, e) {
  t.style.transform = e, t.style.webkitTransform = e;
}
function Zl(t) {
  return t.constructor.name === "TouchEvent";
}
function Eh(t) {
  return t.constructor.name === "KeyboardEvent";
}
const hy = function(t, e) {
  var d;
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = 0, a = 0;
  if (!Eh(t)) {
    const h = e.getBoundingClientRect(), f = Zl(t) ? t.touches[t.touches.length - 1] : t;
    i = f.clientX - h.left, a = f.clientY - h.top;
  }
  let o = 0, r = 0.3;
  (d = e._ripple) != null && d.circle ? (r = 0.15, o = e.clientWidth / 2, o = n.center ? o : o + Math.sqrt((i - o) ** 2 + (a - o) ** 2) / 4) : o = Math.sqrt(e.clientWidth ** 2 + e.clientHeight ** 2) / 2;
  const l = `${(e.clientWidth - o * 2) / 2}px`, s = `${(e.clientHeight - o * 2) / 2}px`, u = n.center ? l : `${i - o}px`, c = n.center ? s : `${a - o}px`;
  return {
    radius: o,
    scale: r,
    x: u,
    y: c,
    centerX: l,
    centerY: s
  };
}, dr = {
  /* eslint-disable max-statements */
  show(t, e) {
    var f;
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!((f = e == null ? void 0 : e._ripple) != null && f.enabled))
      return;
    const i = document.createElement("span"), a = document.createElement("span");
    i.appendChild(a), i.className = "v-ripple__container", n.class && (i.className += ` ${n.class}`);
    const {
      radius: o,
      scale: r,
      x: l,
      y: s,
      centerX: u,
      centerY: c
    } = hy(t, e, n), d = `${o * 2}px`;
    a.className = "v-ripple__animation", a.style.width = d, a.style.height = d, e.appendChild(i);
    const h = window.getComputedStyle(e);
    h && h.position === "static" && (e.style.position = "relative", e.dataset.previousPosition = "static"), a.classList.add("v-ripple__animation--enter"), a.classList.add("v-ripple__animation--visible"), mc(a, `translate(${l}, ${s}) scale3d(${r},${r},${r})`), a.dataset.activated = String(performance.now()), requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        a.classList.remove("v-ripple__animation--enter"), a.classList.add("v-ripple__animation--in"), mc(a, `translate(${u}, ${c}) scale3d(1,1,1)`);
      });
    });
  },
  hide(t) {
    var o;
    if (!((o = t == null ? void 0 : t._ripple) != null && o.enabled)) return;
    const e = t.getElementsByClassName("v-ripple__animation");
    if (e.length === 0) return;
    const n = e[e.length - 1];
    if (n.dataset.isHiding) return;
    n.dataset.isHiding = "true";
    const i = performance.now() - Number(n.dataset.activated), a = Math.max(250 - i, 0);
    setTimeout(() => {
      n.classList.remove("v-ripple__animation--in"), n.classList.add("v-ripple__animation--out"), setTimeout(() => {
        var l;
        t.getElementsByClassName("v-ripple__animation").length === 1 && t.dataset.previousPosition && (t.style.position = t.dataset.previousPosition, delete t.dataset.previousPosition), ((l = n.parentNode) == null ? void 0 : l.parentNode) === t && t.removeChild(n.parentNode);
      }, 300);
    }, a);
  }
};
function Ah(t) {
  return typeof t > "u" || !!t;
}
function to(t) {
  const e = {}, n = t.currentTarget;
  if (!(!(n != null && n._ripple) || n._ripple.touched || t[Hl])) {
    if (t[Hl] = !0, Zl(t))
      n._ripple.touched = !0, n._ripple.isTouch = !0;
    else if (n._ripple.isTouch) return;
    if (e.center = n._ripple.centered || Eh(t), n._ripple.class && (e.class = n._ripple.class), Zl(t)) {
      if (n._ripple.showTimerCommit) return;
      n._ripple.showTimerCommit = () => {
        dr.show(t, n, e);
      }, n._ripple.showTimer = window.setTimeout(() => {
        var i;
        (i = n == null ? void 0 : n._ripple) != null && i.showTimerCommit && (n._ripple.showTimerCommit(), n._ripple.showTimerCommit = null);
      }, dy);
    } else
      dr.show(t, n, e);
  }
}
function vc(t) {
  t[Hl] = !0;
}
function Ot(t) {
  const e = t.currentTarget;
  if (e != null && e._ripple) {
    if (window.clearTimeout(e._ripple.showTimer), t.type === "touchend" && e._ripple.showTimerCommit) {
      e._ripple.showTimerCommit(), e._ripple.showTimerCommit = null, e._ripple.showTimer = window.setTimeout(() => {
        Ot(t);
      });
      return;
    }
    window.setTimeout(() => {
      e._ripple && (e._ripple.touched = !1);
    }), dr.hide(e);
  }
}
function Rh(t) {
  const e = t.currentTarget;
  e != null && e._ripple && (e._ripple.showTimerCommit && (e._ripple.showTimerCommit = null), window.clearTimeout(e._ripple.showTimer));
}
let no = !1;
function yc(t, e) {
  !no && e.includes(t.key) && (no = !0, to(t));
}
function Ih(t) {
  no = !1, Ot(t);
}
function zh(t) {
  no && (no = !1, Ot(t));
}
function Lh(t, e, n) {
  const {
    value: i,
    modifiers: a
  } = e, o = Ah(i);
  o || dr.hide(t), t._ripple = t._ripple ?? {}, t._ripple.enabled = o, t._ripple.centered = a.center, t._ripple.circle = a.circle;
  const r = Nl(i) ? i : {};
  r.class && (t._ripple.class = r.class);
  const l = r.keys ?? ["Enter", "Space"];
  if (t._ripple.keyDownHandler = (s) => yc(s, l), o && !n) {
    if (a.stop) {
      t.addEventListener("touchstart", vc, {
        passive: !0
      }), t.addEventListener("mousedown", vc);
      return;
    }
    t.addEventListener("touchstart", to, {
      passive: !0
    }), t.addEventListener("touchend", Ot, {
      passive: !0
    }), t.addEventListener("touchmove", Rh, {
      passive: !0
    }), t.addEventListener("touchcancel", Ot), t.addEventListener("mousedown", to), t.addEventListener("mouseup", Ot), t.addEventListener("mouseleave", Ot), t.addEventListener("keydown", (s) => yc(s, l)), t.addEventListener("keyup", Ih), t.addEventListener("blur", zh), t.addEventListener("dragstart", Ot, {
      passive: !0
    });
  } else !o && n && Vh(t);
}
function Vh(t) {
  var e;
  t.removeEventListener("mousedown", to), t.removeEventListener("touchstart", to), t.removeEventListener("touchend", Ot), t.removeEventListener("touchmove", Rh), t.removeEventListener("touchcancel", Ot), t.removeEventListener("mouseup", Ot), t.removeEventListener("mouseleave", Ot), (e = t._ripple) != null && e.keyDownHandler && t.removeEventListener("keydown", t._ripple.keyDownHandler), t.removeEventListener("keyup", Ih), t.removeEventListener("dragstart", Ot), t.removeEventListener("blur", zh);
}
function fy(t, e) {
  Lh(t, e, !1);
}
function gy(t) {
  Vh(t), delete t._ripple;
}
function my(t, e) {
  if (e.value === e.oldValue)
    return;
  const n = Ah(e.oldValue);
  Lh(t, e, n);
}
const fn = {
  mounted: fy,
  unmounted: gy,
  updated: my
}, Bh = U({
  label: String,
  baseColor: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...ve(),
  ...wh()
}, "VSelectionControl");
function vy(t) {
  const e = Ne(Th, void 0), {
    densityClasses: n
  } = oi(t), i = Xe(t, "modelValue"), a = E(() => t.trueValue !== void 0 ? t.trueValue : t.value !== void 0 ? t.value : !0), o = E(() => t.falseValue !== void 0 ? t.falseValue : !1), r = E(() => !!t.multiple || t.multiple == null && Array.isArray(i.value)), l = E({
    get() {
      const f = e ? e.modelValue.value : i.value;
      return r.value ? Vt(f).some((g) => t.valueComparator(g, a.value)) : t.valueComparator(f, a.value);
    },
    set(f) {
      if (t.readonly) return;
      const g = f ? a.value : o.value;
      let m = g;
      r.value && (m = f ? [...Vt(i.value), g] : Vt(i.value).filter((v) => !t.valueComparator(v, a.value))), e ? e.modelValue.value = m : i.value = m;
    }
  }), {
    textColorClasses: s,
    textColorStyles: u
  } = Bn(() => {
    if (!(t.error || t.disabled))
      return l.value ? t.color : t.baseColor;
  }), {
    backgroundColorClasses: c,
    backgroundColorStyles: d
  } = xt(() => l.value && !t.error && !t.disabled ? t.color : t.baseColor), h = E(() => l.value ? t.trueIcon : t.falseIcon);
  return {
    group: e,
    densityClasses: n,
    trueValue: a,
    falseValue: o,
    model: l,
    textColorClasses: s,
    textColorStyles: u,
    backgroundColorClasses: c,
    backgroundColorStyles: d,
    icon: h
  };
}
const Cc = ee()({
  name: "VSelectionControl",
  directives: {
    vRipple: fn
  },
  inheritAttrs: !1,
  props: Bh(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      attrs: n,
      slots: i
    } = e;
    const {
      group: a,
      densityClasses: o,
      icon: r,
      model: l,
      textColorClasses: s,
      textColorStyles: u,
      backgroundColorClasses: c,
      backgroundColorStyles: d,
      trueValue: h
    } = vy(t), f = Ti(), g = Q(!1), m = Q(!1), v = Z(), y = O(() => t.id || `input-${f}`), C = O(() => !t.disabled && !t.readonly);
    a == null || a.onForceUpdate(() => {
      v.value && (v.value.checked = l.value);
    });
    function M(x) {
      C.value && (g.value = !0, ya(x.target, ":focus-visible") !== !1 && (m.value = !0));
    }
    function p() {
      g.value = !1, m.value = !1;
    }
    function b(x) {
      x.stopPropagation();
    }
    function P(x) {
      if (!C.value) {
        v.value && (v.value.checked = l.value);
        return;
      }
      t.readonly && a && Ye(() => a.forceUpdate()), l.value = x.target.checked;
    }
    return le(() => {
      var L, z;
      const x = i.label ? i.label({
        label: t.label,
        props: {
          for: y.value
        }
      }) : t.label, [_, T] = ws(n), B = w("input", oe({
        ref: v,
        checked: l.value,
        disabled: !!t.disabled,
        id: y.value,
        onBlur: p,
        onFocus: M,
        onInput: P,
        "aria-disabled": !!t.disabled,
        "aria-label": t.label,
        type: t.type,
        value: h.value,
        name: t.name,
        "aria-checked": t.type === "checkbox" ? l.value : void 0
      }, T), null);
      return w("div", oe({
        class: ["v-selection-control", {
          "v-selection-control--dirty": l.value,
          "v-selection-control--disabled": t.disabled,
          "v-selection-control--error": t.error,
          "v-selection-control--focused": g.value,
          "v-selection-control--focus-visible": m.value,
          "v-selection-control--inline": t.inline
        }, o.value, t.class]
      }, _, {
        style: t.style
      }), [w("div", {
        class: te(["v-selection-control__wrapper", s.value]),
        style: re(u.value)
      }, [(L = i.default) == null ? void 0 : L.call(i, {
        backgroundColorClasses: c,
        backgroundColorStyles: d
      }), it(w("div", {
        class: te(["v-selection-control__input"])
      }, [((z = i.input) == null ? void 0 : z.call(i, {
        model: l,
        textColorClasses: s,
        textColorStyles: u,
        backgroundColorClasses: c,
        backgroundColorStyles: d,
        inputNode: B,
        icon: r.value,
        props: {
          onFocus: M,
          onBlur: p,
          id: y.value
        }
      })) ?? w(pe, null, [r.value && S(Be, {
        key: "icon",
        icon: r.value
      }, null), B])]), [[fn, !t.disabled && !t.readonly && t.ripple, null, {
        center: !0,
        circle: !0
      }]])]), x && S(Ph, {
        for: y.value,
        onClick: b
      }, {
        default: () => [x]
      })]);
    }), {
      isFocused: g,
      input: v
    };
  }
}), yy = U({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: Pe,
    default: "$checkboxIndeterminate"
  },
  ...Bh({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "VCheckboxBtn"), Fh = ee()({
  name: "VCheckboxBtn",
  props: yy(),
  emits: {
    "update:modelValue": (t) => !0,
    "update:indeterminate": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Xe(t, "indeterminate"), a = Xe(t, "modelValue");
    function o(s) {
      i.value && (i.value = !1);
    }
    const r = O(() => i.value ? t.indeterminateIcon : t.falseIcon), l = O(() => i.value ? t.indeterminateIcon : t.trueIcon);
    return le(() => {
      const s = Xi(Cc.filterProps(t), ["modelValue"]);
      return S(Cc, oe(s, {
        modelValue: a.value,
        "onUpdate:modelValue": [(u) => a.value = u, o],
        class: ["v-checkbox-btn", t.class],
        style: t.style,
        type: "checkbox",
        falseIcon: r.value,
        trueIcon: l.value,
        "aria-checked": i.value ? "mixed" : void 0
      }), n);
    }), {};
  }
}), kh = Symbol.for("vuetify:locale");
function Aa() {
  const t = Ne(kh);
  if (!t) throw new Error("[Vuetify] Could not find injected locale instance");
  return t;
}
function Wt() {
  const t = Ne(kh);
  if (!t) throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: t.isRtl,
    rtlClasses: t.rtlClasses
  };
}
function Oh(t) {
  const {
    t: e
  } = Aa();
  function n(i) {
    let {
      name: a,
      color: o,
      ...r
    } = i;
    const l = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[a], s = t[`onClick:${a}`];
    function u(d) {
      d.key !== "Enter" && d.key !== " " || (d.preventDefault(), d.stopPropagation(), As(s, new PointerEvent("click", d)));
    }
    const c = s && l ? e(`$vuetify.input.${l}`, t.label ?? "") : void 0;
    return S(Be, oe({
      icon: t[`${a}Icon`],
      "aria-label": c,
      onClick: s,
      onKeydown: u,
      color: o
    }, r), null);
  }
  return {
    InputIcon: n
  };
}
const Cy = U({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function $t(t, e, n) {
  return ee()({
    name: t,
    props: Cy({
      mode: n,
      origin: e
    }),
    setup(i, a) {
      let {
        slots: o
      } = a;
      const r = {
        onBeforeEnter(l) {
          i.origin && (l.style.transformOrigin = i.origin);
        },
        onLeave(l) {
          if (i.leaveAbsolute) {
            const {
              offsetTop: s,
              offsetLeft: u,
              offsetWidth: c,
              offsetHeight: d
            } = l;
            l._transitionInitialStyles = {
              position: l.style.position,
              top: l.style.top,
              left: l.style.left,
              width: l.style.width,
              height: l.style.height
            }, l.style.position = "absolute", l.style.top = `${s}px`, l.style.left = `${u}px`, l.style.width = `${c}px`, l.style.height = `${d}px`;
          }
          i.hideOnLeave && l.style.setProperty("display", "none", "important");
        },
        onAfterLeave(l) {
          if (i.leaveAbsolute && (l != null && l._transitionInitialStyles)) {
            const {
              position: s,
              top: u,
              left: c,
              width: d,
              height: h
            } = l._transitionInitialStyles;
            delete l._transitionInitialStyles, l.style.position = s || "", l.style.top = u || "", l.style.left = c || "", l.style.width = d || "", l.style.height = h || "";
          }
        }
      };
      return () => {
        const l = i.group ? bs : Si;
        return Ta(l, {
          name: i.disabled ? "" : t,
          css: !i.disabled,
          ...i.group ? void 0 : {
            mode: i.mode
          },
          ...i.disabled ? {} : r
        }, o.default);
      };
    }
  });
}
function Dh(t, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return ee()({
    name: t,
    props: {
      mode: {
        type: String,
        default: n
      },
      disabled: Boolean,
      group: Boolean
    },
    setup(i, a) {
      let {
        slots: o
      } = a;
      const r = i.group ? bs : Si;
      return () => Ta(r, {
        name: i.disabled ? "" : t,
        css: !i.disabled,
        // mode: props.mode, // TODO: vuejs/vue-next#3104
        ...i.disabled ? {} : e
      }, o.default);
    }
  });
}
function Gh() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? "width" : "height", i = Ss(`offset-${n}`);
  return {
    onBeforeEnter(r) {
      r._parent = r.parentNode, r._initialStyle = {
        transition: r.style.transition,
        overflow: r.style.overflow,
        [n]: r.style[n]
      };
    },
    onEnter(r) {
      const l = r._initialStyle;
      if (!l) return;
      r.style.setProperty("transition", "none", "important"), r.style.overflow = "hidden";
      const s = `${r[i]}px`;
      r.style[n] = "0", r.offsetHeight, r.style.transition = l.transition, t && r._parent && r._parent.classList.add(t), requestAnimationFrame(() => {
        r.style[n] = s;
      });
    },
    onAfterEnter: o,
    onEnterCancelled: o,
    onLeave(r) {
      r._initialStyle = {
        transition: "",
        overflow: r.style.overflow,
        [n]: r.style[n]
      }, r.style.overflow = "hidden", r.style[n] = `${r[i]}px`, r.offsetHeight, requestAnimationFrame(() => r.style[n] = "0");
    },
    onAfterLeave: a,
    onLeaveCancelled: a
  };
  function a(r) {
    t && r._parent && r._parent.classList.remove(t), o(r);
  }
  function o(r) {
    if (!r._initialStyle) return;
    const l = r._initialStyle[n];
    r.style.overflow = r._initialStyle.overflow, l != null && (r.style[n] = l), delete r._initialStyle;
  }
}
const py = U({
  target: [Object, Array]
}, "v-dialog-transition"), gl = /* @__PURE__ */ new WeakMap(), Nh = ee()({
  name: "VDialogTransition",
  props: py(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = {
      onBeforeEnter(a) {
        a.style.pointerEvents = "none", a.style.visibility = "hidden";
      },
      async onEnter(a, o) {
        var f;
        await new Promise((g) => requestAnimationFrame(g)), await new Promise((g) => requestAnimationFrame(g)), a.style.visibility = "";
        const r = _c(t.target, a), {
          x: l,
          y: s,
          sx: u,
          sy: c,
          speed: d
        } = r;
        gl.set(a, r);
        const h = sa(a, [{
          transform: `translate(${l}px, ${s}px) scale(${u}, ${c})`,
          opacity: 0
        }, {}], {
          duration: 225 * d,
          easing: jv
        });
        (f = pc(a)) == null || f.forEach((g) => {
          sa(g, [{
            opacity: 0
          }, {
            opacity: 0,
            offset: 0.33
          }, {}], {
            duration: 450 * d,
            easing: ur
          });
        }), h.finished.then(() => o());
      },
      onAfterEnter(a) {
        a.style.removeProperty("pointer-events");
      },
      onBeforeLeave(a) {
        a.style.pointerEvents = "none";
      },
      async onLeave(a, o) {
        var f;
        await new Promise((g) => requestAnimationFrame(g));
        let r;
        !gl.has(a) || Array.isArray(t.target) || t.target.offsetParent || t.target.getClientRects().length ? r = _c(t.target, a) : r = gl.get(a);
        const {
          x: l,
          y: s,
          sx: u,
          sy: c,
          speed: d
        } = r;
        sa(a, [{}, {
          transform: `translate(${l}px, ${s}px) scale(${u}, ${c})`,
          opacity: 0
        }], {
          duration: 125 * d,
          easing: Hv
        }).finished.then(() => o()), (f = pc(a)) == null || f.forEach((g) => {
          sa(g, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 250 * d,
            easing: ur
          });
        });
      },
      onAfterLeave(a) {
        a.style.removeProperty("pointer-events");
      }
    };
    return () => t.target ? S(Si, oe({
      name: "dialog-transition"
    }, i, {
      css: !1
    }), n) : S(Si, {
      name: "dialog-transition"
    }, n);
  }
});
function pc(t) {
  var n;
  const e = (n = t.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : n.children;
  return e && [...e];
}
function _c(t, e) {
  const n = vh(t), i = zs(e), [a, o] = getComputedStyle(e).transformOrigin.split(" ").map((y) => parseFloat(y)), [r, l] = getComputedStyle(e).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let s = n.left + n.width / 2;
  r === "left" || l === "left" ? s -= n.width / 2 : (r === "right" || l === "right") && (s += n.width / 2);
  let u = n.top + n.height / 2;
  r === "top" || l === "top" ? u -= n.height / 2 : (r === "bottom" || l === "bottom") && (u += n.height / 2);
  const c = n.width / i.width, d = n.height / i.height, h = Math.max(1, c, d), f = c / h || 0, g = d / h || 0, m = i.width * i.height / (window.innerWidth * window.innerHeight), v = m > 0.12 ? Math.min(1.5, (m - 0.12) * 10 + 1) : 1;
  return {
    x: s - (a + i.left),
    y: u - (o + i.top),
    sx: f,
    sy: g,
    speed: v
  };
}
$t("fab-transition", "center center", "out-in");
$t("dialog-bottom-transition");
$t("dialog-top-transition");
const Sc = $t("fade-transition");
$t("scale-transition");
$t("scroll-x-transition");
$t("scroll-x-reverse-transition");
$t("scroll-y-transition");
$t("scroll-y-reverse-transition");
$t("slide-x-transition");
$t("slide-x-reverse-transition");
const Wh = $t("slide-y-transition");
$t("slide-y-reverse-transition");
const Bs = Dh("expand-transition", Gh()), $h = Dh("expand-x-transition", Gh("", !0)), _y = U({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...ve(),
  ...Ea({
    transition: {
      component: Wh,
      leaveAbsolute: !0,
      group: !0
    }
  })
}, "VMessages"), Sy = ee()({
  name: "VMessages",
  props: _y(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = E(() => Vt(t.messages)), {
      textColorClasses: a,
      textColorStyles: o
    } = Bn(() => t.color);
    return le(() => S(Jn, {
      transition: t.transition,
      tag: "div",
      class: te(["v-messages", a.value, t.class]),
      style: re([o.value, t.style])
    }, {
      default: () => [t.active && i.value.map((r, l) => w("div", {
        class: "v-messages__message",
        key: `${l}-${i.value}`
      }, [n.message ? n.message({
        message: r
      }) : r]))]
    })), {};
  }
}), Xh = U({
  focused: Boolean,
  "onUpdate:focused": Bt()
}, "focus");
function Fs(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : On();
  const n = Xe(t, "focused"), i = O(() => ({
    [`${e}--focused`]: n.value
  }));
  function a() {
    n.value = !0;
  }
  function o() {
    n.value = !1;
  }
  return {
    focusClasses: i,
    isFocused: n,
    focus: a,
    blur: o
  };
}
const Uh = Symbol.for("vuetify:form"), by = U({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function My(t) {
  const e = Xe(t, "modelValue"), n = O(() => t.disabled), i = O(() => t.readonly), a = Q(!1), o = Z([]), r = Z([]);
  async function l() {
    const c = [];
    let d = !0;
    r.value = [], a.value = !0;
    for (const h of o.value) {
      const f = await h.validate();
      if (f.length > 0 && (d = !1, c.push({
        id: h.id,
        errorMessages: f
      })), !d && t.fastFail) break;
    }
    return r.value = c, a.value = !1, {
      valid: d,
      errors: r.value
    };
  }
  function s() {
    o.value.forEach((c) => c.reset());
  }
  function u() {
    o.value.forEach((c) => c.resetValidation());
  }
  return ie(o, () => {
    let c = 0, d = 0;
    const h = [];
    for (const f of o.value)
      f.isValid === !1 ? (d++, h.push({
        id: f.id,
        errorMessages: f.errorMessages
      })) : f.isValid === !0 && c++;
    r.value = h, e.value = d > 0 ? !1 : c === o.value.length ? !0 : null;
  }, {
    deep: !0,
    flush: "post"
  }), ht(Uh, {
    register: (c) => {
      let {
        id: d,
        vm: h,
        validate: f,
        reset: g,
        resetValidation: m
      } = c;
      o.value.some((v) => v.id === d) && In(`Duplicate input name "${d}"`), o.value.push({
        id: d,
        validate: f,
        reset: g,
        resetValidation: m,
        vm: Gm(h),
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (c) => {
      o.value = o.value.filter((d) => d.id !== c);
    },
    update: (c, d, h) => {
      const f = o.value.find((g) => g.id === c);
      f && (f.isValid = d, f.errorMessages = h);
    },
    isDisabled: n,
    isReadonly: i,
    isValidating: a,
    isValid: e,
    items: o,
    validateOn: O(() => t.validateOn)
  }), {
    errors: r,
    isDisabled: n,
    isReadonly: i,
    isValidating: a,
    isValid: e,
    items: o,
    validate: l,
    reset: s,
    resetValidation: u
  };
}
function ks(t) {
  const e = Ne(Uh, null);
  return {
    ...e,
    isReadonly: E(() => !!((t == null ? void 0 : t.readonly) ?? (e == null ? void 0 : e.isReadonly.value))),
    isDisabled: E(() => !!((t == null ? void 0 : t.disabled) ?? (e == null ? void 0 : e.isDisabled.value)))
  };
}
const xy = Symbol.for("vuetify:rules");
function Py(t) {
  const e = Ne(xy, null);
  return e ? e(t) : O(t);
}
const Ty = U({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...Xh()
}, "validation");
function wy(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : On(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ti();
  const i = Xe(t, "modelValue"), a = E(() => t.validationValue === void 0 ? i.value : t.validationValue), o = ks(t), r = Py(() => t.rules), l = Z([]), s = Q(!0), u = E(() => !!(Vt(i.value === "" ? null : i.value).length || Vt(a.value === "" ? null : a.value).length)), c = E(() => {
    var p;
    return (p = t.errorMessages) != null && p.length ? Vt(t.errorMessages).concat(l.value).slice(0, Math.max(0, Number(t.maxErrors))) : l.value;
  }), d = E(() => {
    var P;
    let p = (t.validateOn ?? ((P = o.validateOn) == null ? void 0 : P.value)) || "input";
    p === "lazy" && (p = "input lazy"), p === "eager" && (p = "input eager");
    const b = new Set((p == null ? void 0 : p.split(" ")) ?? []);
    return {
      input: b.has("input"),
      blur: b.has("blur") || b.has("input") || b.has("invalid-input"),
      invalidInput: b.has("invalid-input"),
      lazy: b.has("lazy"),
      eager: b.has("eager")
    };
  }), h = E(() => {
    var p;
    return t.error || (p = t.errorMessages) != null && p.length ? !1 : t.rules.length ? s.value ? l.value.length || d.value.lazy ? null : !0 : !l.value.length : !0;
  }), f = Q(!1), g = E(() => ({
    [`${e}--error`]: h.value === !1,
    [`${e}--dirty`]: u.value,
    [`${e}--disabled`]: o.isDisabled.value,
    [`${e}--readonly`]: o.isReadonly.value
  })), m = Qe("validation"), v = E(() => t.name ?? W(n));
  Rr(() => {
    var p;
    (p = o.register) == null || p.call(o, {
      id: v.value,
      vm: m,
      validate: M,
      reset: y,
      resetValidation: C
    });
  }), pt(() => {
    var p;
    (p = o.unregister) == null || p.call(o, v.value);
  }), at(async () => {
    var p;
    d.value.lazy || await M(!d.value.eager), (p = o.update) == null || p.call(o, v.value, h.value, c.value);
  }), Nt(() => d.value.input || d.value.invalidInput && h.value === !1, () => {
    ie(a, () => {
      if (a.value != null)
        M();
      else if (t.focused) {
        const p = ie(() => t.focused, (b) => {
          b || M(), p();
        });
      }
    });
  }), Nt(() => d.value.blur, () => {
    ie(() => t.focused, (p) => {
      p || M();
    });
  }), ie([h, c], () => {
    var p;
    (p = o.update) == null || p.call(o, v.value, h.value, c.value);
  });
  async function y() {
    i.value = null, await Ye(), await C();
  }
  async function C() {
    s.value = !0, d.value.lazy ? l.value = [] : await M(!d.value.eager);
  }
  async function M() {
    let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const b = [];
    f.value = !0;
    for (const P of r.value) {
      if (b.length >= Number(t.maxErrors ?? 1))
        break;
      const _ = await (typeof P == "function" ? P : () => P)(a.value);
      if (_ !== !0) {
        if (_ !== !1 && typeof _ != "string") {
          console.warn(`${_} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        b.push(_ || "");
      }
    }
    return l.value = b, f.value = !1, s.value = p, l.value;
  }
  return {
    errorMessages: c,
    isDirty: u,
    isDisabled: o.isDisabled,
    isReadonly: o.isReadonly,
    isPristine: s,
    isValid: h,
    isValidating: f,
    reset: y,
    resetValidation: C,
    validate: M,
    validationClasses: g
  };
}
const Os = U({
  id: String,
  appendIcon: Pe,
  baseColor: String,
  centerAffix: {
    type: Boolean,
    default: !0
  },
  color: String,
  glow: Boolean,
  iconColor: [Boolean, String],
  prependIcon: Pe,
  hideDetails: [Boolean, String],
  hideSpinButtons: Boolean,
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (t) => ["horizontal", "vertical"].includes(t)
  },
  "onClick:prepend": Bt(),
  "onClick:append": Bt(),
  ...ve(),
  ...Dn(),
  ...bo(ln(), ["maxWidth", "minWidth", "width"]),
  ...Ue(),
  ...Ty()
}, "VInput"), hr = ee()({
  name: "VInput",
  props: {
    ...Os()
  },
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      attrs: n,
      slots: i,
      emit: a
    } = e;
    const {
      densityClasses: o
    } = oi(t), {
      dimensionStyles: r
    } = sn(t), {
      themeClasses: l
    } = et(t), {
      rtlClasses: s
    } = Wt(), {
      InputIcon: u
    } = Oh(t), c = Ti(), d = E(() => t.id || `input-${c}`), {
      errorMessages: h,
      isDirty: f,
      isDisabled: g,
      isReadonly: m,
      isPristine: v,
      isValid: y,
      isValidating: C,
      reset: M,
      resetValidation: p,
      validate: b,
      validationClasses: P
    } = wy(t, "v-input", d), x = E(() => {
      var k;
      return (k = t.errorMessages) != null && k.length || !v.value && h.value.length ? h.value : t.hint && (t.persistentHint || t.focused) ? t.hint : t.messages;
    }), _ = O(() => x.value.length > 0), T = O(() => !t.hideDetails || t.hideDetails === "auto" && (_.value || !!i.details)), B = E(() => T.value ? `${d.value}-messages` : void 0), L = E(() => ({
      id: d,
      messagesId: B,
      isDirty: f,
      isDisabled: g,
      isReadonly: m,
      isPristine: v,
      isValid: y,
      isValidating: C,
      hasDetails: T,
      reset: M,
      resetValidation: p,
      validate: b
    })), z = O(() => t.error || t.disabled ? void 0 : t.focused ? t.color : t.baseColor), I = O(() => {
      if (t.iconColor)
        return t.iconColor === !0 ? z.value : t.iconColor;
    });
    return le(() => {
      var F, q, j, ne;
      const k = !!(i.prepend || t.prependIcon), G = !!(i.append || t.appendIcon);
      return w("div", {
        class: te(["v-input", `v-input--${t.direction}`, {
          "v-input--center-affix": t.centerAffix,
          "v-input--focused": t.focused,
          "v-input--glow": t.glow,
          "v-input--hide-spin-buttons": t.hideSpinButtons
        }, o.value, l.value, s.value, P.value, t.class]),
        style: re([r.value, t.style])
      }, [k && w("div", {
        key: "prepend",
        class: "v-input__prepend"
      }, [(F = i.prepend) == null ? void 0 : F.call(i, L.value), t.prependIcon && S(u, {
        key: "prepend-icon",
        name: "prepend",
        color: I.value
      }, null)]), i.default && w("div", {
        class: "v-input__control"
      }, [(q = i.default) == null ? void 0 : q.call(i, L.value)]), G && w("div", {
        key: "append",
        class: "v-input__append"
      }, [t.appendIcon && S(u, {
        key: "append-icon",
        name: "append",
        color: I.value
      }, null), (j = i.append) == null ? void 0 : j.call(i, L.value)]), T.value && w("div", {
        id: B.value,
        class: "v-input__details",
        role: "alert",
        "aria-live": "polite"
      }, [S(Sy, {
        active: _.value,
        messages: x.value
      }, {
        message: i.message
      }), (ne = i.details) == null ? void 0 : ne.call(i, L.value)])]);
    }), {
      reset: M,
      resetValidation: p,
      validate: b,
      isValid: y,
      errorMessages: h
    };
  }
}), ml = Symbol("Forwarded refs");
function vl(t, e) {
  let n = t;
  for (; n; ) {
    const i = Reflect.getOwnPropertyDescriptor(n, e);
    if (i) return i;
    n = Object.getPrototypeOf(n);
  }
}
function Ra(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
    n[i - 1] = arguments[i];
  return t[ml] = n, new Proxy(t, {
    get(a, o) {
      if (Reflect.has(a, o))
        return Reflect.get(a, o);
      if (!(typeof o == "symbol" || o.startsWith("$") || o.startsWith("__"))) {
        for (const r of n)
          if (r.value && Reflect.has(r.value, o)) {
            const l = Reflect.get(r.value, o);
            return typeof l == "function" ? l.bind(r.value) : l;
          }
      }
    },
    has(a, o) {
      if (Reflect.has(a, o))
        return !0;
      if (typeof o == "symbol" || o.startsWith("$") || o.startsWith("__")) return !1;
      for (const r of n)
        if (r.value && Reflect.has(r.value, o))
          return !0;
      return !1;
    },
    set(a, o, r) {
      if (Reflect.has(a, o))
        return Reflect.set(a, o, r);
      if (typeof o == "symbol" || o.startsWith("$") || o.startsWith("__")) return !1;
      for (const l of n)
        if (l.value && Reflect.has(l.value, o))
          return Reflect.set(l.value, o, r);
      return !1;
    },
    getOwnPropertyDescriptor(a, o) {
      var l;
      const r = Reflect.getOwnPropertyDescriptor(a, o);
      if (r) return r;
      if (!(typeof o == "symbol" || o.startsWith("$") || o.startsWith("__"))) {
        for (const s of n) {
          if (!s.value) continue;
          const u = vl(s.value, o) ?? ("_" in s.value ? vl((l = s.value._) == null ? void 0 : l.setupState, o) : void 0);
          if (u) return u;
        }
        for (const s of n) {
          const u = s.value && s.value[ml];
          if (!u) continue;
          const c = u.slice();
          for (; c.length; ) {
            const d = c.shift(), h = vl(d.value, o);
            if (h) return h;
            const f = d.value && d.value[ml];
            f && c.push(...f);
          }
        }
      }
    }
  });
}
const Lr = ["sm", "md", "lg", "xl", "xxl"], Ey = Symbol.for("vuetify:display"), Yh = U({
  mobile: {
    type: Boolean,
    default: !1
  },
  mobileBreakpoint: [Number, String]
}, "display");
function Vr() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    mobile: null
  }, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : On();
  const n = Ne(Ey);
  if (!n) throw new Error("Could not find Vuetify display injection");
  const i = E(() => t.mobile ? !0 : typeof t.mobileBreakpoint == "number" ? n.width.value < t.mobileBreakpoint : t.mobileBreakpoint ? n.width.value < n.thresholds.value[t.mobileBreakpoint] : t.mobile === null ? n.mobile.value : !1), a = O(() => e ? {
    [`${e}--mobile`]: i.value
  } : {});
  return {
    ...n,
    displayClasses: a,
    mobile: i
  };
}
const Ay = Symbol.for("vuetify:goto");
function Ry() {
  return {
    container: void 0,
    duration: 300,
    layout: !1,
    offset: 0,
    easing: "easeInOutCubic",
    patterns: {
      linear: (t) => t,
      easeInQuad: (t) => t ** 2,
      easeOutQuad: (t) => t * (2 - t),
      easeInOutQuad: (t) => t < 0.5 ? 2 * t ** 2 : -1 + (4 - 2 * t) * t,
      easeInCubic: (t) => t ** 3,
      easeOutCubic: (t) => --t ** 3 + 1,
      easeInOutCubic: (t) => t < 0.5 ? 4 * t ** 3 : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
      easeInQuart: (t) => t ** 4,
      easeOutQuart: (t) => 1 - --t ** 4,
      easeInOutQuart: (t) => t < 0.5 ? 8 * t ** 4 : 1 - 8 * --t ** 4,
      easeInQuint: (t) => t ** 5,
      easeOutQuint: (t) => 1 + --t ** 5,
      easeInOutQuint: (t) => t < 0.5 ? 16 * t ** 5 : 1 + 16 * --t ** 5
    }
  };
}
function Iy(t) {
  return Ds(t) ?? (document.scrollingElement || document.body);
}
function Ds(t) {
  return typeof t == "string" ? document.querySelector(t) : lh(t);
}
function yl(t, e, n) {
  if (typeof t == "number") return e && n ? -t : t;
  let i = Ds(t), a = 0;
  for (; i; )
    a += e ? i.offsetLeft : i.offsetTop, i = i.offsetParent;
  return a;
}
async function bc(t, e, n, i) {
  const a = n ? "scrollLeft" : "scrollTop", o = qn((i == null ? void 0 : i.options) ?? Ry(), e), r = i == null ? void 0 : i.rtl.value, l = (typeof t == "number" ? t : Ds(t)) ?? 0, s = o.container === "parent" && l instanceof HTMLElement ? l.parentElement : Iy(o.container), u = typeof o.easing == "function" ? o.easing : o.patterns[o.easing];
  if (!u) throw new TypeError(`Easing function "${o.easing}" not found.`);
  let c;
  if (typeof l == "number")
    c = yl(l, n, r);
  else if (c = yl(l, n, r) - yl(s, n, r), o.layout) {
    const g = window.getComputedStyle(l).getPropertyValue("--v-layout-top");
    g && (c -= parseInt(g, 10));
  }
  c += o.offset, c = Ly(s, c, !!r, !!n);
  const d = s[a] ?? 0;
  if (c === d) return Promise.resolve(c);
  const h = performance.now();
  return new Promise((f) => requestAnimationFrame(function g(m) {
    const y = (m - h) / o.duration, C = Math.floor(d + (c - d) * u(Gt(y, 0, 1)));
    if (s[a] = C, y >= 1 && Math.abs(C - s[a]) < 10)
      return f(c);
    if (y > 2)
      return In("Scroll target is not reachable"), f(s[a]);
    requestAnimationFrame(g);
  }));
}
function zy() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const e = Ne(Ay), {
    isRtl: n
  } = Wt();
  if (!e) throw new Error("[Vuetify] Could not find injected goto instance");
  const i = {
    ...e,
    // can be set via VLocaleProvider
    rtl: O(() => e.rtl.value || n.value)
  };
  async function a(o, r) {
    return bc(o, qn(t, r), !1, i);
  }
  return a.horizontal = async (o, r) => bc(o, qn(t, r), !0, i), a;
}
function Ly(t, e, n, i) {
  const {
    scrollWidth: a,
    scrollHeight: o
  } = t, [r, l] = t === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [t.offsetWidth, t.offsetHeight];
  let s, u;
  return i ? n ? (s = -(a - r), u = 0) : (s = 0, u = a - r) : (s = 0, u = o + -l), Gt(e, s, u);
}
const Br = U({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group"), Eo = U({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function Ao(t, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const i = Qe("useGroupItem");
  if (!i)
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  const a = Ti();
  ht(Symbol.for(`${e.description}:id`), a);
  const o = Ne(e, null);
  if (!o) {
    if (!n) return o;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${e.description}`);
  }
  const r = O(() => t.value), l = E(() => !!(o.disabled.value || t.disabled));
  o.register({
    id: a,
    value: r,
    disabled: l
  }, i), pt(() => {
    o.unregister(a);
  });
  const s = E(() => o.isSelected(a)), u = E(() => o.items.value[0].id === a), c = E(() => o.items.value[o.items.value.length - 1].id === a), d = E(() => s.value && [o.selectedClass.value, t.selectedClass]);
  return ie(s, (h) => {
    i.emit("group:selected", {
      value: h
    });
  }, {
    flush: "sync"
  }), {
    id: a,
    isSelected: s,
    isFirst: u,
    isLast: c,
    toggle: () => o.select(a, !s.value),
    select: (h) => o.select(a, h),
    selectedClass: d,
    value: r,
    disabled: l,
    group: o
  };
}
function Ro(t, e) {
  let n = !1;
  const i = cn([]), a = Xe(t, "modelValue", [], (h) => h == null ? [] : jh(i, Vt(h)), (h) => {
    const f = By(i, h);
    return t.multiple ? f : f[0];
  }), o = Qe("useGroup");
  function r(h, f) {
    const g = h, m = Symbol.for(`${e.description}:id`), y = la(m, o == null ? void 0 : o.vnode).indexOf(f);
    W(g.value) == null && (g.value = y, g.useIndexAsValue = !0), y > -1 ? i.splice(y, 0, g) : i.push(g);
  }
  function l(h) {
    if (n) return;
    s();
    const f = i.findIndex((g) => g.id === h);
    i.splice(f, 1);
  }
  function s() {
    const h = i.find((f) => !f.disabled);
    h && t.mandatory === "force" && !a.value.length && (a.value = [h.id]);
  }
  at(() => {
    s();
  }), pt(() => {
    n = !0;
  }), Nm(() => {
    for (let h = 0; h < i.length; h++)
      i[h].useIndexAsValue && (i[h].value = h);
  });
  function u(h, f) {
    const g = i.find((m) => m.id === h);
    if (!(f && (g != null && g.disabled)))
      if (t.multiple) {
        const m = a.value.slice(), v = m.findIndex((C) => C === h), y = ~v;
        if (f = f ?? !y, y && t.mandatory && m.length <= 1 || !y && t.max != null && m.length + 1 > t.max) return;
        v < 0 && f ? m.push(h) : v >= 0 && !f && m.splice(v, 1), a.value = m;
      } else {
        const m = a.value.includes(h);
        if (t.mandatory && m || !m && !f) return;
        a.value = f ?? !m ? [h] : [];
      }
  }
  function c(h) {
    if (t.multiple && In('This method is not supported when using "multiple" prop'), a.value.length) {
      const f = a.value[0], g = i.findIndex((y) => y.id === f);
      let m = (g + h) % i.length, v = i[m];
      for (; v.disabled && m !== g; )
        m = (m + h) % i.length, v = i[m];
      if (v.disabled) return;
      a.value = [i[m].id];
    } else {
      const f = i.find((g) => !g.disabled);
      f && (a.value = [f.id]);
    }
  }
  const d = {
    register: r,
    unregister: l,
    selected: a,
    select: u,
    disabled: O(() => t.disabled),
    prev: () => c(i.length - 1),
    next: () => c(1),
    isSelected: (h) => a.value.includes(h),
    selectedClass: O(() => t.selectedClass),
    items: O(() => i),
    getItemIndex: (h) => Vy(i, h)
  };
  return ht(e, d), d;
}
function Vy(t, e) {
  const n = jh(t, [e]);
  return n.length ? t.findIndex((i) => i.id === n[0]) : -1;
}
function jh(t, e) {
  const n = [];
  return e.forEach((i) => {
    const a = t.find((r) => en(i, r.value)), o = t[i];
    (a == null ? void 0 : a.value) != null ? n.push(a.id) : o != null && o.useIndexAsValue && n.push(o.id);
  }), n;
}
function By(t, e) {
  const n = [];
  return e.forEach((i) => {
    const a = t.findIndex((o) => o.id === i);
    if (~a) {
      const o = t[a];
      n.push(o.value != null ? o.value : a);
    }
  }), n;
}
function Wi(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
  const n = Wl(), i = Z();
  if (nt) {
    const a = new ResizeObserver((o) => {
      t == null || t(o, a), o.length && (e === "content" ? i.value = o[0].contentRect : i.value = o[0].target.getBoundingClientRect());
    });
    pt(() => {
      a.disconnect();
    }), ie(() => n.el, (o, r) => {
      r && (a.unobserve(r), i.value = void 0), o && a.observe(o);
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef: n,
    contentRect: Ir(i)
  };
}
function Fy(t) {
  let {
    selectedElement: e,
    containerElement: n,
    isRtl: i,
    isHorizontal: a
  } = t;
  const o = io(a, n), r = Hh(a, i, n), l = io(a, e), s = Zh(a, e), u = l * 0.4;
  return r > s ? s - u : r + o < s + l ? s - o + l + u : r;
}
function ky(t) {
  let {
    selectedElement: e,
    containerElement: n,
    isHorizontal: i
  } = t;
  const a = io(i, n), o = Zh(i, e), r = io(i, e);
  return o - a / 2 + r / 2;
}
function Mc(t, e) {
  const n = t ? "scrollWidth" : "scrollHeight";
  return (e == null ? void 0 : e[n]) || 0;
}
function Oy(t, e) {
  const n = t ? "clientWidth" : "clientHeight";
  return (e == null ? void 0 : e[n]) || 0;
}
function Hh(t, e, n) {
  if (!n)
    return 0;
  const {
    scrollLeft: i,
    offsetWidth: a,
    scrollWidth: o
  } = n;
  return t ? e ? o - a + i : i : n.scrollTop;
}
function io(t, e) {
  const n = t ? "offsetWidth" : "offsetHeight";
  return (e == null ? void 0 : e[n]) || 0;
}
function Zh(t, e) {
  const n = t ? "offsetLeft" : "offsetTop";
  return (e == null ? void 0 : e[n]) || 0;
}
const Kh = Symbol.for("vuetify:v-slide-group"), qh = U({
  centerActive: Boolean,
  contentClass: null,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: Kh
  },
  nextIcon: {
    type: Pe,
    default: "$next"
  },
  prevIcon: {
    type: Pe,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (t) => typeof t == "boolean" || ["always", "desktop", "mobile"].includes(t)
  },
  ...ve(),
  ...Yh({
    mobile: null
  }),
  ...Oe(),
  ...Br({
    selectedClass: "v-slide-group-item--active"
  })
}, "VSlideGroup"), Kl = ee()({
  name: "VSlideGroup",
  props: qh(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      isRtl: i
    } = Wt(), {
      displayClasses: a,
      mobile: o
    } = Vr(t), r = Ro(t, t.symbol), l = Q(!1), s = Q(0), u = Q(0), c = Q(0), d = E(() => t.direction === "horizontal"), {
      resizeRef: h,
      contentRect: f
    } = Wi(), {
      resizeRef: g,
      contentRect: m
    } = Wi(), v = zy(), y = E(() => ({
      container: h.el,
      duration: 200,
      easing: "easeOutQuart"
    })), C = E(() => r.selected.value.length ? r.items.value.findIndex((R) => R.id === r.selected.value[0]) : -1), M = E(() => r.selected.value.length ? r.items.value.findIndex((R) => R.id === r.selected.value[r.selected.value.length - 1]) : -1);
    if (nt) {
      let R = -1;
      ie(() => [r.selected.value, f.value, m.value, d.value], () => {
        cancelAnimationFrame(R), R = requestAnimationFrame(() => {
          if (f.value && m.value) {
            const V = d.value ? "width" : "height";
            u.value = f.value[V], c.value = m.value[V], l.value = u.value + 1 < c.value;
          }
          if (C.value >= 0 && g.el) {
            const V = g.el.children[M.value];
            b(V, t.centerActive);
          }
        });
      });
    }
    const p = Q(!1);
    function b(R, V) {
      let X = 0;
      V ? X = ky({
        containerElement: h.el,
        isHorizontal: d.value,
        selectedElement: R
      }) : X = Fy({
        containerElement: h.el,
        isHorizontal: d.value,
        isRtl: i.value,
        selectedElement: R
      }), P(X);
    }
    function P(R) {
      if (!nt || !h.el) return;
      const V = io(d.value, h.el), X = Hh(d.value, i.value, h.el);
      if (!(Mc(d.value, h.el) <= V || // Prevent scrolling by only a couple of pixels, which doesn't look smooth
      Math.abs(R - X) < 16)) {
        if (d.value && i.value && h.el) {
          const {
            scrollWidth: Y,
            offsetWidth: ce
          } = h.el;
          R = Y - ce - R;
        }
        d.value ? v.horizontal(R, y.value) : v(R, y.value);
      }
    }
    function x(R) {
      const {
        scrollTop: V,
        scrollLeft: X
      } = R.target;
      s.value = d.value ? X : V;
    }
    function _(R) {
      if (p.value = !0, !(!l.value || !g.el)) {
        for (const V of R.composedPath())
          for (const X of g.el.children)
            if (X === V) {
              b(X);
              return;
            }
      }
    }
    function T(R) {
      p.value = !1;
    }
    let B = !1;
    function L(R) {
      var V;
      !B && !p.value && !(R.relatedTarget && ((V = g.el) != null && V.contains(R.relatedTarget))) && G(), B = !1;
    }
    function z() {
      B = !0;
    }
    function I(R) {
      if (!g.el) return;
      function V(X) {
        R.preventDefault(), G(X);
      }
      d.value ? R.key === "ArrowRight" ? V(i.value ? "prev" : "next") : R.key === "ArrowLeft" && V(i.value ? "next" : "prev") : R.key === "ArrowDown" ? V("next") : R.key === "ArrowUp" && V("prev"), R.key === "Home" ? V("first") : R.key === "End" && V("last");
    }
    function k(R, V) {
      if (!R) return;
      let X = R;
      do
        X = X == null ? void 0 : X[V === "next" ? "nextElementSibling" : "previousElementSibling"];
      while (X != null && X.hasAttribute("disabled"));
      return X;
    }
    function G(R) {
      if (!g.el) return;
      let V;
      if (!R)
        V = rr(g.el)[0];
      else if (R === "next") {
        if (V = k(g.el.querySelector(":focus"), R), !V) return G("first");
      } else if (R === "prev") {
        if (V = k(g.el.querySelector(":focus"), R), !V) return G("last");
      } else R === "first" ? (V = g.el.firstElementChild, V != null && V.hasAttribute("disabled") && (V = k(V, "next"))) : R === "last" && (V = g.el.lastElementChild, V != null && V.hasAttribute("disabled") && (V = k(V, "prev")));
      V && V.focus({
        preventScroll: !0
      });
    }
    function F(R) {
      const V = d.value && i.value ? -1 : 1, X = (R === "prev" ? -V : V) * u.value;
      let D = s.value + X;
      if (d.value && i.value && h.el) {
        const {
          scrollWidth: Y,
          offsetWidth: ce
        } = h.el;
        D += Y - ce;
      }
      P(D);
    }
    const q = E(() => ({
      next: r.next,
      prev: r.prev,
      select: r.select,
      isSelected: r.isSelected
    })), j = E(() => {
      switch (t.showArrows) {
        // Always show arrows on desktop & mobile
        case "always":
          return !0;
        // Always show arrows on desktop
        case "desktop":
          return !o.value;
        // Show arrows on mobile when overflowing.
        // This matches the default 2.2 behavior
        case !0:
          return l.value || Math.abs(s.value) > 0;
        // Always show on mobile
        case "mobile":
          return o.value || l.value || Math.abs(s.value) > 0;
        // https://material.io/components/tabs#scrollable-tabs
        // Always show arrows when
        // overflowed on desktop
        default:
          return !o.value && (l.value || Math.abs(s.value) > 0);
      }
    }), ne = E(() => Math.abs(s.value) > 1), A = E(() => {
      if (!h.value) return !1;
      const R = Mc(d.value, h.el), V = Oy(d.value, h.el);
      return R - V - Math.abs(s.value) > 1;
    });
    return le(() => S(t.tag, {
      class: te(["v-slide-group", {
        "v-slide-group--vertical": !d.value,
        "v-slide-group--has-affixes": j.value,
        "v-slide-group--is-overflowing": l.value
      }, a.value, t.class]),
      style: re(t.style),
      tabindex: p.value || r.selected.value.length ? -1 : 0,
      onFocus: L
    }, {
      default: () => {
        var R, V, X;
        return [j.value && w("div", {
          key: "prev",
          class: te(["v-slide-group__prev", {
            "v-slide-group__prev--disabled": !ne.value
          }]),
          onMousedown: z,
          onClick: () => ne.value && F("prev")
        }, [((R = n.prev) == null ? void 0 : R.call(n, q.value)) ?? S(Sc, null, {
          default: () => [S(Be, {
            icon: i.value ? t.nextIcon : t.prevIcon
          }, null)]
        })]), w("div", {
          key: "container",
          ref: h,
          class: te(["v-slide-group__container", t.contentClass]),
          onScroll: x
        }, [w("div", {
          ref: g,
          class: "v-slide-group__content",
          onFocusin: _,
          onFocusout: T,
          onKeydown: I
        }, [(V = n.default) == null ? void 0 : V.call(n, q.value)])]), j.value && w("div", {
          key: "next",
          class: te(["v-slide-group__next", {
            "v-slide-group__next--disabled": !A.value
          }]),
          onMousedown: z,
          onClick: () => A.value && F("next")
        }, [((X = n.next) == null ? void 0 : X.call(n, q.value)) ?? S(Sc, null, {
          default: () => [S(Be, {
            icon: i.value ? t.prevIcon : t.nextIcon
          }, null)]
        })])];
      }
    })), {
      selected: r.selected,
      scrollTo: F,
      scrollOffset: s,
      focus: G,
      hasPrev: ne,
      hasNext: A
    };
  }
}), Jh = Symbol.for("vuetify:v-chip-group"), Dy = U({
  baseColor: String,
  column: Boolean,
  filter: Boolean,
  valueComparator: {
    type: Function,
    default: en
  },
  ...qh(),
  ...ve(),
  ...Br({
    selectedClass: "v-chip--selected"
  }),
  ...Oe(),
  ...Ue(),
  ...wi({
    variant: "tonal"
  })
}, "VChipGroup");
ee()({
  name: "VChipGroup",
  props: Dy(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      themeClasses: i
    } = et(t), {
      isSelected: a,
      select: o,
      next: r,
      prev: l,
      selected: s
    } = Ro(t, Jh);
    return ai({
      VChip: {
        baseColor: O(() => t.baseColor),
        color: O(() => t.color),
        disabled: O(() => t.disabled),
        filter: O(() => t.filter),
        variant: O(() => t.variant)
      }
    }), le(() => {
      const u = Kl.filterProps(t);
      return S(Kl, oe(u, {
        class: ["v-chip-group", {
          "v-chip-group--column": t.column
        }, i.value, t.class],
        style: t.style
      }), {
        default: () => {
          var c;
          return [(c = n.default) == null ? void 0 : c.call(n, {
            isSelected: a,
            select: o,
            next: r,
            prev: l,
            selected: s.value
          })];
        }
      });
    }), {};
  }
});
const Cn = U({
  elevation: {
    type: [Number, String],
    validator(t) {
      const e = parseInt(t);
      return !isNaN(e) && e >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      e <= 24;
    }
  }
}, "elevation");
function pn(t) {
  return {
    elevationClasses: O(() => {
      const n = Gl(t) ? t.value : t.elevation;
      return n == null ? [] : [`elevation-${n}`];
    })
  };
}
function Gy() {
  const t = Qe("useRoute");
  return E(() => {
    var e;
    return (e = t == null ? void 0 : t.proxy) == null ? void 0 : e.$route;
  });
}
function Qh() {
  var t, e;
  return (e = (t = Qe("useRouter")) == null ? void 0 : t.proxy) == null ? void 0 : e.$router;
}
function Fr(t, e) {
  var c, d;
  const n = qd("RouterLink"), i = O(() => !!(t.href || t.to)), a = E(() => (i == null ? void 0 : i.value) || Qu(e, "click") || Qu(t, "click"));
  if (typeof n == "string" || !("useLink" in n)) {
    const h = O(() => t.href);
    return {
      isLink: i,
      isClickable: a,
      href: h,
      linkProps: cn({
        href: h
      })
    };
  }
  const o = n.useLink({
    to: O(() => t.to || ""),
    replace: O(() => t.replace)
  }), r = E(() => t.to ? o : void 0), l = Gy(), s = E(() => {
    var h, f, g;
    return r.value ? t.exact ? l.value ? ((g = r.value.isExactActive) == null ? void 0 : g.value) && en(r.value.route.value.query, l.value.query) : ((f = r.value.isExactActive) == null ? void 0 : f.value) ?? !1 : ((h = r.value.isActive) == null ? void 0 : h.value) ?? !1 : !1;
  }), u = E(() => {
    var h;
    return t.to ? (h = r.value) == null ? void 0 : h.route.value.href : t.href;
  });
  return {
    isLink: i,
    isClickable: a,
    isActive: s,
    route: (c = r.value) == null ? void 0 : c.route,
    navigate: (d = r.value) == null ? void 0 : d.navigate,
    href: u,
    linkProps: cn({
      href: u,
      "aria-current": O(() => s.value ? "page" : void 0)
    })
  };
}
const kr = U({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let Cl = !1;
function Ny(t, e) {
  let n = !1, i, a;
  nt && (t != null && t.beforeEach) && (Ye(() => {
    window.addEventListener("popstate", o), i = t.beforeEach((r, l, s) => {
      Cl ? n ? e(s) : s() : setTimeout(() => n ? e(s) : s()), Cl = !0;
    }), a = t == null ? void 0 : t.afterEach(() => {
      Cl = !1;
    });
  }), _t(() => {
    window.removeEventListener("popstate", o), i == null || i(), a == null || a();
  }));
  function o(r) {
    var l;
    (l = r.state) != null && l.replaced || (n = !0, setTimeout(() => n = !1));
  }
}
const Wy = U({
  activeClass: String,
  appendAvatar: String,
  appendIcon: Pe,
  baseColor: String,
  closable: Boolean,
  closeIcon: {
    type: Pe,
    default: "$delete"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  draggable: Boolean,
  filter: Boolean,
  filterIcon: {
    type: Pe,
    default: "$complete"
  },
  label: Boolean,
  link: {
    type: Boolean,
    default: void 0
  },
  pill: Boolean,
  prependAvatar: String,
  prependIcon: Pe,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: {
    type: [String, Number, Boolean],
    default: void 0
  },
  modelValue: {
    type: Boolean,
    default: !0
  },
  onClick: Bt(),
  onClickOnce: Bt(),
  ...vn(),
  ...ve(),
  ...Dn(),
  ...Cn(),
  ...Eo(),
  ...Tt(),
  ...kr(),
  ...xo(),
  ...Oe({
    tag: "span"
  }),
  ...Ue(),
  ...wi({
    variant: "tonal"
  })
}, "VChip"), ef = ee()({
  name: "VChip",
  directives: {
    vRipple: fn
  },
  props: Wy(),
  emits: {
    "click:close": (t) => !0,
    "update:modelValue": (t) => !0,
    "group:selected": (t) => !0,
    click: (t) => !0
  },
  setup(t, e) {
    let {
      attrs: n,
      emit: i,
      slots: a
    } = e;
    const {
      t: o
    } = Aa(), {
      borderClasses: r
    } = yn(t), {
      densityClasses: l
    } = oi(t), {
      elevationClasses: s
    } = pn(t), {
      roundedClasses: u
    } = wt(t), {
      sizeClasses: c
    } = Po(t), {
      themeClasses: d
    } = et(t), h = Xe(t, "modelValue"), f = Ao(t, Jh, !1), g = Fr(t, n), m = O(() => t.link !== !1 && g.isLink.value), v = E(() => !t.disabled && t.link !== !1 && (!!f || t.link || g.isClickable.value)), y = O(() => ({
      "aria-label": o(t.closeLabel),
      disabled: t.disabled,
      onClick(x) {
        x.preventDefault(), x.stopPropagation(), h.value = !1, i("click:close", x);
      }
    })), {
      colorClasses: C,
      colorStyles: M,
      variantClasses: p
    } = wo(() => ({
      color: !f || f.isSelected.value ? t.color ?? t.baseColor : t.baseColor,
      variant: t.variant
    }));
    function b(x) {
      var _;
      i("click", x), v.value && ((_ = g.navigate) == null || _.call(g, x), f == null || f.toggle());
    }
    function P(x) {
      (x.key === "Enter" || x.key === " ") && (x.preventDefault(), b(x));
    }
    return () => {
      var k;
      const x = g.isLink.value ? "a" : t.tag, _ = !!(t.appendIcon || t.appendAvatar), T = !!(_ || a.append), B = !!(a.close || t.closable), L = !!(a.filter || t.filter) && f, z = !!(t.prependIcon || t.prependAvatar), I = !!(z || a.prepend);
      return h.value && it(S(x, oe({
        class: ["v-chip", {
          "v-chip--disabled": t.disabled,
          "v-chip--label": t.label,
          "v-chip--link": v.value,
          "v-chip--filter": L,
          "v-chip--pill": t.pill,
          [`${t.activeClass}`]: t.activeClass && ((k = g.isActive) == null ? void 0 : k.value)
        }, d.value, r.value, C.value, l.value, s.value, u.value, c.value, p.value, f == null ? void 0 : f.selectedClass.value, t.class],
        style: [M.value, t.style],
        disabled: t.disabled || void 0,
        draggable: t.draggable,
        tabindex: v.value ? 0 : void 0,
        onClick: b,
        onKeydown: v.value && !m.value && P
      }, g.linkProps), {
        default: () => {
          var G;
          return [To(v.value, "v-chip"), L && S($h, {
            key: "filter"
          }, {
            default: () => [it(w("div", {
              class: "v-chip__filter"
            }, [a.filter ? S(We, {
              key: "filter-defaults",
              disabled: !t.filterIcon,
              defaults: {
                VIcon: {
                  icon: t.filterIcon
                }
              }
            }, a.filter) : S(Be, {
              key: "filter-icon",
              icon: t.filterIcon
            }, null)]), [[Pi, f.isSelected.value]])]
          }), I && w("div", {
            key: "prepend",
            class: "v-chip__prepend"
          }, [a.prepend ? S(We, {
            key: "prepend-defaults",
            disabled: !z,
            defaults: {
              VAvatar: {
                image: t.prependAvatar,
                start: !0
              },
              VIcon: {
                icon: t.prependIcon,
                start: !0
              }
            }
          }, a.prepend) : w(pe, null, [t.prependIcon && S(Be, {
            key: "prepend-icon",
            icon: t.prependIcon,
            start: !0
          }, null), t.prependAvatar && S(bi, {
            key: "prepend-avatar",
            image: t.prependAvatar,
            start: !0
          }, null)])]), w("div", {
            class: "v-chip__content",
            "data-no-activator": ""
          }, [((G = a.default) == null ? void 0 : G.call(a, {
            isSelected: f == null ? void 0 : f.isSelected.value,
            selectedClass: f == null ? void 0 : f.selectedClass.value,
            select: f == null ? void 0 : f.select,
            toggle: f == null ? void 0 : f.toggle,
            value: f == null ? void 0 : f.value.value,
            disabled: t.disabled
          })) ?? Ge(t.text)]), T && w("div", {
            key: "append",
            class: "v-chip__append"
          }, [a.append ? S(We, {
            key: "append-defaults",
            disabled: !_,
            defaults: {
              VAvatar: {
                end: !0,
                image: t.appendAvatar
              },
              VIcon: {
                end: !0,
                icon: t.appendIcon
              }
            }
          }, a.append) : w(pe, null, [t.appendIcon && S(Be, {
            key: "append-icon",
            end: !0,
            icon: t.appendIcon
          }, null), t.appendAvatar && S(bi, {
            key: "append-avatar",
            end: !0,
            image: t.appendAvatar
          }, null)])]), B && w("button", oe({
            key: "close",
            class: "v-chip__close",
            type: "button",
            "data-testid": "close-chip"
          }, y.value), [a.close ? S(We, {
            key: "close-defaults",
            defaults: {
              VIcon: {
                icon: t.closeIcon,
                size: "x-small"
              }
            }
          }, a.close) : S(Be, {
            key: "close-icon",
            icon: t.closeIcon,
            size: "x-small"
          }, null)])];
        }
      }), [[fn, v.value && t.ripple, null]]);
    };
  }
}), $y = U({
  color: String,
  inset: Boolean,
  length: [Number, String],
  opacity: [Number, String],
  thickness: [Number, String],
  vertical: Boolean,
  ...ve(),
  ...Ue()
}, "VDivider"), Gs = ee()({
  name: "VDivider",
  props: $y(),
  setup(t, e) {
    let {
      attrs: n,
      slots: i
    } = e;
    const {
      themeClasses: a
    } = et(t), {
      textColorClasses: o,
      textColorStyles: r
    } = Bn(() => t.color), l = E(() => {
      const s = {};
      return t.length && (s[t.vertical ? "height" : "width"] = he(t.length)), t.thickness && (s[t.vertical ? "borderRightWidth" : "borderTopWidth"] = he(t.thickness)), s;
    });
    return le(() => {
      const s = w("hr", {
        class: te([{
          "v-divider": !0,
          "v-divider--inset": t.inset,
          "v-divider--vertical": t.vertical
        }, a.value, o.value, t.class]),
        style: re([l.value, r.value, {
          "--v-border-opacity": t.opacity
        }, t.style]),
        "aria-orientation": !n.role || n.role === "separator" ? t.vertical ? "vertical" : "horizontal" : void 0,
        role: `${n.role || "separator"}`
      }, null);
      return i.default ? w("div", {
        class: te(["v-divider__wrapper", {
          "v-divider__wrapper--vertical": t.vertical,
          "v-divider__wrapper--inset": t.inset
        }])
      }, [s, w("div", {
        class: "v-divider__content"
      }, [i.default()]), s]) : s;
    }), {};
  }
}), ql = Symbol.for("vuetify:list");
function tf() {
  let {
    filterable: t
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    filterable: !1
  };
  const e = Ne(ql, {
    filterable: !1,
    hasPrepend: Q(!1),
    updateHasPrepend: () => null
  }), n = {
    filterable: e.filterable || t,
    hasPrepend: Q(!1),
    updateHasPrepend: (i) => {
      i && (n.hasPrepend.value = i);
    }
  };
  return ht(ql, n), e;
}
function nf() {
  return Ne(ql, null);
}
const Ns = (t) => {
  const e = {
    activate: (n) => {
      let {
        id: i,
        value: a,
        activated: o
      } = n;
      return i = lt(i), t && !a && o.size === 1 && o.has(i) || (a ? o.add(i) : o.delete(i)), o;
    },
    in: (n, i, a) => {
      let o = /* @__PURE__ */ new Set();
      if (n != null)
        for (const r of Vt(n))
          o = e.activate({
            id: r,
            value: !0,
            activated: new Set(o),
            children: i,
            parents: a
          });
      return o;
    },
    out: (n) => Array.from(n)
  };
  return e;
}, af = (t) => {
  const e = Ns(t);
  return {
    activate: (i) => {
      let {
        activated: a,
        id: o,
        ...r
      } = i;
      o = lt(o);
      const l = a.has(o) ? /* @__PURE__ */ new Set([o]) : /* @__PURE__ */ new Set();
      return e.activate({
        ...r,
        id: o,
        activated: l
      });
    },
    in: (i, a, o) => {
      let r = /* @__PURE__ */ new Set();
      if (i != null) {
        const l = Vt(i);
        l.length && (r = e.in(l.slice(0, 1), a, o));
      }
      return r;
    },
    out: (i, a, o) => e.out(i, a, o)
  };
}, Xy = (t) => {
  const e = Ns(t);
  return {
    activate: (i) => {
      let {
        id: a,
        activated: o,
        children: r,
        ...l
      } = i;
      return a = lt(a), r.has(a) ? o : e.activate({
        id: a,
        activated: o,
        children: r,
        ...l
      });
    },
    in: e.in,
    out: e.out
  };
}, Uy = (t) => {
  const e = af(t);
  return {
    activate: (i) => {
      let {
        id: a,
        activated: o,
        children: r,
        ...l
      } = i;
      return a = lt(a), r.has(a) ? o : e.activate({
        id: a,
        activated: o,
        children: r,
        ...l
      });
    },
    in: e.in,
    out: e.out
  };
}, Yy = {
  open: (t) => {
    let {
      id: e,
      value: n,
      opened: i,
      parents: a
    } = t;
    if (n) {
      const o = /* @__PURE__ */ new Set();
      o.add(e);
      let r = a.get(e);
      for (; r != null; )
        o.add(r), r = a.get(r);
      return o;
    } else
      return i.delete(e), i;
  },
  select: () => null
}, of = {
  open: (t) => {
    let {
      id: e,
      value: n,
      opened: i,
      parents: a
    } = t;
    if (n) {
      let o = a.get(e);
      for (i.add(e); o != null && o !== e; )
        i.add(o), o = a.get(o);
      return i;
    } else
      i.delete(e);
    return i;
  },
  select: () => null
}, jy = {
  open: of.open,
  select: (t) => {
    let {
      id: e,
      value: n,
      opened: i,
      parents: a
    } = t;
    if (!n) return i;
    const o = [];
    let r = a.get(e);
    for (; r != null; )
      o.push(r), r = a.get(r);
    return new Set(o);
  }
}, Ws = (t) => {
  const e = {
    select: (n) => {
      let {
        id: i,
        value: a,
        selected: o
      } = n;
      if (i = lt(i), t && !a) {
        const r = Array.from(o.entries()).reduce((l, s) => {
          let [u, c] = s;
          return c === "on" && l.push(u), l;
        }, []);
        if (r.length === 1 && r[0] === i) return o;
      }
      return o.set(i, a ? "on" : "off"), o;
    },
    in: (n, i, a, o) => {
      const r = /* @__PURE__ */ new Map();
      for (const l of n || [])
        e.select({
          id: l,
          value: !0,
          selected: r,
          children: i,
          parents: a,
          disabled: o
        });
      return r;
    },
    out: (n) => {
      const i = [];
      for (const [a, o] of n.entries())
        o === "on" && i.push(a);
      return i;
    }
  };
  return e;
}, rf = (t) => {
  const e = Ws(t);
  return {
    select: (i) => {
      let {
        selected: a,
        id: o,
        ...r
      } = i;
      o = lt(o);
      const l = a.has(o) ? /* @__PURE__ */ new Map([[o, a.get(o)]]) : /* @__PURE__ */ new Map();
      return e.select({
        ...r,
        id: o,
        selected: l
      });
    },
    in: (i, a, o, r) => i != null && i.length ? e.in(i.slice(0, 1), a, o, r) : /* @__PURE__ */ new Map(),
    out: (i, a, o) => e.out(i, a, o)
  };
}, Hy = (t) => {
  const e = Ws(t);
  return {
    select: (i) => {
      let {
        id: a,
        selected: o,
        children: r,
        ...l
      } = i;
      return a = lt(a), r.has(a) ? o : e.select({
        id: a,
        selected: o,
        children: r,
        ...l
      });
    },
    in: e.in,
    out: e.out
  };
}, Zy = (t) => {
  const e = rf(t);
  return {
    select: (i) => {
      let {
        id: a,
        selected: o,
        children: r,
        ...l
      } = i;
      return a = lt(a), r.has(a) ? o : e.select({
        id: a,
        selected: o,
        children: r,
        ...l
      });
    },
    in: e.in,
    out: e.out
  };
}, lf = (t) => {
  const e = {
    select: (n) => {
      let {
        id: i,
        value: a,
        selected: o,
        children: r,
        parents: l,
        disabled: s
      } = n;
      i = lt(i);
      const u = new Map(o), c = [i];
      for (; c.length; ) {
        const h = c.shift();
        s.has(h) || o.set(lt(h), a ? "on" : "off"), r.has(h) && c.push(...r.get(h));
      }
      let d = lt(l.get(i));
      for (; d; ) {
        let h = !0, f = !0;
        for (const g of r.get(d)) {
          const m = lt(g);
          if (!s.has(m) && (o.get(m) !== "on" && (h = !1), o.has(m) && o.get(m) !== "off" && (f = !1), !h && !f))
            break;
        }
        o.set(d, h ? "on" : f ? "off" : "indeterminate"), d = lt(l.get(d));
      }
      return t && !a && Array.from(o.entries()).reduce((f, g) => {
        let [m, v] = g;
        return v === "on" && f.push(m), f;
      }, []).length === 0 ? u : o;
    },
    in: (n, i, a, o) => {
      let r = /* @__PURE__ */ new Map();
      for (const l of n || [])
        r = e.select({
          id: l,
          value: !0,
          selected: r,
          children: i,
          parents: a,
          disabled: o
        });
      return r;
    },
    out: (n, i) => {
      const a = [];
      for (const [o, r] of n.entries())
        r === "on" && !i.has(o) && a.push(o);
      return a;
    }
  };
  return e;
}, Ky = (t) => {
  const e = lf(t);
  return {
    select: e.select,
    in: e.in,
    out: (i, a, o) => {
      const r = [];
      for (const [l, s] of i.entries())
        if (s === "on") {
          if (o.has(l)) {
            const u = o.get(l);
            if (i.get(u) === "on") continue;
          }
          r.push(l);
        }
      return r;
    }
  };
}, ao = Symbol.for("vuetify:nested"), sf = {
  id: Q(),
  root: {
    register: () => null,
    unregister: () => null,
    children: Z(/* @__PURE__ */ new Map()),
    parents: Z(/* @__PURE__ */ new Map()),
    disabled: Z(/* @__PURE__ */ new Set()),
    open: () => null,
    openOnSelect: () => null,
    activate: () => null,
    select: () => null,
    activatable: Z(!1),
    selectable: Z(!1),
    opened: Z(/* @__PURE__ */ new Set()),
    activated: Z(/* @__PURE__ */ new Set()),
    selected: Z(/* @__PURE__ */ new Map()),
    selectedValues: Z([]),
    getPath: () => []
  }
}, qy = U({
  activatable: Boolean,
  selectable: Boolean,
  activeStrategy: [String, Function, Object],
  selectStrategy: [String, Function, Object],
  openStrategy: [String, Object],
  opened: null,
  activated: null,
  selected: null,
  mandatory: Boolean
}, "nested"), Jy = (t) => {
  let e = !1;
  const n = Q(/* @__PURE__ */ new Map()), i = Q(/* @__PURE__ */ new Map()), a = Q(/* @__PURE__ */ new Set()), o = Xe(t, "opened", t.opened, (m) => new Set(Array.isArray(m) ? m.map((v) => lt(v)) : m), (m) => [...m.values()]), r = E(() => {
    if (typeof t.activeStrategy == "object") return t.activeStrategy;
    if (typeof t.activeStrategy == "function") return t.activeStrategy(t.mandatory);
    switch (t.activeStrategy) {
      case "leaf":
        return Xy(t.mandatory);
      case "single-leaf":
        return Uy(t.mandatory);
      case "independent":
        return Ns(t.mandatory);
      case "single-independent":
      default:
        return af(t.mandatory);
    }
  }), l = E(() => {
    if (typeof t.selectStrategy == "object") return t.selectStrategy;
    if (typeof t.selectStrategy == "function") return t.selectStrategy(t.mandatory);
    switch (t.selectStrategy) {
      case "single-leaf":
        return Zy(t.mandatory);
      case "leaf":
        return Hy(t.mandatory);
      case "independent":
        return Ws(t.mandatory);
      case "single-independent":
        return rf(t.mandatory);
      case "trunk":
        return Ky(t.mandatory);
      case "classic":
      default:
        return lf(t.mandatory);
    }
  }), s = E(() => {
    if (typeof t.openStrategy == "object") return t.openStrategy;
    switch (t.openStrategy) {
      case "list":
        return jy;
      case "single":
        return Yy;
      case "multiple":
      default:
        return of;
    }
  }), u = Xe(t, "activated", t.activated, (m) => r.value.in(m, n.value, i.value), (m) => r.value.out(m, n.value, i.value)), c = Xe(t, "selected", t.selected, (m) => l.value.in(m, n.value, i.value, a.value), (m) => l.value.out(m, n.value, i.value));
  pt(() => {
    e = !0;
  });
  function d(m) {
    const v = [];
    let y = lt(m);
    for (; y != null; )
      v.unshift(y), y = i.value.get(y);
    return v;
  }
  const h = Qe("nested"), f = /* @__PURE__ */ new Set(), g = {
    id: Q(),
    root: {
      opened: o,
      activatable: O(() => t.activatable),
      selectable: O(() => t.selectable),
      activated: u,
      selected: c,
      selectedValues: E(() => {
        const m = [];
        for (const [v, y] of c.value.entries())
          y === "on" && m.push(v);
        return m;
      }),
      register: (m, v, y, C) => {
        if (f.has(m)) {
          const M = d(m).map(String).join(" -> "), p = d(v).concat(m).map(String).join(" -> ");
          yh(`Multiple nodes with the same ID
	${M}
	${p}`);
          return;
        } else
          f.add(m);
        v && m !== v && i.value.set(m, v), y && a.value.add(m), C && n.value.set(m, []), v != null && n.value.set(v, [...n.value.get(v) || [], m]);
      },
      unregister: (m) => {
        if (e) return;
        f.delete(m), n.value.delete(m), a.value.delete(m);
        const v = i.value.get(m);
        if (v) {
          const y = n.value.get(v) ?? [];
          n.value.set(v, y.filter((C) => C !== m));
        }
        i.value.delete(m);
      },
      open: (m, v, y) => {
        h.emit("click:open", {
          id: m,
          value: v,
          path: d(m),
          event: y
        });
        const C = s.value.open({
          id: m,
          value: v,
          opened: new Set(o.value),
          children: n.value,
          parents: i.value,
          event: y
        });
        C && (o.value = C);
      },
      openOnSelect: (m, v, y) => {
        const C = s.value.select({
          id: m,
          value: v,
          selected: new Map(c.value),
          opened: new Set(o.value),
          children: n.value,
          parents: i.value,
          event: y
        });
        C && (o.value = C);
      },
      select: (m, v, y) => {
        h.emit("click:select", {
          id: m,
          value: v,
          path: d(m),
          event: y
        });
        const C = l.value.select({
          id: m,
          value: v,
          selected: new Map(c.value),
          children: n.value,
          parents: i.value,
          disabled: a.value,
          event: y
        });
        C && (c.value = C), g.root.openOnSelect(m, v, y);
      },
      activate: (m, v, y) => {
        if (!t.activatable)
          return g.root.select(m, !0, y);
        h.emit("click:activate", {
          id: m,
          value: v,
          path: d(m),
          event: y
        });
        const C = r.value.activate({
          id: m,
          value: v,
          activated: new Set(u.value),
          children: n.value,
          parents: i.value,
          event: y
        });
        if (C.size !== u.value.size)
          u.value = C;
        else {
          for (const M of C)
            if (!u.value.has(M)) {
              u.value = C;
              return;
            }
          for (const M of u.value)
            if (!C.has(M)) {
              u.value = C;
              return;
            }
        }
      },
      children: n,
      parents: i,
      disabled: a,
      getPath: d
    }
  };
  return ht(ao, g), g.root;
}, uf = (t, e, n) => {
  const i = Ne(ao, sf), a = Symbol("nested item"), o = E(() => lt(Vn(t)) ?? a), r = {
    ...i,
    id: o,
    open: (l, s) => i.root.open(o.value, l, s),
    openOnSelect: (l, s) => i.root.openOnSelect(o.value, l, s),
    isOpen: E(() => i.root.opened.value.has(o.value)),
    parent: E(() => i.root.parents.value.get(o.value)),
    activate: (l, s) => i.root.activate(o.value, l, s),
    isActivated: E(() => i.root.activated.value.has(o.value)),
    select: (l, s) => i.root.select(o.value, l, s),
    isSelected: E(() => i.root.selected.value.get(o.value) === "on"),
    isIndeterminate: E(() => i.root.selected.value.get(o.value) === "indeterminate"),
    isLeaf: E(() => !i.root.children.value.get(o.value)),
    isGroupActivator: i.isGroupActivator
  };
  return Rr(() => {
    i.isGroupActivator || i.root.register(o.value, i.id.value, Vn(e), n);
  }), pt(() => {
    i.isGroupActivator || i.root.unregister(o.value);
  }), n && ht(ao, r), r;
}, Qy = () => {
  const t = Ne(ao, sf);
  ht(ao, {
    ...t,
    isGroupActivator: !0
  });
};
function Io() {
  const t = Q(!1);
  return at(() => {
    window.requestAnimationFrame(() => {
      t.value = !0;
    });
  }), {
    ssrBootStyles: O(() => t.value ? void 0 : {
      transition: "none !important"
    }),
    isBooted: Ir(t)
  };
}
const eC = Mo({
  name: "VListGroupActivator",
  setup(t, e) {
    let {
      slots: n
    } = e;
    return Qy(), () => {
      var i;
      return (i = n.default) == null ? void 0 : i.call(n);
    };
  }
}), tC = U({
  /* @deprecated */
  activeColor: String,
  baseColor: String,
  color: String,
  collapseIcon: {
    type: Pe,
    default: "$collapse"
  },
  disabled: Boolean,
  expandIcon: {
    type: Pe,
    default: "$expand"
  },
  rawId: [String, Number],
  prependIcon: Pe,
  appendIcon: Pe,
  fluid: Boolean,
  subgroup: Boolean,
  title: String,
  value: null,
  ...ve(),
  ...Oe()
}, "VListGroup"), xc = ee()({
  name: "VListGroup",
  props: tC(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      isOpen: i,
      open: a,
      id: o
    } = uf(() => t.value, () => t.disabled, !0), r = E(() => `v-list-group--id-${String(t.rawId ?? o.value)}`), l = nf(), {
      isBooted: s
    } = Io();
    function u(f) {
      var g;
      ["INPUT", "TEXTAREA"].includes((g = f.target) == null ? void 0 : g.tagName) || a(!i.value, f);
    }
    const c = E(() => ({
      onClick: u,
      class: "v-list-group__header",
      id: r.value
    })), d = E(() => i.value ? t.collapseIcon : t.expandIcon), h = E(() => ({
      VListItem: {
        activeColor: t.activeColor,
        baseColor: t.baseColor,
        color: t.color,
        prependIcon: t.prependIcon || t.subgroup && d.value,
        appendIcon: t.appendIcon || !t.subgroup && d.value,
        title: t.title,
        value: t.value
      }
    }));
    return le(() => S(t.tag, {
      class: te(["v-list-group", {
        "v-list-group--prepend": l == null ? void 0 : l.hasPrepend.value,
        "v-list-group--fluid": t.fluid,
        "v-list-group--subgroup": t.subgroup,
        "v-list-group--open": i.value
      }, t.class]),
      style: re(t.style)
    }, {
      default: () => [n.activator && S(We, {
        defaults: h.value
      }, {
        default: () => [S(eC, null, {
          default: () => [n.activator({
            props: c.value,
            isOpen: i.value
          })]
        })]
      }), S(Jn, {
        transition: {
          component: Bs
        },
        disabled: !s.value
      }, {
        default: () => {
          var f;
          return [it(w("div", {
            class: "v-list-group__items",
            role: "group",
            "aria-labelledby": r.value
          }, [(f = n.default) == null ? void 0 : f.call(n)]), [[Pi, i.value]])];
        }
      })]
    })), {
      isOpen: i
    };
  }
}), nC = U({
  opacity: [Number, String],
  ...ve(),
  ...Oe()
}, "VListItemSubtitle"), iC = ee()({
  name: "VListItemSubtitle",
  props: nC(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return le(() => S(t.tag, {
      class: te(["v-list-item-subtitle", t.class]),
      style: re([{
        "--v-list-item-subtitle-opacity": t.opacity
      }, t.style])
    }, n)), {};
  }
}), cf = ph("v-list-item-title"), aC = U({
  active: {
    type: Boolean,
    default: void 0
  },
  activeClass: String,
  /* @deprecated */
  activeColor: String,
  appendAvatar: String,
  appendIcon: Pe,
  baseColor: String,
  disabled: Boolean,
  lines: [Boolean, String],
  link: {
    type: Boolean,
    default: void 0
  },
  nav: Boolean,
  prependAvatar: String,
  prependIcon: Pe,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  slim: Boolean,
  subtitle: {
    type: [String, Number, Boolean],
    default: void 0
  },
  title: {
    type: [String, Number, Boolean],
    default: void 0
  },
  value: null,
  onClick: Bt(),
  onClickOnce: Bt(),
  ...vn(),
  ...ve(),
  ...Dn(),
  ...ln(),
  ...Cn(),
  ...Tt(),
  ...kr(),
  ...Oe(),
  ...Ue(),
  ...wi({
    variant: "text"
  })
}, "VListItem"), Fn = ee()({
  name: "VListItem",
  directives: {
    vRipple: fn
  },
  props: aC(),
  emits: {
    click: (t) => !0
  },
  setup(t, e) {
    let {
      attrs: n,
      slots: i,
      emit: a
    } = e;
    const o = Fr(t, n), r = E(() => t.value === void 0 ? o.href.value : t.value), {
      activate: l,
      isActivated: s,
      select: u,
      isOpen: c,
      isSelected: d,
      isIndeterminate: h,
      isGroupActivator: f,
      root: g,
      parent: m,
      openOnSelect: v,
      id: y
    } = uf(r, () => t.disabled, !1), C = nf(), M = E(() => {
      var Y;
      return t.active !== !1 && (t.active || ((Y = o.isActive) == null ? void 0 : Y.value) || (g.activatable.value ? s.value : d.value));
    }), p = O(() => t.link !== !1 && o.isLink.value), b = E(() => !!C && (g.selectable.value || g.activatable.value || t.value != null)), P = E(() => !t.disabled && t.link !== !1 && (t.link || o.isClickable.value || b.value)), x = O(() => t.rounded || t.nav), _ = O(() => t.color ?? t.activeColor), T = O(() => ({
      color: M.value ? _.value ?? t.baseColor : t.baseColor,
      variant: t.variant
    }));
    ie(() => {
      var Y;
      return (Y = o.isActive) == null ? void 0 : Y.value;
    }, (Y) => {
      Y && B();
    }), Rr(() => {
      var Y;
      (Y = o.isActive) != null && Y.value && B();
    });
    function B() {
      m.value != null && g.open(m.value, !0), v(!0);
    }
    const {
      themeClasses: L
    } = et(t), {
      borderClasses: z
    } = yn(t), {
      colorClasses: I,
      colorStyles: k,
      variantClasses: G
    } = wo(T), {
      densityClasses: F
    } = oi(t), {
      dimensionStyles: q
    } = sn(t), {
      elevationClasses: j
    } = pn(t), {
      roundedClasses: ne
    } = wt(x), A = O(() => t.lines ? `v-list-item--${t.lines}-line` : void 0), R = O(() => t.ripple !== void 0 && t.ripple && (C != null && C.filterable) ? {
      keys: ["Enter"]
    } : t.ripple), V = E(() => ({
      isActive: M.value,
      select: u,
      isOpen: c.value,
      isSelected: d.value,
      isIndeterminate: h.value
    }));
    function X(Y) {
      var ce, K;
      a("click", Y), !["INPUT", "TEXTAREA"].includes((ce = Y.target) == null ? void 0 : ce.tagName) && P.value && ((K = o.navigate) == null || K.call(o, Y), !f && (g.activatable.value ? l(!s.value, Y) : (g.selectable.value || t.value != null) && u(!d.value, Y)));
    }
    function D(Y) {
      const ce = Y.target;
      ["INPUT", "TEXTAREA"].includes(ce.tagName) || (Y.key === "Enter" || Y.key === " " && !(C != null && C.filterable)) && (Y.preventDefault(), Y.stopPropagation(), Y.target.dispatchEvent(new MouseEvent("click", Y)));
    }
    return le(() => {
      const Y = p.value ? "a" : t.tag, ce = i.title || t.title != null, K = i.subtitle || t.subtitle != null, se = !!(t.appendAvatar || t.appendIcon), ge = !!(se || i.append), $ = !!(t.prependAvatar || t.prependIcon), ae = !!($ || i.prepend);
      return C == null || C.updateHasPrepend(ae), t.activeColor && Nv("active-color", ["color", "base-color"]), it(S(Y, oe({
        class: ["v-list-item", {
          "v-list-item--active": M.value,
          "v-list-item--disabled": t.disabled,
          "v-list-item--link": P.value,
          "v-list-item--nav": t.nav,
          "v-list-item--prepend": !ae && (C == null ? void 0 : C.hasPrepend.value),
          "v-list-item--slim": t.slim,
          [`${t.activeClass}`]: t.activeClass && M.value
        }, L.value, z.value, I.value, F.value, j.value, A.value, ne.value, G.value, t.class],
        style: [k.value, q.value, t.style],
        tabindex: P.value ? C ? -2 : 0 : void 0,
        "aria-selected": b.value ? g.activatable.value ? s.value : g.selectable.value ? d.value : M.value : void 0,
        onClick: X,
        onKeydown: P.value && !p.value && D
      }, o.linkProps), {
        default: () => {
          var ye;
          return [To(P.value || M.value, "v-list-item"), ae && w("div", {
            key: "prepend",
            class: "v-list-item__prepend"
          }, [i.prepend ? S(We, {
            key: "prepend-defaults",
            disabled: !$,
            defaults: {
              VAvatar: {
                density: t.density,
                image: t.prependAvatar
              },
              VIcon: {
                density: t.density,
                icon: t.prependIcon
              },
              VListItemAction: {
                start: !0
              }
            }
          }, {
            default: () => {
              var me;
              return [(me = i.prepend) == null ? void 0 : me.call(i, V.value)];
            }
          }) : w(pe, null, [t.prependAvatar && S(bi, {
            key: "prepend-avatar",
            density: t.density,
            image: t.prependAvatar
          }, null), t.prependIcon && S(Be, {
            key: "prepend-icon",
            density: t.density,
            icon: t.prependIcon
          }, null)]), w("div", {
            class: "v-list-item__spacer"
          }, null)]), w("div", {
            class: "v-list-item__content",
            "data-no-activator": ""
          }, [ce && S(cf, {
            key: "title"
          }, {
            default: () => {
              var me;
              return [((me = i.title) == null ? void 0 : me.call(i, {
                title: t.title
              })) ?? Ge(t.title)];
            }
          }), K && S(iC, {
            key: "subtitle"
          }, {
            default: () => {
              var me;
              return [((me = i.subtitle) == null ? void 0 : me.call(i, {
                subtitle: t.subtitle
              })) ?? Ge(t.subtitle)];
            }
          }), (ye = i.default) == null ? void 0 : ye.call(i, V.value)]), ge && w("div", {
            key: "append",
            class: "v-list-item__append"
          }, [i.append ? S(We, {
            key: "append-defaults",
            disabled: !se,
            defaults: {
              VAvatar: {
                density: t.density,
                image: t.appendAvatar
              },
              VIcon: {
                density: t.density,
                icon: t.appendIcon
              },
              VListItemAction: {
                end: !0
              }
            }
          }, {
            default: () => {
              var me;
              return [(me = i.append) == null ? void 0 : me.call(i, V.value)];
            }
          }) : w(pe, null, [t.appendIcon && S(Be, {
            key: "append-icon",
            density: t.density,
            icon: t.appendIcon
          }, null), t.appendAvatar && S(bi, {
            key: "append-avatar",
            density: t.density,
            image: t.appendAvatar
          }, null)]), w("div", {
            class: "v-list-item__spacer"
          }, null)])];
        }
      }), [[fn, P.value && R.value]]);
    }), {
      activate: l,
      isActivated: s,
      isGroupActivator: f,
      isSelected: d,
      list: C,
      select: u,
      root: g,
      id: y,
      link: o
    };
  }
}), oC = U({
  color: String,
  inset: Boolean,
  sticky: Boolean,
  title: String,
  ...ve(),
  ...Oe()
}, "VListSubheader"), $s = ee()({
  name: "VListSubheader",
  props: oC(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      textColorClasses: i,
      textColorStyles: a
    } = Bn(() => t.color);
    return le(() => {
      const o = !!(n.default || t.title);
      return S(t.tag, {
        class: te(["v-list-subheader", {
          "v-list-subheader--inset": t.inset,
          "v-list-subheader--sticky": t.sticky
        }, i.value, t.class]),
        style: re([{
          textColorStyles: a
        }, t.style])
      }, {
        default: () => {
          var r;
          return [o && w("div", {
            class: "v-list-subheader__text"
          }, [((r = n.default) == null ? void 0 : r.call(n)) ?? t.title])];
        }
      });
    }), {};
  }
}), rC = U({
  items: Array,
  returnObject: Boolean
}, "VListChildren"), df = ee()({
  name: "VListChildren",
  props: rC(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return tf(), () => {
      var i, a;
      return ((i = n.default) == null ? void 0 : i.call(n)) ?? ((a = t.items) == null ? void 0 : a.map((o) => {
        var h, f;
        let {
          children: r,
          props: l,
          type: s,
          raw: u
        } = o;
        if (s === "divider")
          return ((h = n.divider) == null ? void 0 : h.call(n, {
            props: l
          })) ?? S(Gs, l, null);
        if (s === "subheader")
          return ((f = n.subheader) == null ? void 0 : f.call(n, {
            props: l
          })) ?? S($s, l, null);
        const c = {
          subtitle: n.subtitle ? (g) => {
            var m;
            return (m = n.subtitle) == null ? void 0 : m.call(n, {
              ...g,
              item: u
            });
          } : void 0,
          prepend: n.prepend ? (g) => {
            var m;
            return (m = n.prepend) == null ? void 0 : m.call(n, {
              ...g,
              item: u
            });
          } : void 0,
          append: n.append ? (g) => {
            var m;
            return (m = n.append) == null ? void 0 : m.call(n, {
              ...g,
              item: u
            });
          } : void 0,
          title: n.title ? (g) => {
            var m;
            return (m = n.title) == null ? void 0 : m.call(n, {
              ...g,
              item: u
            });
          } : void 0
        }, d = xc.filterProps(l);
        return r ? S(xc, oe(d, {
          value: t.returnObject ? u : l == null ? void 0 : l.value,
          rawId: l == null ? void 0 : l.value
        }), {
          activator: (g) => {
            let {
              props: m
            } = g;
            const v = {
              ...l,
              ...m,
              value: t.returnObject ? u : l.value
            };
            return n.header ? n.header({
              props: v
            }) : S(Fn, v, c);
          },
          default: () => S(df, {
            items: r,
            returnObject: t.returnObject
          }, n)
        }) : n.item ? n.item({
          props: l
        }) : S(Fn, oe(l, {
          value: t.returnObject ? u : l.value
        }), c);
      }));
    };
  }
}), hf = U({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  itemType: {
    type: [Boolean, String, Array, Function],
    default: "type"
  },
  returnObject: Boolean,
  valueComparator: Function
}, "list-items"), lC = /* @__PURE__ */ new Set(["item", "divider", "subheader"]);
function ha(t, e) {
  const n = Jt(e, t.itemTitle, e), i = Jt(e, t.itemValue, n), a = Jt(e, t.itemChildren), o = t.itemProps === !0 ? typeof e == "object" && e != null && !Array.isArray(e) ? "children" in e ? Xi(e, ["children"]) : e : void 0 : Jt(e, t.itemProps);
  let r = Jt(e, t.itemType, "item");
  lC.has(r) || (r = "item");
  const l = {
    title: n,
    value: i,
    ...o
  };
  return {
    type: r,
    title: String(l.title ?? ""),
    value: l.value,
    props: l,
    children: r === "item" && Array.isArray(a) ? ff(t, a) : void 0,
    raw: e
  };
}
ha.neededProps = ["itemTitle", "itemValue", "itemChildren", "itemProps", "itemType"];
function ff(t, e) {
  const n = bo(t, ha.neededProps), i = [];
  for (const a of e)
    i.push(ha(n, a));
  return i;
}
function gf(t) {
  const e = E(() => ff(t, t.items)), n = E(() => e.value.some((l) => l.value === null)), i = Q(/* @__PURE__ */ new Map()), a = Q([]);
  Pt(() => {
    const l = e.value, s = /* @__PURE__ */ new Map(), u = [];
    for (let c = 0; c < l.length; c++) {
      const d = l[c];
      if ($l(d.value) || d.value === null) {
        let h = s.get(d.value);
        h || (h = [], s.set(d.value, h)), h.push(d);
      } else
        u.push(d);
    }
    i.value = s, a.value = u;
  });
  function o(l) {
    const s = i.value, u = e.value, c = a.value, d = n.value, h = t.returnObject, f = !!t.valueComparator, g = t.valueComparator || en, m = bo(t, ha.neededProps), v = [];
    e: for (const y of l) {
      if (!d && y === null) continue;
      if (h && typeof y == "string") {
        v.push(ha(m, y));
        continue;
      }
      const C = s.get(y);
      if (f || !C) {
        for (const M of f ? u : c)
          if (g(y, M.value)) {
            v.push(M);
            continue e;
          }
        v.push(ha(m, y));
        continue;
      }
      v.push(...C);
    }
    return v;
  }
  function r(l) {
    return t.returnObject ? l.map((s) => {
      let {
        raw: u
      } = s;
      return u;
    }) : l.map((s) => {
      let {
        value: u
      } = s;
      return u;
    });
  }
  return {
    items: e,
    transformIn: o,
    transformOut: r
  };
}
const sC = /* @__PURE__ */ new Set(["item", "divider", "subheader"]);
function uC(t, e) {
  const n = $l(e) ? e : Jt(e, t.itemTitle), i = $l(e) ? e : Jt(e, t.itemValue, void 0), a = Jt(e, t.itemChildren), o = t.itemProps === !0 ? Xi(e, ["children"]) : Jt(e, t.itemProps);
  let r = Jt(e, t.itemType, "item");
  sC.has(r) || (r = "item");
  const l = {
    title: n,
    value: i,
    ...o
  };
  return {
    type: r,
    title: l.title,
    value: l.value,
    props: l,
    children: r === "item" && a ? mf(t, a) : void 0,
    raw: e
  };
}
function mf(t, e) {
  const n = [];
  for (const i of e)
    n.push(uC(t, i));
  return n;
}
function cC(t) {
  return {
    items: E(() => mf(t, t.items))
  };
}
const dC = U({
  baseColor: String,
  /* @deprecated */
  activeColor: String,
  activeClass: String,
  bgColor: String,
  disabled: Boolean,
  filterable: Boolean,
  expandIcon: Pe,
  collapseIcon: Pe,
  lines: {
    type: [Boolean, String],
    default: "one"
  },
  slim: Boolean,
  nav: Boolean,
  "onClick:open": Bt(),
  "onClick:select": Bt(),
  "onUpdate:opened": Bt(),
  ...qy({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  }),
  ...vn(),
  ...ve(),
  ...Dn(),
  ...ln(),
  ...Cn(),
  ...hf(),
  ...Tt(),
  ...Oe(),
  ...Ue(),
  ...wi({
    variant: "text"
  })
}, "VList"), Ia = ee()({
  name: "VList",
  props: dC(),
  emits: {
    "update:selected": (t) => !0,
    "update:activated": (t) => !0,
    "update:opened": (t) => !0,
    "click:open": (t) => !0,
    "click:activate": (t) => !0,
    "click:select": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      items: i
    } = cC(t), {
      themeClasses: a
    } = et(t), {
      backgroundColorClasses: o,
      backgroundColorStyles: r
    } = xt(() => t.bgColor), {
      borderClasses: l
    } = yn(t), {
      densityClasses: s
    } = oi(t), {
      dimensionStyles: u
    } = sn(t), {
      elevationClasses: c
    } = pn(t), {
      roundedClasses: d
    } = wt(t), {
      children: h,
      open: f,
      parents: g,
      select: m,
      getPath: v
    } = Jy(t), y = O(() => t.lines ? `v-list--${t.lines}-line` : void 0), C = O(() => t.activeColor), M = O(() => t.baseColor), p = O(() => t.color);
    tf({
      filterable: t.filterable
    }), ai({
      VListGroup: {
        activeColor: C,
        baseColor: M,
        color: p,
        expandIcon: O(() => t.expandIcon),
        collapseIcon: O(() => t.collapseIcon)
      },
      VListItem: {
        activeClass: O(() => t.activeClass),
        activeColor: C,
        baseColor: M,
        color: p,
        density: O(() => t.density),
        disabled: O(() => t.disabled),
        lines: O(() => t.lines),
        nav: O(() => t.nav),
        slim: O(() => t.slim),
        variant: O(() => t.variant)
      }
    });
    const b = Q(!1), P = Z();
    function x(I) {
      b.value = !0;
    }
    function _(I) {
      b.value = !1;
    }
    function T(I) {
      var k;
      !b.value && !(I.relatedTarget && ((k = P.value) != null && k.contains(I.relatedTarget))) && z();
    }
    function B(I) {
      const k = I.target;
      if (!(!P.value || k.tagName === "INPUT" && ["Home", "End"].includes(I.key) || k.tagName === "TEXTAREA")) {
        if (I.key === "ArrowDown")
          z("next");
        else if (I.key === "ArrowUp")
          z("prev");
        else if (I.key === "Home")
          z("first");
        else if (I.key === "End")
          z("last");
        else
          return;
        I.preventDefault();
      }
    }
    function L(I) {
      b.value = !0;
    }
    function z(I) {
      if (P.value)
        return Ha(P.value, I);
    }
    return le(() => S(t.tag, {
      ref: P,
      class: te(["v-list", {
        "v-list--disabled": t.disabled,
        "v-list--nav": t.nav,
        "v-list--slim": t.slim
      }, a.value, o.value, l.value, s.value, c.value, y.value, d.value, t.class]),
      style: re([r.value, u.value, t.style]),
      tabindex: t.disabled ? -1 : 0,
      role: "listbox",
      "aria-activedescendant": void 0,
      onFocusin: x,
      onFocusout: _,
      onFocus: T,
      onKeydown: B,
      onMousedown: L
    }, {
      default: () => [S(df, {
        items: i.value,
        returnObject: t.returnObject
      }, n)]
    })), {
      open: f,
      select: m,
      focus: z,
      children: h,
      parents: g,
      getPath: v
    };
  }
});
function pl(t, e) {
  return {
    x: t.x + e.x,
    y: t.y + e.y
  };
}
function hC(t, e) {
  return {
    x: t.x - e.x,
    y: t.y - e.y
  };
}
function Pc(t, e) {
  if (t.side === "top" || t.side === "bottom") {
    const {
      side: n,
      align: i
    } = t, a = i === "left" ? 0 : i === "center" ? e.width / 2 : i === "right" ? e.width : i, o = n === "top" ? 0 : n === "bottom" ? e.height : n;
    return pl({
      x: a,
      y: o
    }, e);
  } else if (t.side === "left" || t.side === "right") {
    const {
      side: n,
      align: i
    } = t, a = n === "left" ? 0 : n === "right" ? e.width : n, o = i === "top" ? 0 : i === "center" ? e.height / 2 : i === "bottom" ? e.height : i;
    return pl({
      x: a,
      y: o
    }, e);
  }
  return pl({
    x: e.width / 2,
    y: e.height / 2
  }, e);
}
const vf = {
  static: mC,
  // specific viewport position, usually centered
  connected: yC
  // connected to a certain element
}, fC = U({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (t) => typeof t == "function" || t in vf
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array]
}, "VOverlay-location-strategies");
function gC(t, e) {
  const n = Z({}), i = Z();
  nt && Nt(() => !!(e.isActive.value && t.locationStrategy), (l) => {
    var s, u;
    ie(() => t.locationStrategy, l), _t(() => {
      window.removeEventListener("resize", a), visualViewport == null || visualViewport.removeEventListener("resize", o), visualViewport == null || visualViewport.removeEventListener("scroll", r), i.value = void 0;
    }), window.addEventListener("resize", a, {
      passive: !0
    }), visualViewport == null || visualViewport.addEventListener("resize", o, {
      passive: !0
    }), visualViewport == null || visualViewport.addEventListener("scroll", r, {
      passive: !0
    }), typeof t.locationStrategy == "function" ? i.value = (s = t.locationStrategy(e, t, n)) == null ? void 0 : s.updateLocation : i.value = (u = vf[t.locationStrategy](e, t, n)) == null ? void 0 : u.updateLocation;
  });
  function a(l) {
    var s;
    (s = i.value) == null || s.call(i, l);
  }
  function o(l) {
    var s;
    (s = i.value) == null || s.call(i, l);
  }
  function r(l) {
    var s;
    (s = i.value) == null || s.call(i, l);
  }
  return {
    contentStyles: n,
    updateLocation: i
  };
}
function mC() {
}
function vC(t, e) {
  const n = zs(t);
  return e ? n.x += parseFloat(t.style.right || 0) : n.x -= parseFloat(t.style.left || 0), n.y -= parseFloat(t.style.top || 0), n;
}
function yC(t, e, n) {
  (Array.isArray(t.target.value) || Kv(t.target.value)) && Object.assign(n.value, {
    position: "fixed",
    top: 0,
    [t.isRtl.value ? "right" : "left"]: 0
  });
  const {
    preferredAnchor: a,
    preferredOrigin: o
  } = Es(() => {
    const y = Xl(e.location, t.isRtl.value), C = e.origin === "overlap" ? y : e.origin === "auto" ? hl(y) : Xl(e.origin, t.isRtl.value);
    return y.side === C.side && y.align === fl(C).align ? {
      preferredAnchor: ec(y),
      preferredOrigin: ec(C)
    } : {
      preferredAnchor: y,
      preferredOrigin: C
    };
  }), [r, l, s, u] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((y) => E(() => {
    const C = parseFloat(e[y]);
    return isNaN(C) ? 1 / 0 : C;
  })), c = E(() => {
    if (Array.isArray(e.offset))
      return e.offset;
    if (typeof e.offset == "string") {
      const y = e.offset.split(" ").map(parseFloat);
      return y.length < 2 && y.push(0), y;
    }
    return typeof e.offset == "number" ? [e.offset, 0] : [0, 0];
  });
  let d = !1, h = -1;
  const f = new hh(4), g = new ResizeObserver(() => {
    if (!d) return;
    if (requestAnimationFrame((C) => {
      C !== h && f.clear(), requestAnimationFrame((M) => {
        h = M;
      });
    }), f.isFull) {
      const C = f.values();
      if (en(C.at(-1), C.at(-3)) && !en(C.at(-1), C.at(-2)))
        return;
    }
    const y = v();
    y && f.push(y.flipped);
  });
  ie([t.target, t.contentEl], (y, C) => {
    let [M, p] = y, [b, P] = C;
    b && !Array.isArray(b) && g.unobserve(b), M && !Array.isArray(M) && g.observe(M), P && g.unobserve(P), p && g.observe(p);
  }, {
    immediate: !0
  }), _t(() => {
    g.disconnect();
  });
  let m = new Rn({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
  function v() {
    if (d = !1, requestAnimationFrame(() => d = !0), !t.target.value || !t.contentEl.value) return;
    (Array.isArray(t.target.value) || t.target.value.offsetParent || t.target.value.getClientRects().length) && (m = vh(t.target.value));
    const y = vC(t.contentEl.value, t.isRtl.value), C = cr(t.contentEl.value), M = 12;
    C.length || (C.push(document.documentElement), t.contentEl.value.style.top && t.contentEl.value.style.left || (y.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), y.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
    const p = C.reduce((I, k) => {
      const G = Iv(k);
      return I ? new Rn({
        x: Math.max(I.left, G.left),
        y: Math.max(I.top, G.top),
        width: Math.min(I.right, G.right) - Math.max(I.left, G.left),
        height: Math.min(I.bottom, G.bottom) - Math.max(I.top, G.top)
      }) : G;
    }, void 0);
    p.x += M, p.y += M, p.width -= M * 2, p.height -= M * 2;
    let b = {
      anchor: a.value,
      origin: o.value
    };
    function P(I) {
      const k = new Rn(y), G = Pc(I.anchor, m), F = Pc(I.origin, k);
      let {
        x: q,
        y: j
      } = hC(G, F);
      switch (I.anchor.side) {
        case "top":
          j -= c.value[0];
          break;
        case "bottom":
          j += c.value[0];
          break;
        case "left":
          q -= c.value[0];
          break;
        case "right":
          q += c.value[0];
          break;
      }
      switch (I.anchor.align) {
        case "top":
          j -= c.value[1];
          break;
        case "bottom":
          j += c.value[1];
          break;
        case "left":
          q -= c.value[1];
          break;
        case "right":
          q += c.value[1];
          break;
      }
      return k.x += q, k.y += j, k.width = Math.min(k.width, s.value), k.height = Math.min(k.height, u.value), {
        overflows: nc(k, p),
        x: q,
        y: j
      };
    }
    let x = 0, _ = 0;
    const T = {
      x: 0,
      y: 0
    }, B = {
      x: !1,
      y: !1
    };
    let L = -1;
    for (; ; ) {
      if (L++ > 10) {
        yh("Infinite loop detected in connectedLocationStrategy");
        break;
      }
      const {
        x: I,
        y: k,
        overflows: G
      } = P(b);
      x += I, _ += k, y.x += I, y.y += k;
      {
        const F = tc(b.anchor), q = G.x.before || G.x.after, j = G.y.before || G.y.after;
        let ne = !1;
        if (["x", "y"].forEach((A) => {
          if (A === "x" && q && !B.x || A === "y" && j && !B.y) {
            const R = {
              anchor: {
                ...b.anchor
              },
              origin: {
                ...b.origin
              }
            }, V = A === "x" ? F === "y" ? fl : hl : F === "y" ? hl : fl;
            R.anchor = V(R.anchor), R.origin = V(R.origin);
            const {
              overflows: X
            } = P(R);
            (X[A].before <= G[A].before && X[A].after <= G[A].after || X[A].before + X[A].after < (G[A].before + G[A].after) / 2) && (b = R, ne = B[A] = !0);
          }
        }), ne) continue;
      }
      G.x.before && (x += G.x.before, y.x += G.x.before), G.x.after && (x -= G.x.after, y.x -= G.x.after), G.y.before && (_ += G.y.before, y.y += G.y.before), G.y.after && (_ -= G.y.after, y.y -= G.y.after);
      {
        const F = nc(y, p);
        T.x = p.width - F.x.before - F.x.after, T.y = p.height - F.y.before - F.y.after, x += F.x.before, y.x += F.x.before, _ += F.y.before, y.y += F.y.before;
      }
      break;
    }
    const z = tc(b.anchor);
    return Object.assign(n.value, {
      "--v-overlay-anchor-origin": `${b.anchor.side} ${b.anchor.align}`,
      transformOrigin: `${b.origin.side} ${b.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: he(_l(_)),
      left: t.isRtl.value ? void 0 : he(_l(x)),
      right: t.isRtl.value ? he(_l(-x)) : void 0,
      minWidth: he(z === "y" ? Math.min(r.value, m.width) : r.value),
      maxWidth: he(Tc(Gt(T.x, r.value === 1 / 0 ? 0 : r.value, s.value))),
      maxHeight: he(Tc(Gt(T.y, l.value === 1 / 0 ? 0 : l.value, u.value)))
    }), {
      available: T,
      contentBox: y,
      flipped: B
    };
  }
  return ie(() => [a.value, o.value, e.offset, e.minWidth, e.minHeight, e.maxWidth, e.maxHeight], () => v()), Ye(() => {
    const y = v();
    if (!y) return;
    const {
      available: C,
      contentBox: M
    } = y;
    M.height > C.y && requestAnimationFrame(() => {
      v(), requestAnimationFrame(() => {
        v();
      });
    });
  }), {
    updateLocation: v
  };
}
function _l(t) {
  return Math.round(t * devicePixelRatio) / devicePixelRatio;
}
function Tc(t) {
  return Math.ceil(t * devicePixelRatio) / devicePixelRatio;
}
let Jl = !0;
const fr = [];
function CC(t) {
  !Jl || fr.length ? (fr.push(t), Ql()) : (Jl = !1, t(), Ql());
}
let wc = -1;
function Ql() {
  cancelAnimationFrame(wc), wc = requestAnimationFrame(() => {
    const t = fr.shift();
    t && t(), fr.length ? Ql() : Jl = !0;
  });
}
const ir = {
  none: null,
  close: SC,
  block: bC,
  reposition: MC
}, pC = U({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (t) => typeof t == "function" || t in ir
  }
}, "VOverlay-scroll-strategies");
function _C(t, e) {
  if (!nt) return;
  let n;
  Pt(async () => {
    n == null || n.stop(), e.isActive.value && t.scrollStrategy && (n = Ms(), await new Promise((i) => setTimeout(i)), n.active && n.run(() => {
      var i;
      typeof t.scrollStrategy == "function" ? t.scrollStrategy(e, t, n) : (i = ir[t.scrollStrategy]) == null || i.call(ir, e, t, n);
    }));
  }), _t(() => {
    n == null || n.stop();
  });
}
function SC(t) {
  function e(n) {
    t.isActive.value = !1;
  }
  yf(t.targetEl.value ?? t.contentEl.value, e);
}
function bC(t, e) {
  var r;
  const n = (r = t.root.value) == null ? void 0 : r.offsetParent, i = [.../* @__PURE__ */ new Set([...cr(t.targetEl.value, e.contained ? n : void 0), ...cr(t.contentEl.value, e.contained ? n : void 0)])].filter((l) => !l.classList.contains("v-overlay-scroll-blocked")), a = window.innerWidth - document.documentElement.offsetWidth, o = ((l) => Ls(l) && l)(n || document.documentElement);
  o && t.root.value.classList.add("v-overlay--scroll-blocked"), i.forEach((l, s) => {
    l.style.setProperty("--v-body-scroll-x", he(-l.scrollLeft)), l.style.setProperty("--v-body-scroll-y", he(-l.scrollTop)), l !== document.documentElement && l.style.setProperty("--v-scrollbar-offset", he(a)), l.classList.add("v-overlay-scroll-blocked");
  }), _t(() => {
    i.forEach((l, s) => {
      const u = parseFloat(l.style.getPropertyValue("--v-body-scroll-x")), c = parseFloat(l.style.getPropertyValue("--v-body-scroll-y")), d = l.style.scrollBehavior;
      l.style.scrollBehavior = "auto", l.style.removeProperty("--v-body-scroll-x"), l.style.removeProperty("--v-body-scroll-y"), l.style.removeProperty("--v-scrollbar-offset"), l.classList.remove("v-overlay-scroll-blocked"), l.scrollLeft = -u, l.scrollTop = -c, l.style.scrollBehavior = d;
    }), o && t.root.value.classList.remove("v-overlay--scroll-blocked");
  });
}
function MC(t, e, n) {
  let i = !1, a = -1, o = -1;
  function r(l) {
    CC(() => {
      var c, d;
      const s = performance.now();
      (d = (c = t.updateLocation).value) == null || d.call(c, l), i = (performance.now() - s) / (1e3 / 60) > 2;
    });
  }
  o = (typeof requestIdleCallback > "u" ? (l) => l() : requestIdleCallback)(() => {
    n.run(() => {
      yf(t.targetEl.value ?? t.contentEl.value, (l) => {
        i ? (cancelAnimationFrame(a), a = requestAnimationFrame(() => {
          a = requestAnimationFrame(() => {
            r(l);
          });
        })) : r(l);
      });
    });
  }), _t(() => {
    typeof cancelIdleCallback < "u" && cancelIdleCallback(o), cancelAnimationFrame(a);
  });
}
function yf(t, e) {
  const n = [document, ...cr(t)];
  n.forEach((i) => {
    i.addEventListener("scroll", e, {
      passive: !0
    });
  }), _t(() => {
    n.forEach((i) => {
      i.removeEventListener("scroll", e);
    });
  });
}
const es = Symbol.for("vuetify:v-menu"), Cf = U({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function pf(t, e) {
  let n = () => {
  };
  function i(r) {
    n == null || n();
    const l = Number(r ? t.openDelay : t.closeDelay);
    return new Promise((s) => {
      n = Mv(l, () => {
        e == null || e(r), s(r);
      });
    });
  }
  function a() {
    return i(!0);
  }
  function o() {
    return i(!1);
  }
  return {
    clearDelay: n,
    runOpenDelay: a,
    runCloseDelay: o
  };
}
const xC = U({
  target: [String, Object],
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...Cf()
}, "VOverlay-activator");
function PC(t, e) {
  let {
    isActive: n,
    isTop: i,
    contentEl: a
  } = e;
  const o = Qe("useActivator"), r = Z();
  let l = !1, s = !1, u = !0;
  const c = E(() => t.openOnFocus || t.openOnFocus == null && t.openOnHover), d = E(() => t.openOnClick || t.openOnClick == null && !t.openOnHover && !c.value), {
    runOpenDelay: h,
    runCloseDelay: f
  } = pf(t, (_) => {
    _ === (t.openOnHover && l || c.value && s) && !(t.openOnHover && n.value && !i.value) && (n.value !== _ && (u = !0), n.value = _);
  }), g = Z(), m = {
    onClick: (_) => {
      _.stopPropagation(), r.value = _.currentTarget || _.target, n.value || (g.value = [_.clientX, _.clientY]), n.value = !n.value;
    },
    onMouseenter: (_) => {
      var T;
      (T = _.sourceCapabilities) != null && T.firesTouchEvents || (l = !0, r.value = _.currentTarget || _.target, h());
    },
    onMouseleave: (_) => {
      l = !1, f();
    },
    onFocus: (_) => {
      ya(_.target, ":focus-visible") !== !1 && (s = !0, _.stopPropagation(), r.value = _.currentTarget || _.target, h());
    },
    onBlur: (_) => {
      s = !1, _.stopPropagation(), f();
    }
  }, v = E(() => {
    const _ = {};
    return d.value && (_.onClick = m.onClick), t.openOnHover && (_.onMouseenter = m.onMouseenter, _.onMouseleave = m.onMouseleave), c.value && (_.onFocus = m.onFocus, _.onBlur = m.onBlur), _;
  }), y = E(() => {
    const _ = {};
    if (t.openOnHover && (_.onMouseenter = () => {
      l = !0, h();
    }, _.onMouseleave = () => {
      l = !1, f();
    }), c.value && (_.onFocusin = () => {
      s = !0, h();
    }, _.onFocusout = () => {
      s = !1, f();
    }), t.closeOnContentClick) {
      const T = Ne(es, null);
      _.onClick = () => {
        n.value = !1, T == null || T.closeParents();
      };
    }
    return _;
  }), C = E(() => {
    const _ = {};
    return t.openOnHover && (_.onMouseenter = () => {
      u && (l = !0, u = !1, h());
    }, _.onMouseleave = () => {
      l = !1, f();
    }), _;
  });
  ie(i, (_) => {
    var T;
    _ && (t.openOnHover && !l && (!c.value || !s) || c.value && !s && (!t.openOnHover || !l)) && !((T = a.value) != null && T.contains(document.activeElement)) && (n.value = !1);
  }), ie(n, (_) => {
    _ || setTimeout(() => {
      g.value = void 0;
    });
  }, {
    flush: "post"
  });
  const M = Wl();
  Pt(() => {
    M.value && Ye(() => {
      r.value = M.el;
    });
  });
  const p = Wl(), b = E(() => t.target === "cursor" && g.value ? g.value : p.value ? p.el : _f(t.target, o) || r.value), P = E(() => Array.isArray(b.value) ? void 0 : b.value);
  let x;
  return ie(() => !!t.activator, (_) => {
    _ && nt ? (x = Ms(), x.run(() => {
      TC(t, o, {
        activatorEl: r,
        activatorEvents: v
      });
    })) : x && x.stop();
  }, {
    flush: "post",
    immediate: !0
  }), _t(() => {
    x == null || x.stop();
  }), {
    activatorEl: r,
    activatorRef: M,
    target: b,
    targetEl: P,
    targetRef: p,
    activatorEvents: v,
    contentEvents: y,
    scrimEvents: C
  };
}
function TC(t, e, n) {
  let {
    activatorEl: i,
    activatorEvents: a
  } = n;
  ie(() => t.activator, (s, u) => {
    if (u && s !== u) {
      const c = l(u);
      c && r(c);
    }
    s && Ye(() => o());
  }, {
    immediate: !0
  }), ie(() => t.activatorProps, () => {
    o();
  }), _t(() => {
    r();
  });
  function o() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : l(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t.activatorProps;
    s && zv(s, oe(a.value, u));
  }
  function r() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : l(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t.activatorProps;
    s && Lv(s, oe(a.value, u));
  }
  function l() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : t.activator;
    const u = _f(s, e);
    return i.value = (u == null ? void 0 : u.nodeType) === Node.ELEMENT_NODE ? u : void 0, i.value;
  }
}
function _f(t, e) {
  var i, a;
  if (!t) return;
  let n;
  if (t === "parent") {
    let o = (a = (i = e == null ? void 0 : e.proxy) == null ? void 0 : i.$el) == null ? void 0 : a.parentNode;
    for (; o != null && o.hasAttribute("data-no-activator"); )
      o = o.parentNode;
    n = o;
  } else typeof t == "string" ? n = document.querySelector(t) : "$el" in t ? n = t.$el : n = t;
  return n;
}
function wC() {
  if (!nt) return Q(!1);
  const {
    ssr: t
  } = Vr();
  if (t) {
    const e = Q(!1);
    return at(() => {
      e.value = !0;
    }), e;
  } else
    return Q(!0);
}
const Xs = U({
  eager: Boolean
}, "lazy");
function Us(t, e) {
  const n = Q(!1), i = O(() => n.value || t.eager || e.value);
  ie(e, () => n.value = !0);
  function a() {
    t.eager || (n.value = !1);
  }
  return {
    isBooted: n,
    hasContent: i,
    onAfterLeave: a
  };
}
function Ys() {
  const e = Qe("useScopeId").vnode.scopeId;
  return {
    scopeId: e ? {
      [e]: ""
    } : void 0
  };
}
const Ec = Symbol.for("vuetify:stack"), Oa = cn([]);
function EC(t, e, n) {
  const i = Qe("useStack"), a = !n, o = Ne(Ec, void 0), r = cn({
    activeChildren: /* @__PURE__ */ new Set()
  });
  ht(Ec, r);
  const l = Q(Number(Vn(e)));
  Nt(t, () => {
    var d;
    const c = (d = Oa.at(-1)) == null ? void 0 : d[1];
    l.value = c ? c + 10 : Number(Vn(e)), a && Oa.push([i.uid, l.value]), o == null || o.activeChildren.add(i.uid), _t(() => {
      if (a) {
        const h = lt(Oa).findIndex((f) => f[0] === i.uid);
        Oa.splice(h, 1);
      }
      o == null || o.activeChildren.delete(i.uid);
    });
  });
  const s = Q(!0);
  a && Pt(() => {
    var d;
    const c = ((d = Oa.at(-1)) == null ? void 0 : d[0]) === i.uid;
    setTimeout(() => s.value = c);
  });
  const u = O(() => !r.activeChildren.size);
  return {
    globalTop: Ir(s),
    localTop: u,
    stackStyles: O(() => ({
      zIndex: l.value
    }))
  };
}
function AC(t) {
  return {
    teleportTarget: E(() => {
      const n = t();
      if (n === !0 || !nt) return;
      const i = n === !1 ? document.body : typeof n == "string" ? document.querySelector(n) : n;
      if (i == null) {
        Ar(`Unable to locate target ${n}`);
        return;
      }
      let a = [...i.children].find((o) => o.matches(".v-overlay-container"));
      return a || (a = document.createElement("div"), a.className = "v-overlay-container", i.appendChild(a)), a;
    })
  };
}
function RC() {
  return !0;
}
function Sf(t, e, n) {
  if (!t || bf(t, n) === !1) return !1;
  const i = _h(e);
  if (typeof ShadowRoot < "u" && i instanceof ShadowRoot && i.host === t.target) return !1;
  const a = (typeof n.value == "object" && n.value.include || (() => []))();
  return a.push(e), !a.some((o) => o == null ? void 0 : o.contains(t.target));
}
function bf(t, e) {
  return (typeof e.value == "object" && e.value.closeConditional || RC)(t);
}
function IC(t, e, n) {
  const i = typeof n.value == "function" ? n.value : n.value.handler;
  t.shadowTarget = t.target, e._clickOutside.lastMousedownWasOutside && Sf(t, e, n) && setTimeout(() => {
    bf(t, n) && i && i(t);
  }, 0);
}
function Ac(t, e) {
  const n = _h(t);
  e(document), typeof ShadowRoot < "u" && n instanceof ShadowRoot && e(n);
}
const Rc = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(t, e) {
    const n = (a) => IC(a, t, e), i = (a) => {
      t._clickOutside.lastMousedownWasOutside = Sf(a, t, e);
    };
    Ac(t, (a) => {
      a.addEventListener("click", n, !0), a.addEventListener("mousedown", i, !0);
    }), t._clickOutside || (t._clickOutside = {
      lastMousedownWasOutside: !1
    }), t._clickOutside[e.instance.$.uid] = {
      onClick: n,
      onMousedown: i
    };
  },
  beforeUnmount(t, e) {
    t._clickOutside && (Ac(t, (n) => {
      var o;
      if (!n || !((o = t._clickOutside) != null && o[e.instance.$.uid])) return;
      const {
        onClick: i,
        onMousedown: a
      } = t._clickOutside[e.instance.$.uid];
      n.removeEventListener("click", i, !0), n.removeEventListener("mousedown", a, !0);
    }), delete t._clickOutside[e.instance.$.uid]);
  }
};
function zC(t) {
  const {
    modelValue: e,
    color: n,
    ...i
  } = t;
  return S(Si, {
    name: "fade-transition",
    appear: !0
  }, {
    default: () => [t.modelValue && w("div", oe({
      class: ["v-overlay__scrim", t.color.backgroundColorClasses.value],
      style: t.color.backgroundColorStyles.value
    }, i), null)]
  });
}
const Mf = U({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: !0
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  opacity: [Number, String],
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...xC(),
  ...ve(),
  ...ln(),
  ...Xs(),
  ...fC(),
  ...pC(),
  ...Ue(),
  ...Ea()
}, "VOverlay"), Ic = ee()({
  name: "VOverlay",
  directives: {
    vClickOutside: Rc
  },
  inheritAttrs: !1,
  props: {
    _disableGlobalStack: Boolean,
    ...Mf()
  },
  emits: {
    "click:outside": (t) => !0,
    "update:modelValue": (t) => !0,
    keydown: (t) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(t, e) {
    let {
      slots: n,
      attrs: i,
      emit: a
    } = e;
    const o = Qe("VOverlay"), r = Z(), l = Z(), s = Z(), u = Xe(t, "modelValue"), c = E({
      get: () => u.value,
      set: (K) => {
        K && t.disabled || (u.value = K);
      }
    }), {
      themeClasses: d
    } = et(t), {
      rtlClasses: h,
      isRtl: f
    } = Wt(), {
      hasContent: g,
      onAfterLeave: m
    } = Us(t, c), v = xt(() => typeof t.scrim == "string" ? t.scrim : null), {
      globalTop: y,
      localTop: C,
      stackStyles: M
    } = EC(c, () => t.zIndex, t._disableGlobalStack), {
      activatorEl: p,
      activatorRef: b,
      target: P,
      targetEl: x,
      targetRef: _,
      activatorEvents: T,
      contentEvents: B,
      scrimEvents: L
    } = PC(t, {
      isActive: c,
      isTop: C,
      contentEl: s
    }), {
      teleportTarget: z
    } = AC(() => {
      var ge, $, ae;
      const K = t.attach || t.contained;
      if (K) return K;
      const se = ((ge = p == null ? void 0 : p.value) == null ? void 0 : ge.getRootNode()) || ((ae = ($ = o.proxy) == null ? void 0 : $.$el) == null ? void 0 : ae.getRootNode());
      return se instanceof ShadowRoot ? se : !1;
    }), {
      dimensionStyles: I
    } = sn(t), k = wC(), {
      scopeId: G
    } = Ys();
    ie(() => t.disabled, (K) => {
      K && (c.value = !1);
    });
    const {
      contentStyles: F,
      updateLocation: q
    } = gC(t, {
      isRtl: f,
      contentEl: s,
      target: P,
      isActive: c
    });
    _C(t, {
      root: r,
      contentEl: s,
      targetEl: x,
      isActive: c,
      updateLocation: q
    });
    function j(K) {
      a("click:outside", K), t.persistent ? D() : c.value = !1;
    }
    function ne(K) {
      return c.value && y.value && // If using scrim, only close if clicking on it rather than anything opened on top
      (!t.scrim || K.target === l.value || K instanceof MouseEvent && K.shadowTarget === l.value);
    }
    nt && ie(c, (K) => {
      K ? window.addEventListener("keydown", A) : window.removeEventListener("keydown", A);
    }, {
      immediate: !0
    }), pt(() => {
      nt && window.removeEventListener("keydown", A);
    });
    function A(K) {
      var se, ge, $;
      K.key === "Escape" && y.value && ((se = s.value) != null && se.contains(document.activeElement) || a("keydown", K), t.persistent ? D() : (c.value = !1, (ge = s.value) != null && ge.contains(document.activeElement) && (($ = p.value) == null || $.focus())));
    }
    function R(K) {
      K.key === "Escape" && !y.value || a("keydown", K);
    }
    const V = Qh();
    Nt(() => t.closeOnBack, () => {
      Ny(V, (K) => {
        y.value && c.value ? (K(!1), t.persistent ? D() : c.value = !1) : K();
      });
    });
    const X = Z();
    ie(() => c.value && (t.absolute || t.contained) && z.value == null, (K) => {
      if (K) {
        const se = Sh(r.value);
        se && se !== document.scrollingElement && (X.value = se.scrollTop);
      }
    });
    function D() {
      t.noClickAnimation || s.value && sa(s.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: ur
      });
    }
    function Y() {
      a("afterEnter");
    }
    function ce() {
      m(), a("afterLeave");
    }
    return le(() => {
      var K;
      return w(pe, null, [(K = n.activator) == null ? void 0 : K.call(n, {
        isActive: c.value,
        targetRef: _,
        props: oe({
          ref: b
        }, T.value, t.activatorProps)
      }), k.value && g.value && S(Wm, {
        disabled: !z.value,
        to: z.value
      }, {
        default: () => [w("div", oe({
          class: ["v-overlay", {
            "v-overlay--absolute": t.absolute || t.contained,
            "v-overlay--active": c.value,
            "v-overlay--contained": t.contained
          }, d.value, h.value, t.class],
          style: [M.value, {
            "--v-overlay-opacity": t.opacity,
            top: he(X.value)
          }, t.style],
          ref: r,
          onKeydown: R
        }, G, i), [S(zC, oe({
          color: v,
          modelValue: c.value && !!t.scrim,
          ref: l
        }, L.value), null), S(Jn, {
          appear: !0,
          persisted: !0,
          transition: t.transition,
          target: P.value,
          onAfterEnter: Y,
          onAfterLeave: ce
        }, {
          default: () => {
            var se;
            return [it(w("div", oe({
              ref: s,
              class: ["v-overlay__content", t.contentClass],
              style: [I.value, F.value]
            }, B.value, t.contentProps), [(se = n.default) == null ? void 0 : se.call(n, {
              isActive: c
            })]), [[Pi, c.value], [Rc, {
              handler: j,
              closeConditional: ne,
              include: () => [p.value]
            }]])];
          }
        })])]
      })]);
    }), {
      activatorEl: p,
      scrimEl: l,
      target: P,
      animateClick: D,
      contentEl: s,
      globalTop: y,
      localTop: C,
      updateLocation: q
    };
  }
}), LC = U({
  // TODO
  // disableKeys: Boolean,
  id: String,
  submenu: Boolean,
  disableInitialFocus: Boolean,
  ...Xi(Mf({
    closeDelay: 250,
    closeOnContentClick: !0,
    locationStrategy: "connected",
    location: void 0,
    openDelay: 300,
    scrim: !1,
    scrollStrategy: "reposition",
    transition: {
      component: Nh
    }
  }), ["absolute"])
}, "VMenu"), Or = ee()({
  name: "VMenu",
  props: LC(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Xe(t, "modelValue"), {
      scopeId: a
    } = Ys(), {
      isRtl: o
    } = Wt(), r = Ti(), l = O(() => t.id || `v-menu-${r}`), s = Z(), u = Ne(es, null), c = Q(/* @__PURE__ */ new Set());
    ht(es, {
      register() {
        c.value.add(r);
      },
      unregister() {
        c.value.delete(r);
      },
      closeParents(v) {
        setTimeout(() => {
          var y;
          !c.value.size && !t.persistent && (v == null || (y = s.value) != null && y.contentEl && !xv(v, s.value.contentEl)) && (i.value = !1, u == null || u.closeParents());
        }, 40);
      }
    }), pt(() => {
      u == null || u.unregister(), document.removeEventListener("focusin", d);
    }), xs(() => i.value = !1);
    async function d(v) {
      var M, p, b;
      const y = v.relatedTarget, C = v.target;
      await Ye(), i.value && y !== C && ((M = s.value) != null && M.contentEl) && // We're the topmost menu
      ((p = s.value) != null && p.globalTop) && // It isn't the document or the menu body
      ![document, s.value.contentEl].includes(C) && // It isn't inside the menu body
      !s.value.contentEl.contains(C) && ((b = rr(s.value.contentEl)[0]) == null || b.focus());
    }
    ie(i, (v) => {
      v ? (u == null || u.register(), nt && !t.disableInitialFocus && document.addEventListener("focusin", d, {
        once: !0
      })) : (u == null || u.unregister(), nt && document.removeEventListener("focusin", d));
    }, {
      immediate: !0
    });
    function h(v) {
      u == null || u.closeParents(v);
    }
    function f(v) {
      var y, C, M, p, b;
      if (!t.disabled)
        if (v.key === "Tab" || v.key === "Enter" && !t.closeOnContentClick) {
          if (v.key === "Enter" && (v.target instanceof HTMLTextAreaElement || v.target instanceof HTMLInputElement && v.target.closest("form"))) return;
          v.key === "Enter" && v.preventDefault(), gh(rr((y = s.value) == null ? void 0 : y.contentEl, !1), v.shiftKey ? "prev" : "next", (x) => x.tabIndex >= 0) || (i.value = !1, (M = (C = s.value) == null ? void 0 : C.activatorEl) == null || M.focus());
        } else t.submenu && v.key === (o.value ? "ArrowRight" : "ArrowLeft") && (i.value = !1, (b = (p = s.value) == null ? void 0 : p.activatorEl) == null || b.focus());
    }
    function g(v) {
      var C;
      if (t.disabled) return;
      const y = (C = s.value) == null ? void 0 : C.contentEl;
      y && i.value ? v.key === "ArrowDown" ? (v.preventDefault(), v.stopImmediatePropagation(), Ha(y, "next")) : v.key === "ArrowUp" ? (v.preventDefault(), v.stopImmediatePropagation(), Ha(y, "prev")) : t.submenu && (v.key === (o.value ? "ArrowRight" : "ArrowLeft") ? i.value = !1 : v.key === (o.value ? "ArrowLeft" : "ArrowRight") && (v.preventDefault(), Ha(y, "first"))) : (t.submenu ? v.key === (o.value ? "ArrowLeft" : "ArrowRight") : ["ArrowDown", "ArrowUp"].includes(v.key)) && (i.value = !0, v.preventDefault(), setTimeout(() => setTimeout(() => g(v))));
    }
    const m = E(() => oe({
      "aria-haspopup": "menu",
      "aria-expanded": String(i.value),
      "aria-controls": l.value,
      onKeydown: g
    }, t.activatorProps));
    return le(() => {
      const v = Ic.filterProps(t);
      return S(Ic, oe({
        ref: s,
        id: l.value,
        class: ["v-menu", t.class],
        style: t.style
      }, v, {
        modelValue: i.value,
        "onUpdate:modelValue": (y) => i.value = y,
        absolute: !0,
        activatorProps: m.value,
        location: t.location ?? (t.submenu ? "end" : "bottom"),
        "onClick:outside": h,
        onKeydown: f
      }, a), {
        activator: n.activator,
        default: function() {
          for (var y = arguments.length, C = new Array(y), M = 0; M < y; M++)
            C[M] = arguments[M];
          return S(We, {
            root: "VMenu"
          }, {
            default: () => {
              var p;
              return [(p = n.default) == null ? void 0 : p.call(n, ...C)];
            }
          });
        }
      });
    }), Ra({
      id: l,
      openChildren: c
    }, s);
  }
}), VC = U({
  active: Boolean,
  disabled: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...ve(),
  ...Ea({
    transition: {
      component: Wh
    }
  })
}, "VCounter"), xf = ee()({
  name: "VCounter",
  functional: !0,
  props: VC(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = O(() => t.max ? `${t.value} / ${t.max}` : String(t.value));
    return le(() => S(Jn, {
      transition: t.transition
    }, {
      default: () => [it(w("div", {
        class: te(["v-counter", {
          "text-error": t.max && !t.disabled && parseFloat(t.value) > parseFloat(t.max)
        }, t.class]),
        style: re(t.style)
      }, [n.default ? n.default({
        counter: i.value,
        max: t.max,
        value: t.value
      }) : i.value]), [[Pi, t.active]])]
    })), {};
  }
}), BC = U({
  floating: Boolean,
  ...ve()
}, "VFieldLabel"), Xo = ee()({
  name: "VFieldLabel",
  props: BC(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return le(() => S(Ph, {
      class: te(["v-field-label", {
        "v-field-label--floating": t.floating
      }, t.class]),
      style: re(t.style)
    }, n)), {};
  }
});
function Pf(t, e) {
  const n = Z(), i = Q(!1);
  if (Ts) {
    const a = new IntersectionObserver((o) => {
      i.value = !!o.find((r) => r.isIntersecting);
    }, e);
    _t(() => {
      a.disconnect();
    }), ie(n, (o, r) => {
      r && (a.unobserve(r), i.value = !1), o && a.observe(o);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef: n,
    isIntersecting: i
  };
}
const zc = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, Dr = U({
  location: String
}, "location");
function Gr(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl: i
  } = Wt();
  return {
    locationStyles: E(() => {
      if (!t.location) return {};
      const {
        side: o,
        align: r
      } = Xl(t.location.split(" ").length > 1 ? t.location : `${t.location} center`, i.value);
      function l(u) {
        return n ? n(u) : 0;
      }
      const s = {};
      return o !== "center" && (e ? s[zc[o]] = `calc(100% - ${l(o)}px)` : s[o] = 0), r !== "center" ? e ? s[zc[r]] = `calc(100% - ${l(r)}px)` : s[r] = 0 : (o === "center" ? s.top = s.left = "50%" : s[{
        top: "left",
        bottom: "left",
        left: "top",
        right: "top"
      }[o]] = "50%", s.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[o]), s;
    })
  };
}
const FC = U({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: !0
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  bufferColor: String,
  bufferOpacity: [Number, String],
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  opacity: [Number, String],
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...ve(),
  ...Dr({
    location: "top"
  }),
  ...Tt(),
  ...Oe(),
  ...Ue()
}, "VProgressLinear"), Tf = ee()({
  name: "VProgressLinear",
  props: FC(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    var L;
    let {
      slots: n
    } = e;
    const i = Xe(t, "modelValue"), {
      isRtl: a,
      rtlClasses: o
    } = Wt(), {
      themeClasses: r
    } = et(t), {
      locationStyles: l
    } = Gr(t), {
      textColorClasses: s,
      textColorStyles: u
    } = Bn(() => t.color), {
      backgroundColorClasses: c,
      backgroundColorStyles: d
    } = xt(() => t.bgColor || t.color), {
      backgroundColorClasses: h,
      backgroundColorStyles: f
    } = xt(() => t.bufferColor || t.bgColor || t.color), {
      backgroundColorClasses: g,
      backgroundColorStyles: m
    } = xt(() => t.color), {
      roundedClasses: v
    } = wt(t), {
      intersectionRef: y,
      isIntersecting: C
    } = Pf(), M = E(() => parseFloat(t.max)), p = E(() => parseFloat(t.height)), b = E(() => Gt(parseFloat(t.bufferValue) / M.value * 100, 0, 100)), P = E(() => Gt(parseFloat(i.value) / M.value * 100, 0, 100)), x = E(() => a.value !== t.reverse), _ = E(() => t.indeterminate ? "fade-transition" : "slide-x-transition"), T = nt && ((L = window.matchMedia) == null ? void 0 : L.call(window, "(forced-colors: active)").matches);
    function B(z) {
      if (!y.value) return;
      const {
        left: I,
        right: k,
        width: G
      } = y.value.getBoundingClientRect(), F = x.value ? G - z.clientX + (k - G) : z.clientX - I;
      i.value = Math.round(F / G * M.value);
    }
    return le(() => S(t.tag, {
      ref: y,
      class: te(["v-progress-linear", {
        "v-progress-linear--absolute": t.absolute,
        "v-progress-linear--active": t.active && C.value,
        "v-progress-linear--reverse": x.value,
        "v-progress-linear--rounded": t.rounded,
        "v-progress-linear--rounded-bar": t.roundedBar,
        "v-progress-linear--striped": t.striped
      }, v.value, r.value, o.value, t.class]),
      style: re([{
        bottom: t.location === "bottom" ? 0 : void 0,
        top: t.location === "top" ? 0 : void 0,
        height: t.active ? he(p.value) : 0,
        "--v-progress-linear-height": he(p.value),
        ...t.absolute ? l.value : {}
      }, t.style]),
      role: "progressbar",
      "aria-hidden": t.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": t.max,
      "aria-valuenow": t.indeterminate ? void 0 : Math.min(parseFloat(i.value), M.value),
      onClick: t.clickable && B
    }, {
      default: () => [t.stream && w("div", {
        key: "stream",
        class: te(["v-progress-linear__stream", s.value]),
        style: {
          ...u.value,
          [x.value ? "left" : "right"]: he(-p.value),
          borderTop: `${he(p.value / 2)} dotted`,
          opacity: parseFloat(t.bufferOpacity),
          top: `calc(50% - ${he(p.value / 4)})`,
          width: he(100 - b.value, "%"),
          "--v-progress-linear-stream-to": he(p.value * (x.value ? 1 : -1))
        }
      }, null), w("div", {
        class: te(["v-progress-linear__background", T ? void 0 : c.value]),
        style: re([d.value, {
          opacity: parseFloat(t.bgOpacity),
          width: t.stream ? 0 : void 0
        }])
      }, null), w("div", {
        class: te(["v-progress-linear__buffer", T ? void 0 : h.value]),
        style: re([f.value, {
          opacity: parseFloat(t.bufferOpacity),
          width: he(b.value, "%")
        }])
      }, null), S(Si, {
        name: _.value
      }, {
        default: () => [t.indeterminate ? w("div", {
          class: "v-progress-linear__indeterminate"
        }, [["long", "short"].map((z) => w("div", {
          key: z,
          class: te(["v-progress-linear__indeterminate", z, T ? void 0 : g.value]),
          style: re(m.value)
        }, null))]) : w("div", {
          class: te(["v-progress-linear__determinate", T ? void 0 : g.value]),
          style: re([m.value, {
            width: he(P.value, "%")
          }])
        }, null)]
      }), n.default && w("div", {
        class: "v-progress-linear__content"
      }, [n.default({
        value: P.value,
        buffer: b.value
      })])]
    })), {};
  }
}), js = U({
  loading: [Boolean, String]
}, "loader");
function Hs(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : On();
  return {
    loaderClasses: O(() => ({
      [`${e}--loading`]: t.loading
    }))
  };
}
function wf(t, e) {
  var i;
  let {
    slots: n
  } = e;
  return w("div", {
    class: te(`${t.name}__loader`)
  }, [((i = n.default) == null ? void 0 : i.call(n, {
    color: t.color,
    isActive: t.active
  })) || S(Tf, {
    absolute: t.absolute,
    active: t.active,
    color: t.color,
    height: "2",
    indeterminate: !0
  }, null)]);
}
const kC = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"], Zs = U({
  appendInnerIcon: Pe,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: Pe,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  details: Boolean,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  glow: Boolean,
  error: Boolean,
  flat: Boolean,
  iconColor: [Boolean, String],
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: Pe,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (t) => kC.includes(t)
  },
  "onClick:clear": Bt(),
  "onClick:appendInner": Bt(),
  "onClick:prependInner": Bt(),
  ...ve(),
  ...js(),
  ...Tt(),
  ...Ue()
}, "VField"), gr = ee()({
  name: "VField",
  inheritAttrs: !1,
  props: {
    id: String,
    ...Xh(),
    ...Zs()
  },
  emits: {
    "update:focused": (t) => !0,
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      attrs: n,
      emit: i,
      slots: a
    } = e;
    const {
      themeClasses: o
    } = et(t), {
      loaderClasses: r
    } = Hs(t), {
      focusClasses: l,
      isFocused: s,
      focus: u,
      blur: c
    } = Fs(t), {
      InputIcon: d
    } = Oh(t), {
      roundedClasses: h
    } = wt(t), {
      rtlClasses: f
    } = Wt(), g = O(() => t.dirty || t.active), m = O(() => !!(t.label || a.label)), v = O(() => !t.singleLine && m.value), y = Ti(), C = E(() => t.id || `input-${y}`), M = O(() => t.details ? `${C.value}-messages` : void 0), p = Z(), b = Z(), P = Z(), x = E(() => ["plain", "underlined"].includes(t.variant)), _ = E(() => t.error || t.disabled ? void 0 : g.value && s.value ? t.color : t.baseColor), T = E(() => {
      if (!(!t.iconColor || t.glow && !s.value))
        return t.iconColor === !0 ? _.value : t.iconColor;
    }), {
      backgroundColorClasses: B,
      backgroundColorStyles: L
    } = xt(() => t.bgColor), {
      textColorClasses: z,
      textColorStyles: I
    } = Bn(_);
    ie(g, (F) => {
      if (v.value) {
        const q = p.value.$el, j = b.value.$el;
        requestAnimationFrame(() => {
          const ne = zs(q), A = j.getBoundingClientRect(), R = A.x - ne.x, V = A.y - ne.y - (ne.height / 2 - A.height / 2), X = A.width / 0.75, D = Math.abs(X - ne.width) > 1 ? {
            maxWidth: he(X)
          } : void 0, Y = getComputedStyle(q), ce = getComputedStyle(j), K = parseFloat(Y.transitionDuration) * 1e3 || 150, se = parseFloat(ce.getPropertyValue("--v-field-label-scale")), ge = ce.getPropertyValue("color");
          q.style.visibility = "visible", j.style.visibility = "hidden", sa(q, {
            transform: `translate(${R}px, ${V}px) scale(${se})`,
            color: ge,
            ...D
          }, {
            duration: K,
            easing: ur,
            direction: F ? "normal" : "reverse"
          }).finished.then(() => {
            q.style.removeProperty("visibility"), j.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const k = E(() => ({
      isActive: g,
      isFocused: s,
      controlRef: P,
      blur: c,
      focus: u
    }));
    function G(F) {
      F.target !== document.activeElement && F.preventDefault();
    }
    return le(() => {
      var R, V, X;
      const F = t.variant === "outlined", q = !!(a["prepend-inner"] || t.prependInnerIcon), j = !!(t.clearable || a.clear) && !t.disabled, ne = !!(a["append-inner"] || t.appendInnerIcon || j), A = () => a.label ? a.label({
        ...k.value,
        label: t.label,
        props: {
          for: C.value
        }
      }) : t.label;
      return w("div", oe({
        class: ["v-field", {
          "v-field--active": g.value,
          "v-field--appended": ne,
          "v-field--center-affix": t.centerAffix ?? !x.value,
          "v-field--disabled": t.disabled,
          "v-field--dirty": t.dirty,
          "v-field--error": t.error,
          "v-field--glow": t.glow,
          "v-field--flat": t.flat,
          "v-field--has-background": !!t.bgColor,
          "v-field--persistent-clear": t.persistentClear,
          "v-field--prepended": q,
          "v-field--reverse": t.reverse,
          "v-field--single-line": t.singleLine,
          "v-field--no-label": !A(),
          [`v-field--variant-${t.variant}`]: !0
        }, o.value, B.value, l.value, r.value, h.value, f.value, t.class],
        style: [L.value, t.style],
        onClick: G
      }, n), [w("div", {
        class: "v-field__overlay"
      }, null), S(wf, {
        name: "v-field",
        active: !!t.loading,
        color: t.error ? "error" : typeof t.loading == "string" ? t.loading : t.color
      }, {
        default: a.loader
      }), q && w("div", {
        key: "prepend",
        class: "v-field__prepend-inner"
      }, [t.prependInnerIcon && S(d, {
        key: "prepend-icon",
        name: "prependInner",
        color: T.value
      }, null), (R = a["prepend-inner"]) == null ? void 0 : R.call(a, k.value)]), w("div", {
        class: "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(t.variant) && v.value && S(Xo, {
        key: "floating-label",
        ref: b,
        class: te([z.value]),
        floating: !0,
        for: C.value,
        "aria-hidden": !g.value,
        style: re(I.value)
      }, {
        default: () => [A()]
      }), m.value && S(Xo, {
        key: "label",
        ref: p,
        for: C.value
      }, {
        default: () => [A()]
      }), ((V = a.default) == null ? void 0 : V.call(a, {
        ...k.value,
        props: {
          id: C.value,
          class: "v-field__input",
          "aria-describedby": M.value
        },
        focus: u,
        blur: c
      })) ?? w("div", {
        id: C.value,
        class: "v-field__input",
        "aria-describedby": M.value
      }, null)]), j && S($h, {
        key: "clear"
      }, {
        default: () => [it(w("div", {
          class: "v-field__clearable",
          onMousedown: (D) => {
            D.preventDefault(), D.stopPropagation();
          }
        }, [S(We, {
          defaults: {
            VIcon: {
              icon: t.clearIcon
            }
          }
        }, {
          default: () => [a.clear ? a.clear({
            ...k.value,
            props: {
              onFocus: u,
              onBlur: c,
              onClick: t["onClick:clear"],
              tabindex: -1
            }
          }) : S(d, {
            name: "clear",
            onFocus: u,
            onBlur: c,
            tabindex: -1
          }, null)]
        })]), [[Pi, t.dirty]])]
      }), ne && w("div", {
        key: "append",
        class: "v-field__append-inner"
      }, [(X = a["append-inner"]) == null ? void 0 : X.call(a, k.value), t.appendInnerIcon && S(d, {
        key: "append-icon",
        name: "appendInner",
        color: T.value
      }, null)]), w("div", {
        class: te(["v-field__outline", z.value]),
        style: re(I.value)
      }, [F && w(pe, null, [w("div", {
        class: "v-field__outline__start"
      }, null), v.value && w("div", {
        class: "v-field__outline__notch"
      }, [S(Xo, {
        ref: b,
        floating: !0,
        for: C.value,
        "aria-hidden": !g.value
      }, {
        default: () => [A()]
      })]), w("div", {
        class: "v-field__outline__end"
      }, null)]), x.value && v.value && S(Xo, {
        ref: b,
        floating: !0,
        for: C.value,
        "aria-hidden": !g.value
      }, {
        default: () => [A()]
      })])]);
    }), {
      controlRef: P,
      fieldIconColor: T
    };
  }
});
function Ef(t) {
  function e(n, i) {
    var a, o;
    !t.autofocus || !n || (o = (a = i[0].target) == null ? void 0 : a.focus) == null || o.call(a);
  }
  return {
    onIntersect: e
  };
}
const OC = ["color", "file", "time", "date", "datetime-local", "week", "month"], Ks = U({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: [Number, Function],
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  role: String,
  type: {
    type: String,
    default: "text"
  },
  modelModifiers: Object,
  ...Os(),
  ...Zs()
}, "VTextField"), Qn = ee()({
  name: "VTextField",
  directives: {
    vIntersect: Ca
  },
  inheritAttrs: !1,
  props: Ks(),
  emits: {
    "click:control": (t) => !0,
    "mousedown:control": (t) => !0,
    "update:focused": (t) => !0,
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      attrs: n,
      emit: i,
      slots: a
    } = e;
    const o = Xe(t, "modelValue"), {
      isFocused: r,
      focus: l,
      blur: s
    } = Fs(t), {
      onIntersect: u
    } = Ef(t), c = E(() => typeof t.counterValue == "function" ? t.counterValue(o.value) : typeof t.counterValue == "number" ? t.counterValue : (o.value ?? "").toString().length), d = E(() => {
      if (n.maxlength) return n.maxlength;
      if (!(!t.counter || typeof t.counter != "number" && typeof t.counter != "string"))
        return t.counter;
    }), h = E(() => ["plain", "underlined"].includes(t.variant)), f = Z(), g = Z(), m = Z(), v = E(() => OC.includes(t.type) || t.persistentPlaceholder || r.value || t.active);
    function y() {
      r.value || l(), Ye(() => {
        m.value !== document.activeElement && Ye(() => {
          var P;
          return (P = m.value) == null ? void 0 : P.focus();
        });
      });
    }
    function C(P) {
      i("mousedown:control", P), P.target !== m.value && (y(), P.preventDefault());
    }
    function M(P) {
      i("click:control", P);
    }
    function p(P, x) {
      P.stopPropagation(), y(), Ye(() => {
        o.value = null, x(), As(t["onClick:clear"], P);
      });
    }
    function b(P) {
      var _;
      const x = P.target;
      if (o.value = x.value, (_ = t.modelModifiers) != null && _.trim && ["text", "search", "password", "tel", "url"].includes(t.type)) {
        const T = [x.selectionStart, x.selectionEnd];
        Ye(() => {
          x.selectionStart = T[0], x.selectionEnd = T[1];
        });
      }
    }
    return le(() => {
      const P = !!(a.counter || t.counter !== !1 && t.counter != null), x = !!(P || a.details), [_, T] = ws(n), {
        modelValue: B,
        ...L
      } = hr.filterProps(t), z = gr.filterProps(t);
      return S(hr, oe({
        ref: f,
        modelValue: o.value,
        "onUpdate:modelValue": (I) => o.value = I,
        class: ["v-text-field", {
          "v-text-field--prefixed": t.prefix,
          "v-text-field--suffixed": t.suffix,
          "v-input--plain-underlined": h.value
        }, t.class],
        style: t.style
      }, _, L, {
        centerAffix: !h.value,
        focused: r.value
      }), {
        ...a,
        default: (I) => {
          let {
            id: k,
            isDisabled: G,
            isDirty: F,
            isReadonly: q,
            isValid: j,
            hasDetails: ne,
            reset: A
          } = I;
          return S(gr, oe({
            ref: g,
            onMousedown: C,
            onClick: M,
            "onClick:clear": (R) => p(R, A),
            "onClick:prependInner": t["onClick:prependInner"],
            "onClick:appendInner": t["onClick:appendInner"],
            role: t.role
          }, z, {
            id: k.value,
            active: v.value || F.value,
            dirty: F.value || t.dirty,
            disabled: G.value,
            focused: r.value,
            details: ne.value,
            error: j.value === !1
          }), {
            ...a,
            default: (R) => {
              let {
                props: {
                  class: V,
                  ...X
                }
              } = R;
              const D = it(w("input", oe({
                ref: m,
                value: o.value,
                onInput: b,
                autofocus: t.autofocus,
                readonly: q.value,
                disabled: G.value,
                name: t.name,
                placeholder: t.placeholder,
                size: 1,
                type: t.type,
                onFocus: y,
                onBlur: s
              }, X, T), null), [[Ca, {
                handler: u
              }, null, {
                once: !0
              }]]);
              return w(pe, null, [t.prefix && w("span", {
                class: "v-text-field__prefix"
              }, [w("span", {
                class: "v-text-field__prefix__text"
              }, [t.prefix])]), a.default ? w("div", {
                class: te(V),
                "data-no-activator": ""
              }, [a.default(), D]) : $m(D, {
                class: V
              }), t.suffix && w("span", {
                class: "v-text-field__suffix"
              }, [w("span", {
                class: "v-text-field__suffix__text"
              }, [t.suffix])])]);
            }
          });
        },
        details: x ? (I) => {
          var k;
          return w(pe, null, [(k = a.details) == null ? void 0 : k.call(a, I), P && w(pe, null, [w("span", null, null), S(xf, {
            active: t.persistentCounter || r.value,
            value: c.value,
            max: d.value,
            disabled: t.disabled
          }, a.counter)])]);
        } : void 0
      });
    }), Ra({}, f, g, m);
  }
}), DC = U({
  renderless: Boolean,
  ...ve()
}, "VVirtualScrollItem"), GC = ee()({
  name: "VVirtualScrollItem",
  inheritAttrs: !1,
  props: DC(),
  emits: {
    "update:height": (t) => !0
  },
  setup(t, e) {
    let {
      attrs: n,
      emit: i,
      slots: a
    } = e;
    const {
      resizeRef: o,
      contentRect: r
    } = Wi(void 0, "border");
    ie(() => {
      var l;
      return (l = r.value) == null ? void 0 : l.height;
    }, (l) => {
      l != null && i("update:height", l);
    }), le(() => {
      var l, s;
      return t.renderless ? w(pe, null, [(l = a.default) == null ? void 0 : l.call(a, {
        itemRef: o
      })]) : w("div", oe({
        ref: o,
        class: ["v-virtual-scroll__item", t.class],
        style: t.style
      }, n), [(s = a.default) == null ? void 0 : s.call(a)]);
    });
  }
}), NC = -1, WC = 1, Sl = 100, $C = U({
  itemHeight: {
    type: [Number, String],
    default: null
  },
  itemKey: {
    type: [String, Array, Function],
    default: null
  },
  height: [Number, String]
}, "virtual");
function XC(t, e) {
  const n = Vr(), i = Q(0);
  Pt(() => {
    i.value = parseFloat(t.itemHeight || 0);
  });
  const a = Q(0), o = Q(Math.ceil(
    // Assume 16px items filling the entire screen height if
    // not provided. This is probably incorrect but it minimises
    // the chance of ending up with empty space at the bottom.
    // The default value is set here to avoid poisoning getSize()
    (parseInt(t.height) || n.height.value) / (i.value || 16)
  ) || 1), r = Q(0), l = Q(0), s = Z(), u = Z();
  let c = 0;
  const {
    resizeRef: d,
    contentRect: h
  } = Wi();
  Pt(() => {
    d.value = s.value;
  });
  const f = E(() => {
    var A;
    return s.value === document.documentElement ? n.height.value : ((A = h.value) == null ? void 0 : A.height) || parseInt(t.height) || 0;
  }), g = E(() => !!(s.value && u.value && f.value && i.value));
  let m = Array.from({
    length: e.value.length
  }), v = Array.from({
    length: e.value.length
  });
  const y = Q(0);
  let C = -1;
  function M(A) {
    return m[A] || i.value;
  }
  const p = _v(() => {
    const A = performance.now();
    v[0] = 0;
    const R = e.value.length;
    for (let V = 1; V <= R - 1; V++)
      v[V] = (v[V - 1] || 0) + M(V - 1);
    y.value = Math.max(y.value, performance.now() - A);
  }, y), b = ie(g, (A) => {
    A && (b(), c = u.value.offsetTop, p.immediate(), F(), ~C && Ye(() => {
      nt && window.requestAnimationFrame(() => {
        j(C), C = -1;
      });
    }));
  });
  _t(() => {
    p.clear();
  });
  function P(A, R) {
    const V = m[A], X = i.value;
    i.value = X ? Math.min(i.value, R) : R, (V !== R || X !== i.value) && (m[A] = R, p());
  }
  function x(A) {
    A = Gt(A, 0, e.value.length - 1);
    const R = Math.floor(A), V = A % 1, X = R + 1, D = v[R] || 0, Y = v[X] || D;
    return D + (Y - D) * V;
  }
  function _(A) {
    return UC(v, A);
  }
  let T = 0, B = 0, L = 0;
  ie(f, (A, R) => {
    R && (F(), A < R && requestAnimationFrame(() => {
      B = 0, F();
    }));
  });
  let z = -1;
  function I() {
    if (!s.value || !u.value) return;
    const A = s.value.scrollTop, R = performance.now();
    R - L > 500 ? (B = Math.sign(A - T), c = u.value.offsetTop) : B = A - T, T = A, L = R, window.clearTimeout(z), z = window.setTimeout(k, 500), F();
  }
  function k() {
    !s.value || !u.value || (B = 0, L = 0, window.clearTimeout(z), F());
  }
  let G = -1;
  function F() {
    cancelAnimationFrame(G), G = requestAnimationFrame(q);
  }
  function q() {
    if (!s.value || !f.value || !i.value) return;
    const A = T - c, R = Math.sign(B), V = Math.max(0, A - Sl), X = Gt(_(V), 0, e.value.length), D = A + f.value + Sl, Y = Gt(_(D) + 1, X + 1, e.value.length);
    if (
      // Only update the side we're scrolling towards,
      // the other side will be updated incidentally
      (R !== NC || X < a.value) && (R !== WC || Y > o.value)
    ) {
      const ce = x(a.value) - x(X), K = x(Y) - x(o.value);
      Math.max(ce, K) > Sl ? (a.value = X, o.value = Y) : (X <= 0 && (a.value = X), Y >= e.value.length && (o.value = Y));
    }
    r.value = x(a.value), l.value = x(e.value.length) - x(o.value);
  }
  function j(A) {
    const R = x(A);
    !s.value || A && !R ? C = A : s.value.scrollTop = R;
  }
  const ne = E(() => e.value.slice(a.value, o.value).map((A, R) => {
    const V = R + a.value;
    return {
      raw: A,
      index: V,
      key: Jt(A, t.itemKey, V)
    };
  }));
  return ie(e, () => {
    m = Array.from({
      length: e.value.length
    }), v = Array.from({
      length: e.value.length
    }), p.immediate(), F();
  }, {
    deep: 1
  }), {
    calculateVisibleItems: F,
    containerRef: s,
    markerRef: u,
    computedItems: ne,
    paddingTop: r,
    paddingBottom: l,
    scrollToIndex: j,
    handleScroll: I,
    handleScrollend: k,
    handleItemResize: P
  };
}
function UC(t, e) {
  let n = t.length - 1, i = 0, a = 0, o = null, r = -1;
  if (t[n] < e)
    return n;
  for (; i <= n; )
    if (a = i + n >> 1, o = t[a], o > e)
      n = a - 1;
    else if (o < e)
      r = a, i = a + 1;
    else return o === e ? a : i;
  return r;
}
const YC = U({
  items: {
    type: Array,
    default: () => []
  },
  renderless: Boolean,
  ...$C(),
  ...ve(),
  ...ln()
}, "VVirtualScroll"), Af = ee()({
  name: "VVirtualScroll",
  props: YC(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Qe("VVirtualScroll"), {
      dimensionStyles: a
    } = sn(t), {
      calculateVisibleItems: o,
      containerRef: r,
      markerRef: l,
      handleScroll: s,
      handleScrollend: u,
      handleItemResize: c,
      scrollToIndex: d,
      paddingTop: h,
      paddingBottom: f,
      computedItems: g
    } = XC(t, O(() => t.items));
    return Nt(() => t.renderless, () => {
      function m() {
        var C, M;
        const y = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) ? "addEventListener" : "removeEventListener";
        r.value === document.documentElement ? (document[y]("scroll", s, {
          passive: !0
        }), document[y]("scrollend", u)) : ((C = r.value) == null || C[y]("scroll", s, {
          passive: !0
        }), (M = r.value) == null || M[y]("scrollend", u));
      }
      at(() => {
        r.value = Sh(i.vnode.el, !0), m(!0);
      }), _t(m);
    }), le(() => {
      const m = g.value.map((v) => S(GC, {
        key: v.key,
        renderless: t.renderless,
        "onUpdate:height": (y) => c(v.index, y)
      }, {
        default: (y) => {
          var C;
          return (C = n.default) == null ? void 0 : C.call(n, {
            item: v.raw,
            index: v.index,
            ...y
          });
        }
      }));
      return t.renderless ? w(pe, null, [w("div", {
        ref: l,
        class: "v-virtual-scroll__spacer",
        style: {
          paddingTop: he(h.value)
        }
      }, null), m, w("div", {
        class: "v-virtual-scroll__spacer",
        style: {
          paddingBottom: he(f.value)
        }
      }, null)]) : w("div", {
        ref: r,
        class: te(["v-virtual-scroll", t.class]),
        onScrollPassive: s,
        onScrollend: u,
        style: re([a.value, t.style])
      }, [w("div", {
        ref: l,
        class: "v-virtual-scroll__container",
        style: {
          paddingTop: he(h.value),
          paddingBottom: he(f.value)
        }
      }, [m])]);
    }), {
      calculateVisibleItems: o,
      scrollToIndex: d
    };
  }
});
function Rf(t, e) {
  const n = Q(!1);
  let i;
  function a(l) {
    cancelAnimationFrame(i), n.value = !0, i = requestAnimationFrame(() => {
      i = requestAnimationFrame(() => {
        n.value = !1;
      });
    });
  }
  async function o() {
    await new Promise((l) => requestAnimationFrame(l)), await new Promise((l) => requestAnimationFrame(l)), await new Promise((l) => requestAnimationFrame(l)), await new Promise((l) => {
      if (n.value) {
        const s = ie(n, () => {
          s(), l();
        });
      } else l();
    });
  }
  async function r(l) {
    var c, d;
    if (l.key === "Tab" && ((c = e.value) == null || c.focus()), !["PageDown", "PageUp", "Home", "End"].includes(l.key)) return;
    const s = (d = t.value) == null ? void 0 : d.$el;
    if (!s) return;
    (l.key === "Home" || l.key === "End") && s.scrollTo({
      top: l.key === "Home" ? 0 : s.scrollHeight,
      behavior: "smooth"
    }), await o();
    const u = s.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
    if (l.key === "PageDown" || l.key === "Home") {
      const h = s.getBoundingClientRect().top;
      for (const f of u)
        if (f.getBoundingClientRect().top >= h) {
          f.focus();
          break;
        }
    } else {
      const h = s.getBoundingClientRect().bottom;
      for (const f of [...u].reverse())
        if (f.getBoundingClientRect().bottom <= h) {
          f.focus();
          break;
        }
    }
  }
  return {
    onScrollPassive: a,
    onKeydown: r
  };
}
const If = U({
  chips: Boolean,
  closableChips: Boolean,
  closeText: {
    type: String,
    default: "$vuetify.close"
  },
  openText: {
    type: String,
    default: "$vuetify.open"
  },
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  listProps: {
    type: Object
  },
  menu: Boolean,
  menuIcon: {
    type: Pe,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  itemColor: String,
  noAutoScroll: Boolean,
  ...hf({
    itemChildren: !1
  })
}, "Select"), jC = U({
  ...If(),
  ...Xi(Ks({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Ea({
    transition: {
      component: Nh
    }
  })
}, "VSelect");
ee()({
  name: "VSelect",
  props: jC(),
  emits: {
    "update:focused": (t) => !0,
    "update:modelValue": (t) => !0,
    "update:menu": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      t: i
    } = Aa(), a = Z(), o = Z(), r = Z(), {
      items: l,
      transformIn: s,
      transformOut: u
    } = gf(t), c = Xe(t, "modelValue", [], (A) => s(A === null ? [null] : Vt(A)), (A) => {
      const R = u(A);
      return t.multiple ? R : R[0] ?? null;
    }), d = E(() => typeof t.counterValue == "function" ? t.counterValue(c.value) : typeof t.counterValue == "number" ? t.counterValue : c.value.length), h = ks(t), f = E(() => c.value.map((A) => A.value)), g = Q(!1);
    let m = "", v = -1, y;
    const C = E(() => t.hideSelected ? l.value.filter((A) => !c.value.some((R) => (t.valueComparator || en)(R, A))) : l.value), M = E(() => t.hideNoData && !C.value.length || h.isReadonly.value || h.isDisabled.value), p = Xe(t, "menu"), b = E({
      get: () => p.value,
      set: (A) => {
        var R;
        p.value && !A && ((R = o.value) != null && R.openChildren.size) || A && M.value || (p.value = A);
      }
    }), P = O(() => b.value ? t.closeText : t.openText), x = E(() => {
      var A;
      return {
        ...t.menuProps,
        activatorProps: {
          ...((A = t.menuProps) == null ? void 0 : A.activatorProps) || {},
          "aria-haspopup": "listbox"
          // Set aria-haspopup to 'listbox'
        }
      };
    }), _ = Z(), T = Rf(_, a);
    function B(A) {
      t.openOnClear && (b.value = !0);
    }
    function L() {
      M.value || (b.value = !b.value);
    }
    function z(A) {
      lr(A) && I(A);
    }
    function I(A) {
      var ge, $, ae;
      if (!A.key || h.isReadonly.value) return;
      ["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(A.key) && A.preventDefault(), ["Enter", "ArrowDown", " "].includes(A.key) && (b.value = !0), ["Escape", "Tab"].includes(A.key) && (b.value = !1), A.key === "Home" ? (ge = _.value) == null || ge.focus("first") : A.key === "End" && (($ = _.value) == null || $.focus("last"));
      const R = 1e3;
      if (!lr(A)) return;
      const V = performance.now();
      V - y > R && (m = "", v = -1), m += A.key.toLowerCase(), y = V;
      const X = C.value;
      function D() {
        let ye = Y();
        return ye || m.at(-1) === m.at(-2) && (m = m.slice(0, -1), ye = Y(), ye) || (v = -1, ye = Y(), ye) ? ye : (m = A.key.toLowerCase(), Y());
      }
      function Y() {
        for (let ye = v + 1; ye < X.length; ye++) {
          const me = X[ye];
          if (me.title.toLowerCase().startsWith(m))
            return [me, ye];
        }
      }
      const ce = D();
      if (!ce) return;
      const [K, se] = ce;
      v = se, (ae = _.value) == null || ae.focus(se), t.multiple || (c.value = [K]);
    }
    function k(A) {
      let R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!A.props.disabled)
        if (t.multiple) {
          const V = c.value.findIndex((D) => (t.valueComparator || en)(D.value, A.value)), X = R ?? !~V;
          if (~V) {
            const D = X ? [...c.value, A] : [...c.value];
            D.splice(V, 1), c.value = D;
          } else X && (c.value = [...c.value, A]);
        } else {
          const V = R !== !1;
          c.value = V ? [A] : [], Ye(() => {
            b.value = !1;
          });
        }
    }
    function G(A) {
      var R;
      (R = _.value) != null && R.$el.contains(A.relatedTarget) || (b.value = !1);
    }
    function F() {
      var A;
      t.eager && ((A = r.value) == null || A.calculateVisibleItems());
    }
    function q() {
      var A;
      g.value && ((A = a.value) == null || A.focus());
    }
    function j(A) {
      g.value = !0;
    }
    function ne(A) {
      if (A == null) c.value = [];
      else if (ya(a.value, ":autofill") || ya(a.value, ":-webkit-autofill")) {
        const R = l.value.find((V) => V.title === A);
        R && k(R);
      } else a.value && (a.value.value = "");
    }
    return ie(b, () => {
      if (!t.hideSelected && b.value && c.value.length) {
        const A = C.value.findIndex((R) => c.value.some((V) => (t.valueComparator || en)(V.value, R.value)));
        nt && !t.noAutoScroll && window.requestAnimationFrame(() => {
          var R;
          A >= 0 && ((R = r.value) == null || R.scrollToIndex(A));
        });
      }
    }), ie(() => t.items, (A, R) => {
      b.value || g.value && t.hideNoData && !R.length && A.length && (b.value = !0);
    }), le(() => {
      const A = !!(t.chips || n.chip), R = !!(!t.hideNoData || C.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), V = c.value.length > 0, X = Qn.filterProps(t), D = V || !g.value && t.label && !t.persistentPlaceholder ? void 0 : t.placeholder;
      return S(Qn, oe({
        ref: a
      }, X, {
        modelValue: c.value.map((Y) => Y.props.value).join(", "),
        "onUpdate:modelValue": ne,
        focused: g.value,
        "onUpdate:focused": (Y) => g.value = Y,
        validationValue: c.externalValue,
        counterValue: d.value,
        dirty: V,
        class: ["v-select", {
          "v-select--active-menu": b.value,
          "v-select--chips": !!t.chips,
          [`v-select--${t.multiple ? "multiple" : "single"}`]: !0,
          "v-select--selected": c.value.length,
          "v-select--selection-slot": !!n.selection
        }, t.class],
        style: t.style,
        inputmode: "none",
        placeholder: D,
        "onClick:clear": B,
        "onMousedown:control": L,
        onBlur: G,
        onKeydown: I,
        "aria-label": i(P.value),
        title: i(P.value)
      }), {
        ...n,
        default: () => w(pe, null, [S(Or, oe({
          ref: o,
          modelValue: b.value,
          "onUpdate:modelValue": (Y) => b.value = Y,
          activator: "parent",
          contentClass: "v-select__content",
          disabled: M.value,
          eager: t.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: t.transition,
          onAfterEnter: F,
          onAfterLeave: q
        }, x.value), {
          default: () => [R && S(Ia, oe({
            ref: _,
            selected: f.value,
            selectStrategy: t.multiple ? "independent" : "single-independent",
            onMousedown: (Y) => Y.preventDefault(),
            onKeydown: z,
            onFocusin: j,
            tabindex: "-1",
            "aria-live": "polite",
            "aria-label": `${t.label}-list`,
            color: t.itemColor ?? t.color
          }, T, t.listProps), {
            default: () => {
              var Y, ce, K;
              return [(Y = n["prepend-item"]) == null ? void 0 : Y.call(n), !C.value.length && !t.hideNoData && (((ce = n["no-data"]) == null ? void 0 : ce.call(n)) ?? S(Fn, {
                key: "no-data",
                title: i(t.noDataText)
              }, null)), S(Af, {
                ref: r,
                renderless: !0,
                items: C.value,
                itemKey: "value"
              }, {
                default: (se) => {
                  var ze, je, He;
                  let {
                    item: ge,
                    index: $,
                    itemRef: ae
                  } = se;
                  const ye = Pv(ge.props), me = oe(ge.props, {
                    ref: ae,
                    key: ge.value,
                    onClick: () => k(ge, null)
                  });
                  return ge.type === "divider" ? ((ze = n.divider) == null ? void 0 : ze.call(n, {
                    props: ge.raw,
                    index: $
                  })) ?? S(Gs, oe(ge.props, {
                    key: `divider-${$}`
                  }), null) : ge.type === "subheader" ? ((je = n.subheader) == null ? void 0 : je.call(n, {
                    props: ge.raw,
                    index: $
                  })) ?? S($s, oe(ge.props, {
                    key: `subheader-${$}`
                  }), null) : ((He = n.item) == null ? void 0 : He.call(n, {
                    item: ge,
                    index: $,
                    props: me
                  })) ?? S(Fn, oe(me, {
                    role: "option"
                  }), {
                    prepend: (xe) => {
                      let {
                        isSelected: De
                      } = xe;
                      return w(pe, null, [t.multiple && !t.hideSelected ? S(Fh, {
                        key: ge.value,
                        modelValue: De,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, ye.prependAvatar && S(bi, {
                        image: ye.prependAvatar
                      }, null), ye.prependIcon && S(Be, {
                        icon: ye.prependIcon
                      }, null)]);
                    }
                  });
                }
              }), (K = n["append-item"]) == null ? void 0 : K.call(n)];
            }
          })]
        }), c.value.map((Y, ce) => {
          function K(ae) {
            ae.stopPropagation(), ae.preventDefault(), k(Y, !1);
          }
          const se = {
            "onClick:close": K,
            onKeydown(ae) {
              ae.key !== "Enter" && ae.key !== " " || (ae.preventDefault(), ae.stopPropagation(), K(ae));
            },
            onMousedown(ae) {
              ae.preventDefault(), ae.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, ge = A ? !!n.chip : !!n.selection, $ = ge ? Rs(A ? n.chip({
            item: Y,
            index: ce,
            props: se
          }) : n.selection({
            item: Y,
            index: ce
          })) : void 0;
          if (!(ge && !$))
            return w("div", {
              key: Y.value,
              class: "v-select__selection"
            }, [A ? n.chip ? S(We, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: t.closableChips,
                  size: "small",
                  text: Y.title
                }
              }
            }, {
              default: () => [$]
            }) : S(ef, oe({
              key: "chip",
              closable: t.closableChips,
              size: "small",
              text: Y.title,
              disabled: Y.props.disabled
            }, se), null) : $ ?? w("span", {
              class: "v-select__selection-text"
            }, [Y.title, t.multiple && ce < c.value.length - 1 && w("span", {
              class: "v-select__selection-comma"
            }, [ct(",")])])]);
        })]),
        "append-inner": function() {
          var se, ge;
          for (var Y = arguments.length, ce = new Array(Y), K = 0; K < Y; K++)
            ce[K] = arguments[K];
          return w(pe, null, [(se = n["append-inner"]) == null ? void 0 : se.call(n, ...ce), t.menuIcon ? S(Be, {
            class: "v-select__menu-icon",
            color: (ge = a.value) == null ? void 0 : ge.fieldIconColor,
            icon: t.menuIcon
          }, null) : void 0]);
        }
      });
    }), Ra({
      isFocused: g,
      menu: b,
      select: k
    }, a);
  }
});
const HC = (t, e, n) => {
  if (t == null || e == null) return -1;
  if (!e.length) return 0;
  t = t.toString().toLocaleLowerCase(), e = e.toString().toLocaleLowerCase();
  const i = [];
  let a = t.indexOf(e);
  for (; ~a; )
    i.push([a, a + e.length]), a = t.indexOf(e, a + e.length);
  return i.length ? i : -1;
};
function bl(t, e) {
  if (!(t == null || typeof t == "boolean" || t === -1))
    return typeof t == "number" ? [[t, t + e.length]] : Array.isArray(t[0]) ? t : [t];
}
const ZC = U({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function KC(t, e, n) {
  var l;
  const i = [], a = (n == null ? void 0 : n.default) ?? HC, o = n != null && n.filterKeys ? Vt(n.filterKeys) : !1, r = Object.keys((n == null ? void 0 : n.customKeyFilter) ?? {}).length;
  if (!(t != null && t.length)) return i;
  e: for (let s = 0; s < t.length; s++) {
    const [u, c = u] = Vt(t[s]), d = {}, h = {};
    let f = -1;
    if ((e || r > 0) && !(n != null && n.noFilter)) {
      if (typeof u == "object") {
        if (u.type === "divider" || u.type === "subheader")
          continue;
        const v = o || Object.keys(c);
        for (const y of v) {
          const C = Jt(c, y), M = (l = n == null ? void 0 : n.customKeyFilter) == null ? void 0 : l[y];
          if (f = M ? M(C, e, u) : a(C, e, u), f !== -1 && f !== !1)
            M ? d[y] = bl(f, e) : h[y] = bl(f, e);
          else if ((n == null ? void 0 : n.filterMode) === "every")
            continue e;
        }
      } else
        f = a(u, e, u), f !== -1 && f !== !1 && (h.title = bl(f, e));
      const g = Object.keys(h).length, m = Object.keys(d).length;
      if (!g && !m || (n == null ? void 0 : n.filterMode) === "union" && m !== r && !g || (n == null ? void 0 : n.filterMode) === "intersection" && (m !== r || !g)) continue;
    }
    i.push({
      index: s,
      matches: {
        ...h,
        ...d
      }
    });
  }
  return i;
}
function qC(t, e, n, i) {
  const a = Q([]), o = Q(/* @__PURE__ */ new Map()), r = E(() => W(e));
  Pt(() => {
    const s = typeof n == "function" ? n() : W(n), u = typeof s != "string" && typeof s != "number" ? "" : String(s), c = KC(r.value, u, {
      customKeyFilter: {
        ...t.customKeyFilter,
        ...W(i == null ? void 0 : i.customKeyFilter)
      },
      default: t.customFilter,
      filterKeys: t.filterKeys,
      filterMode: t.filterMode,
      noFilter: t.noFilter
    }), d = W(e), h = [], f = /* @__PURE__ */ new Map();
    c.forEach((g) => {
      let {
        index: m,
        matches: v
      } = g;
      const y = d[m];
      h.push(y), f.set(y.value, v);
    }), a.value = h, o.value = f;
  });
  function l(s) {
    return o.value.get(s.value);
  }
  return {
    filteredItems: a,
    filteredMatches: o,
    getMatches: l
  };
}
function JC(t, e, n) {
  return n == null || !n.length ? e : n.map((i, a) => {
    const o = a === 0 ? 0 : n[a - 1][1], r = [w("span", {
      class: te(`${t}__unmask`)
    }, [e.slice(o, i[0])]), w("span", {
      class: te(`${t}__mask`)
    }, [e.slice(i[0], i[1])])];
    return a === n.length - 1 && r.push(w("span", {
      class: te(`${t}__unmask`)
    }, [e.slice(i[1])])), w(pe, null, [r]);
  });
}
const QC = U({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: Boolean,
  search: String,
  ...ZC({
    filterKeys: ["title"]
  }),
  ...If(),
  ...Xi(Ks({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Ea({
    transition: !1
  })
}, "VAutocomplete"), Ml = ee()({
  name: "VAutocomplete",
  props: QC(),
  emits: {
    "update:focused": (t) => !0,
    "update:search": (t) => !0,
    "update:modelValue": (t) => !0,
    "update:menu": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      t: i
    } = Aa(), a = Z(), o = Q(!1), r = Q(!0), l = Q(!1), s = Z(), u = Z(), c = Q(-1), {
      items: d,
      transformIn: h,
      transformOut: f
    } = gf(t), {
      textColorClasses: g,
      textColorStyles: m
    } = Bn(() => {
      var $;
      return ($ = a.value) == null ? void 0 : $.color;
    }), v = Xe(t, "search", ""), y = Xe(t, "modelValue", [], ($) => h($ === null ? [null] : Vt($)), ($) => {
      const ae = f($);
      return t.multiple ? ae : ae[0] ?? null;
    }), C = E(() => typeof t.counterValue == "function" ? t.counterValue(y.value) : typeof t.counterValue == "number" ? t.counterValue : y.value.length), M = ks(t), {
      filteredItems: p,
      getMatches: b
    } = qC(t, d, () => r.value ? "" : v.value), P = E(() => t.hideSelected ? p.value.filter(($) => !y.value.some((ae) => ae.value === $.value)) : p.value), x = E(() => !!(t.chips || n.chip)), _ = E(() => x.value || !!n.selection), T = E(() => y.value.map(($) => $.props.value)), B = E(() => {
      var ae;
      return (t.autoSelectFirst === !0 || t.autoSelectFirst === "exact" && v.value === ((ae = P.value[0]) == null ? void 0 : ae.title)) && P.value.length > 0 && !r.value && !l.value;
    }), L = E(() => t.hideNoData && !P.value.length || M.isReadonly.value || M.isDisabled.value), z = Xe(t, "menu"), I = E({
      get: () => z.value,
      set: ($) => {
        var ae;
        z.value && !$ && ((ae = s.value) != null && ae.openChildren.size) || $ && L.value || (z.value = $);
      }
    }), k = E(() => I.value ? t.closeText : t.openText), G = Z(), F = Rf(G, a);
    function q($) {
      t.openOnClear && (I.value = !0), v.value = "";
    }
    function j() {
      L.value || (I.value = !0);
    }
    function ne($) {
      L.value || (o.value && ($.preventDefault(), $.stopPropagation()), I.value = !I.value);
    }
    function A($) {
      var ae;
      (lr($) || $.key === "Backspace") && ((ae = a.value) == null || ae.focus());
    }
    function R($) {
      var me, ze, je, He, xe;
      if (M.isReadonly.value) return;
      const ae = (me = a.value) == null ? void 0 : me.selectionStart, ye = y.value.length;
      if (["Enter", "ArrowDown", "ArrowUp"].includes($.key) && $.preventDefault(), ["Enter", "ArrowDown"].includes($.key) && (I.value = !0), ["Escape"].includes($.key) && (I.value = !1), B.value && ["Enter", "Tab"].includes($.key) && !y.value.some((De) => {
        let {
          value: Ze
        } = De;
        return Ze === P.value[0].value;
      }) && ge(P.value[0]), $.key === "ArrowDown" && B.value && ((ze = G.value) == null || ze.focus("next")), ["Backspace", "Delete"].includes($.key)) {
        if (!t.multiple && _.value && y.value.length > 0 && !v.value) return ge(y.value[0], !1);
        if (~c.value) {
          $.preventDefault();
          const De = c.value;
          ge(y.value[c.value], !1), c.value = De >= ye - 1 ? ye - 2 : De;
        } else $.key === "Backspace" && !v.value && (c.value = ye - 1);
        return;
      }
      if (t.multiple)
        if ($.key === "ArrowLeft") {
          if (c.value < 0 && ae && ae > 0) return;
          const De = c.value > -1 ? c.value - 1 : ye - 1;
          if (y.value[De])
            c.value = De;
          else {
            const Ze = ((je = v.value) == null ? void 0 : je.length) ?? null;
            c.value = -1, (He = a.value) == null || He.setSelectionRange(Ze, Ze);
          }
        } else if ($.key === "ArrowRight") {
          if (c.value < 0) return;
          const De = c.value + 1;
          y.value[De] ? c.value = De : (c.value = -1, (xe = a.value) == null || xe.setSelectionRange(0, 0));
        } else ~c.value && lr($) && (c.value = -1);
    }
    function V($) {
      if (ya(a.value, ":autofill") || ya(a.value, ":-webkit-autofill")) {
        const ae = d.value.find((ye) => ye.title === $.target.value);
        ae && ge(ae);
      }
    }
    function X() {
      var $;
      t.eager && (($ = u.value) == null || $.calculateVisibleItems());
    }
    function D() {
      var $;
      o.value && (r.value = !0, ($ = a.value) == null || $.focus());
    }
    function Y($) {
      o.value = !0, setTimeout(() => {
        l.value = !0;
      });
    }
    function ce($) {
      l.value = !1;
    }
    function K($) {
      ($ == null || $ === "" && !t.multiple && !_.value) && (y.value = []);
    }
    const se = Q(!1);
    function ge($) {
      let ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!$ || $.props.disabled))
        if (t.multiple) {
          const ye = y.value.findIndex((ze) => (t.valueComparator || en)(ze.value, $.value)), me = ae ?? !~ye;
          if (~ye) {
            const ze = me ? [...y.value, $] : [...y.value];
            ze.splice(ye, 1), y.value = ze;
          } else me && (y.value = [...y.value, $]);
          t.clearOnSelect && (v.value = "");
        } else {
          const ye = ae !== !1;
          y.value = ye ? [$] : [], v.value = ye && !_.value ? $.title : "", Ye(() => {
            I.value = !1, r.value = !0;
          });
        }
    }
    return ie(o, ($, ae) => {
      var ye;
      $ !== ae && ($ ? (se.value = !0, v.value = t.multiple || _.value ? "" : String(((ye = y.value.at(-1)) == null ? void 0 : ye.props.title) ?? ""), r.value = !0, Ye(() => se.value = !1)) : (!t.multiple && v.value == null && (y.value = []), I.value = !1, (t.multiple || _.value) && (v.value = ""), c.value = -1));
    }), ie(v, ($) => {
      !o.value || se.value || ($ && (I.value = !0), r.value = !$);
    }), ie(I, () => {
      if (!t.hideSelected && I.value && y.value.length) {
        const $ = P.value.findIndex((ae) => y.value.some((ye) => ae.value === ye.value));
        nt && window.requestAnimationFrame(() => {
          var ae;
          $ >= 0 && ((ae = u.value) == null || ae.scrollToIndex($));
        });
      }
    }), ie(() => t.items, ($, ae) => {
      I.value || o.value && !ae.length && $.length && (I.value = !0);
    }), le(() => {
      const $ = !!(!t.hideNoData || P.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), ae = y.value.length > 0, ye = Qn.filterProps(t);
      return S(Qn, oe({
        ref: a
      }, ye, {
        modelValue: v.value,
        "onUpdate:modelValue": [(me) => v.value = me, K],
        focused: o.value,
        "onUpdate:focused": (me) => o.value = me,
        validationValue: y.externalValue,
        counterValue: C.value,
        dirty: ae,
        onChange: V,
        class: ["v-autocomplete", `v-autocomplete--${t.multiple ? "multiple" : "single"}`, {
          "v-autocomplete--active-menu": I.value,
          "v-autocomplete--chips": !!t.chips,
          "v-autocomplete--selection-slot": !!_.value,
          "v-autocomplete--selecting-index": c.value > -1
        }, t.class],
        style: t.style,
        readonly: M.isReadonly.value,
        placeholder: ae ? void 0 : t.placeholder,
        "onClick:clear": q,
        "onMousedown:control": j,
        onKeydown: R
      }), {
        ...n,
        default: () => w(pe, null, [S(Or, oe({
          ref: s,
          modelValue: I.value,
          "onUpdate:modelValue": (me) => I.value = me,
          activator: "parent",
          contentClass: "v-autocomplete__content",
          disabled: L.value,
          eager: t.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: t.transition,
          onAfterEnter: X,
          onAfterLeave: D
        }, t.menuProps), {
          default: () => [$ && S(Ia, oe({
            ref: G,
            filterable: !0,
            selected: T.value,
            selectStrategy: t.multiple ? "independent" : "single-independent",
            onMousedown: (me) => me.preventDefault(),
            onKeydown: A,
            onFocusin: Y,
            onFocusout: ce,
            tabindex: "-1",
            "aria-live": "polite",
            color: t.itemColor ?? t.color
          }, F, t.listProps), {
            default: () => {
              var me, ze, je;
              return [(me = n["prepend-item"]) == null ? void 0 : me.call(n), !P.value.length && !t.hideNoData && (((ze = n["no-data"]) == null ? void 0 : ze.call(n)) ?? S(Fn, {
                key: "no-data",
                title: i(t.noDataText)
              }, null)), S(Af, {
                ref: u,
                renderless: !0,
                items: P.value,
                itemKey: "value"
              }, {
                default: (He) => {
                  var St, Xt, Sn;
                  let {
                    item: xe,
                    index: De,
                    itemRef: Ze
                  } = He;
                  const Et = oe(xe.props, {
                    ref: Ze,
                    key: xe.value,
                    active: B.value && De === 0 ? !0 : void 0,
                    onClick: () => ge(xe, null)
                  });
                  return xe.type === "divider" ? ((St = n.divider) == null ? void 0 : St.call(n, {
                    props: xe.raw,
                    index: De
                  })) ?? S(Gs, oe(xe.props, {
                    key: `divider-${De}`
                  }), null) : xe.type === "subheader" ? ((Xt = n.subheader) == null ? void 0 : Xt.call(n, {
                    props: xe.raw,
                    index: De
                  })) ?? S($s, oe(xe.props, {
                    key: `subheader-${De}`
                  }), null) : ((Sn = n.item) == null ? void 0 : Sn.call(n, {
                    item: xe,
                    index: De,
                    props: Et
                  })) ?? S(Fn, oe(Et, {
                    role: "option"
                  }), {
                    prepend: (Ut) => {
                      let {
                        isSelected: bn
                      } = Ut;
                      return w(pe, null, [t.multiple && !t.hideSelected ? S(Fh, {
                        key: xe.value,
                        modelValue: bn,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, xe.props.prependAvatar && S(bi, {
                        image: xe.props.prependAvatar
                      }, null), xe.props.prependIcon && S(Be, {
                        icon: xe.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var Ut;
                      return r.value ? xe.title : JC("v-autocomplete", xe.title, (Ut = b(xe)) == null ? void 0 : Ut.title);
                    }
                  });
                }
              }), (je = n["append-item"]) == null ? void 0 : je.call(n)];
            }
          })]
        }), y.value.map((me, ze) => {
          function je(Ze) {
            Ze.stopPropagation(), Ze.preventDefault(), ge(me, !1);
          }
          const He = {
            "onClick:close": je,
            onKeydown(Ze) {
              Ze.key !== "Enter" && Ze.key !== " " || (Ze.preventDefault(), Ze.stopPropagation(), je(Ze));
            },
            onMousedown(Ze) {
              Ze.preventDefault(), Ze.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, xe = x.value ? !!n.chip : !!n.selection, De = xe ? Rs(x.value ? n.chip({
            item: me,
            index: ze,
            props: He
          }) : n.selection({
            item: me,
            index: ze
          })) : void 0;
          if (!(xe && !De))
            return w("div", {
              key: me.value,
              class: te(["v-autocomplete__selection", ze === c.value && ["v-autocomplete__selection--selected", g.value]]),
              style: re(ze === c.value ? m.value : {})
            }, [x.value ? n.chip ? S(We, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: t.closableChips,
                  size: "small",
                  text: me.title
                }
              }
            }, {
              default: () => [De]
            }) : S(ef, oe({
              key: "chip",
              closable: t.closableChips,
              size: "small",
              text: me.title,
              disabled: me.props.disabled
            }, He), null) : De ?? w("span", {
              class: "v-autocomplete__selection-text"
            }, [me.title, t.multiple && ze < y.value.length - 1 && w("span", {
              class: "v-autocomplete__selection-comma"
            }, [ct(",")])])]);
        })]),
        "append-inner": function() {
          var He, xe;
          for (var me = arguments.length, ze = new Array(me), je = 0; je < me; je++)
            ze[je] = arguments[je];
          return w(pe, null, [(He = n["append-inner"]) == null ? void 0 : He.call(n, ...ze), t.menuIcon ? S(Be, {
            class: "v-autocomplete__menu-icon",
            color: (xe = a.value) == null ? void 0 : xe.fieldIconColor,
            icon: t.menuIcon,
            onMousedown: ne,
            onClick: bv,
            "aria-label": i(k.value),
            title: i(k.value),
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Ra({
      isFocused: o,
      isPristine: r,
      menu: I,
      search: v,
      filteredItems: p,
      select: ge
    }, a);
  }
}), ep = U({
  fluid: {
    type: Boolean,
    default: !1
  },
  ...ve(),
  ...ln(),
  ...Oe()
}, "VContainer"), gn = ee()({
  name: "VContainer",
  props: ep(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      rtlClasses: i
    } = Wt(), {
      dimensionStyles: a
    } = sn(t);
    return le(() => S(t.tag, {
      class: te(["v-container", {
        "v-container--fluid": t.fluid
      }, i.value, t.class]),
      style: re([a.value, t.style])
    }, n)), {};
  }
}), zf = Lr.reduce((t, e) => (t[e] = {
  type: [Boolean, String, Number],
  default: !1
}, t), {}), Lf = Lr.reduce((t, e) => {
  const n = "offset" + _o(e);
  return t[n] = {
    type: [String, Number],
    default: null
  }, t;
}, {}), Vf = Lr.reduce((t, e) => {
  const n = "order" + _o(e);
  return t[n] = {
    type: [String, Number],
    default: null
  }, t;
}, {}), Lc = {
  col: Object.keys(zf),
  offset: Object.keys(Lf),
  order: Object.keys(Vf)
};
function tp(t, e, n) {
  let i = t;
  if (!(n == null || n === !1)) {
    if (e) {
      const a = e.replace(t, "");
      i += `-${a}`;
    }
    return t === "col" && (i = "v-" + i), t === "col" && (n === "" || n === !0) || (i += `-${n}`), i.toLowerCase();
  }
}
const np = ["auto", "start", "end", "center", "baseline", "stretch"], ip = U({
  cols: {
    type: [Boolean, String, Number],
    default: !1
  },
  ...zf,
  offset: {
    type: [String, Number],
    default: null
  },
  ...Lf,
  order: {
    type: [String, Number],
    default: null
  },
  ...Vf,
  alignSelf: {
    type: String,
    default: null,
    validator: (t) => np.includes(t)
  },
  ...ve(),
  ...Oe()
}, "VCol"), dn = ee()({
  name: "VCol",
  props: ip(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = E(() => {
      const a = [];
      let o;
      for (o in Lc)
        Lc[o].forEach((l) => {
          const s = t[l], u = tp(o, l, s);
          u && a.push(u);
        });
      const r = a.some((l) => l.startsWith("v-col-"));
      return a.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        "v-col": !r || !t.cols,
        [`v-col-${t.cols}`]: t.cols,
        [`offset-${t.offset}`]: t.offset,
        [`order-${t.order}`]: t.order,
        [`align-self-${t.alignSelf}`]: t.alignSelf
      }), a;
    });
    return () => {
      var a;
      return Ta(t.tag, {
        class: [i.value, t.class],
        style: t.style
      }, (a = n.default) == null ? void 0 : a.call(n));
    };
  }
}), qs = ["start", "end", "center"], Bf = ["space-between", "space-around", "space-evenly"];
function Js(t, e) {
  return Lr.reduce((n, i) => {
    const a = t + _o(i);
    return n[a] = e(), n;
  }, {});
}
const ap = [...qs, "baseline", "stretch"], Ff = (t) => ap.includes(t), kf = Js("align", () => ({
  type: String,
  default: null,
  validator: Ff
})), op = [...qs, ...Bf], Of = (t) => op.includes(t), Df = Js("justify", () => ({
  type: String,
  default: null,
  validator: Of
})), rp = [...qs, ...Bf, "stretch"], Gf = (t) => rp.includes(t), Nf = Js("alignContent", () => ({
  type: String,
  default: null,
  validator: Gf
})), Vc = {
  align: Object.keys(kf),
  justify: Object.keys(Df),
  alignContent: Object.keys(Nf)
}, lp = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function sp(t, e, n) {
  let i = lp[t];
  if (n != null) {
    if (e) {
      const a = e.replace(t, "");
      i += `-${a}`;
    }
    return i += `-${n}`, i.toLowerCase();
  }
}
const up = U({
  dense: Boolean,
  noGutters: Boolean,
  align: {
    type: String,
    default: null,
    validator: Ff
  },
  ...kf,
  justify: {
    type: String,
    default: null,
    validator: Of
  },
  ...Df,
  alignContent: {
    type: String,
    default: null,
    validator: Gf
  },
  ...Nf,
  ...ve(),
  ...Oe()
}, "VRow"), pa = ee()({
  name: "VRow",
  props: up(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = E(() => {
      const a = [];
      let o;
      for (o in Vc)
        Vc[o].forEach((r) => {
          const l = t[r], s = sp(o, r, l);
          s && a.push(s);
        });
      return a.push({
        "v-row--no-gutters": t.noGutters,
        "v-row--dense": t.dense,
        [`align-${t.align}`]: t.align,
        [`justify-${t.justify}`]: t.justify,
        [`align-content-${t.alignContent}`]: t.alignContent
      }), a;
    });
    return () => {
      var a;
      return Ta(t.tag, {
        class: ["v-row", i.value, t.class],
        style: t.style
      }, (a = n.default) == null ? void 0 : a.call(n));
    };
  }
}), cp = {
  __name: "Address",
  setup(t) {
    const e = kn(), { data: n } = tn(e), i = n.value.store, a = i.addressMode, o = ih(), r = Z([]), l = Z([]), s = Z([]), u = (g = !1) => {
      o.region && o.province && !g || o.region && xn[o.region] && (l.value = Object.keys(xn[o.region]), o.province = "", s.value = [], o.city = "");
    }, c = (g = !1) => {
      var m;
      o.region && o.province && o.city && !g || o.province && ((m = xn[o.region]) != null && m[o.province]) && (s.value = xn[o.region][o.province], o.city = "");
    }, d = () => {
      for (const g in xn)
        if (xn[g][o.province]) {
          o.region = g, c();
          break;
        }
    }, h = () => {
      for (const g in xn)
        for (const m in xn[g]) {
          const v = xn[g][m];
          if (s.value.every((C) => v.includes(C))) {
            o.province = m, o.region = g;
            break;
          }
        }
    }, f = () => {
      a === 3 ? (s.value = i.cities, h(), o.city = "") : a === 2 && (o.province = i.province, d());
    };
    return ie(() => o.region, () => {
      a == 1 && (console.log("Cambio regione"), u(!0));
    }), ie(() => o.province, () => {
      a === 1 ? c(!0) : a === 2 && d();
    }), at(() => {
      o.region && (u(), o.province && c()), a === 1 ? r.value = Object.keys(xn) : f();
    }), (g, m) => (J(), Ie("div", null, [
      S(pa, null, {
        default: H(() => [
          S(dn, { cols: "6" }, {
            default: H(() => [
              S(Qn, {
                modelValue: W(o).firstname,
                "onUpdate:modelValue": m[0] || (m[0] = (v) => W(o).firstname = v),
                label: "Nome",
                placeholder: "Inserisci il nome",
                outlined: "",
                dense: "",
                rules: [(v) => !!v || "Campo obbligatorio"]
              }, null, 8, ["modelValue", "rules"])
            ]),
            _: 1
          }),
          S(dn, { cols: "6" }, {
            default: H(() => [
              S(Qn, {
                modelValue: W(o).lastname,
                "onUpdate:modelValue": m[1] || (m[1] = (v) => W(o).lastname = v),
                label: "Cognome",
                placeholder: "Inserisci il cognome",
                outlined: "",
                dense: "",
                rules: [(v) => !!v || "Campo obbligatorio"]
              }, null, 8, ["modelValue", "rules"])
            ]),
            _: 1
          })
        ]),
        _: 1
      }),
      S(Ml, {
        modelValue: W(o).region,
        "onUpdate:modelValue": m[2] || (m[2] = (v) => W(o).region = v),
        items: r.value,
        label: "Seleziona una regione",
        placeholder: "Inserisci la regione",
        "hide-no-data": "",
        "hide-selected": "",
        readonly: W(a) === 2,
        outlined: "",
        dense: "",
        rules: [(v) => !!v || "Campo obbligatorio"]
      }, null, 8, ["modelValue", "items", "readonly", "rules"]),
      S(Ml, {
        modelValue: W(o).province,
        "onUpdate:modelValue": m[3] || (m[3] = (v) => W(o).province = v),
        items: l.value,
        label: "Seleziona una provincia",
        placeholder: "Inserisci la provincia",
        "hide-no-data": "",
        "hide-selected": "",
        readonly: W(a) === 2,
        disabled: W(a) === 1 ? !W(o).region : !1,
        outlined: "",
        dense: "",
        rules: [(v) => !!v || "Campo obbligatorio"]
      }, null, 8, ["modelValue", "items", "readonly", "disabled", "rules"]),
      S(Ml, {
        modelValue: W(o).city,
        "onUpdate:modelValue": m[4] || (m[4] = (v) => W(o).city = v),
        items: s.value,
        label: "Seleziona una citt",
        placeholder: "Inserisci la citt",
        "hide-no-data": "",
        "hide-selected": "",
        disabled: W(a) === 1 ? !W(o).province : !1,
        outlined: "",
        dense: "",
        rules: [(v) => !!v || "Campo obbligatorio"]
      }, null, 8, ["modelValue", "items", "disabled", "rules"]),
      S(Qn, {
        modelValue: W(o).address,
        "onUpdate:modelValue": m[5] || (m[5] = (v) => W(o).address = v),
        label: "Inserisci la via e il numero civico",
        placeholder: "Via e numero",
        outlined: "",
        dense: "",
        rules: [(v) => !!v || "Campo obbligatorio"]
      }, null, 8, ["modelValue", "rules"])
    ]));
  }
}, dp = So("popup", {
  state: () => ({
    message: "",
    type: ""
  }),
  actions: {
    setPopup(t, e) {
      this.message = "", this.type = "", setTimeout(() => {
        this.message = t, this.type = e;
      }, 50);
    }
  }
}), Wf = U({
  baseColor: String,
  divided: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...vn(),
  ...ve(),
  ...Dn(),
  ...Cn(),
  ...Tt(),
  ...Oe(),
  ...Ue(),
  ...wi()
}, "VBtnGroup"), Bc = ee()({
  name: "VBtnGroup",
  props: Wf(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      themeClasses: i
    } = et(t), {
      densityClasses: a
    } = oi(t), {
      borderClasses: o
    } = yn(t), {
      elevationClasses: r
    } = pn(t), {
      roundedClasses: l
    } = wt(t);
    ai({
      VBtn: {
        height: O(() => t.direction === "horizontal" ? "auto" : null),
        baseColor: O(() => t.baseColor),
        color: O(() => t.color),
        density: O(() => t.density),
        flat: !0,
        variant: O(() => t.variant)
      }
    }), le(() => S(t.tag, {
      class: te(["v-btn-group", `v-btn-group--${t.direction}`, {
        "v-btn-group--divided": t.divided
      }, i.value, o.value, a.value, r.value, l.value, t.class]),
      style: re(t.style)
    }, n));
  }
}), $f = Symbol.for("vuetify:v-btn-toggle"), hp = U({
  ...Wf(),
  ...Br()
}, "VBtnToggle");
ee()({
  name: "VBtnToggle",
  props: hp(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      isSelected: i,
      next: a,
      prev: o,
      select: r,
      selected: l
    } = Ro(t, $f);
    return le(() => {
      const s = Bc.filterProps(t);
      return S(Bc, oe({
        class: ["v-btn-toggle", t.class]
      }, s, {
        style: t.style
      }), {
        default: () => {
          var u;
          return [(u = n.default) == null ? void 0 : u.call(n, {
            isSelected: i,
            next: a,
            prev: o,
            select: r,
            selected: l
          })];
        }
      });
    }), {
      next: a,
      prev: o,
      select: r
    };
  }
});
const fp = U({
  bgColor: String,
  color: String,
  indeterminate: [Boolean, String],
  modelValue: {
    type: [Number, String],
    default: 0
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  width: {
    type: [Number, String],
    default: 4
  },
  ...ve(),
  ...xo(),
  ...Oe({
    tag: "div"
  }),
  ...Ue()
}, "VProgressCircular"), gp = ee()({
  name: "VProgressCircular",
  props: fp(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = 20, a = 2 * Math.PI * i, o = Z(), {
      themeClasses: r
    } = et(t), {
      sizeClasses: l,
      sizeStyles: s
    } = Po(t), {
      textColorClasses: u,
      textColorStyles: c
    } = Bn(() => t.color), {
      textColorClasses: d,
      textColorStyles: h
    } = Bn(() => t.bgColor), {
      intersectionRef: f,
      isIntersecting: g
    } = Pf(), {
      resizeRef: m,
      contentRect: v
    } = Wi(), y = O(() => Gt(parseFloat(t.modelValue), 0, 100)), C = O(() => Number(t.width)), M = O(() => s.value ? Number(t.size) : v.value ? v.value.width : Math.max(C.value, 32)), p = O(() => i / (1 - C.value / M.value) * 2), b = O(() => C.value / M.value * p.value), P = O(() => he((100 - y.value) / 100 * a));
    return Pt(() => {
      f.value = o.value, m.value = o.value;
    }), le(() => S(t.tag, {
      ref: o,
      class: te(["v-progress-circular", {
        "v-progress-circular--indeterminate": !!t.indeterminate,
        "v-progress-circular--visible": g.value,
        "v-progress-circular--disable-shrink": t.indeterminate === "disable-shrink"
      }, r.value, l.value, u.value, t.class]),
      style: re([s.value, c.value, t.style]),
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": t.indeterminate ? void 0 : y.value
    }, {
      default: () => [w("svg", {
        style: {
          transform: `rotate(calc(-90deg + ${Number(t.rotate)}deg))`
        },
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${p.value} ${p.value}`
      }, [w("circle", {
        class: te(["v-progress-circular__underlay", d.value]),
        style: re(h.value),
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: i,
        "stroke-width": b.value,
        "stroke-dasharray": a,
        "stroke-dashoffset": 0
      }, null), w("circle", {
        class: "v-progress-circular__overlay",
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: i,
        "stroke-width": b.value,
        "stroke-dasharray": a,
        "stroke-dashoffset": P.value
      }, null)]), n.default && w("div", {
        class: "v-progress-circular__content"
      }, [n.default({
        value: y.value
      })])]
    })), {};
  }
}), mp = ["static", "relative", "fixed", "absolute", "sticky"], Qs = U({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (t) => mp.includes(t)
    )
  }
}, "position");
function eu(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : On();
  return {
    positionClasses: O(() => t.position ? `${e}--${t.position}` : void 0)
  };
}
function vp(t, e) {
  ie(() => {
    var n;
    return (n = t.isActive) == null ? void 0 : n.value;
  }, (n) => {
    t.isLink.value && n != null && e && Ye(() => {
      e(n);
    });
  }, {
    immediate: !0
  });
}
const Xf = U({
  active: {
    type: Boolean,
    default: void 0
  },
  activeColor: String,
  baseColor: String,
  symbol: {
    type: null,
    default: $f
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: Pe,
  appendIcon: Pe,
  block: Boolean,
  readonly: Boolean,
  slim: Boolean,
  stacked: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: {
    type: [String, Number, Boolean],
    default: void 0
  },
  ...vn(),
  ...ve(),
  ...Dn(),
  ...ln(),
  ...Cn(),
  ...Eo(),
  ...js(),
  ...Dr(),
  ...Qs(),
  ...Tt(),
  ...kr(),
  ...xo(),
  ...Oe({
    tag: "button"
  }),
  ...Ue(),
  ...wi({
    variant: "elevated"
  })
}, "VBtn"), At = ee()({
  name: "VBtn",
  props: Xf(),
  emits: {
    "group:selected": (t) => !0
  },
  setup(t, e) {
    let {
      attrs: n,
      slots: i
    } = e;
    const {
      themeClasses: a
    } = et(t), {
      borderClasses: o
    } = yn(t), {
      densityClasses: r
    } = oi(t), {
      dimensionStyles: l
    } = sn(t), {
      elevationClasses: s
    } = pn(t), {
      loaderClasses: u
    } = Hs(t), {
      locationStyles: c
    } = Gr(t), {
      positionClasses: d
    } = eu(t), {
      roundedClasses: h
    } = wt(t), {
      sizeClasses: f,
      sizeStyles: g
    } = Po(t), m = Ao(t, t.symbol, !1), v = Fr(t, n), y = E(() => {
      var L;
      return t.active !== void 0 ? t.active : v.isLink.value ? (L = v.isActive) == null ? void 0 : L.value : m == null ? void 0 : m.isSelected.value;
    }), C = O(() => y.value ? t.activeColor ?? t.color : t.color), M = E(() => {
      var z, I;
      return {
        color: (m == null ? void 0 : m.isSelected.value) && (!v.isLink.value || ((z = v.isActive) == null ? void 0 : z.value)) || !m || ((I = v.isActive) == null ? void 0 : I.value) ? C.value ?? t.baseColor : t.baseColor,
        variant: t.variant
      };
    }), {
      colorClasses: p,
      colorStyles: b,
      variantClasses: P
    } = wo(M), x = E(() => (m == null ? void 0 : m.disabled.value) || t.disabled), _ = O(() => t.variant === "elevated" && !(t.disabled || t.flat || t.border)), T = E(() => {
      if (!(t.value === void 0 || typeof t.value == "symbol"))
        return Object(t.value) === t.value ? JSON.stringify(t.value, null, 0) : t.value;
    });
    function B(L) {
      var z;
      x.value || v.isLink.value && (L.metaKey || L.ctrlKey || L.shiftKey || L.button !== 0 || n.target === "_blank") || ((z = v.navigate) == null || z.call(v, L), m == null || m.toggle());
    }
    return vp(v, m == null ? void 0 : m.select), le(() => {
      const L = v.isLink.value ? "a" : t.tag, z = !!(t.prependIcon || i.prepend), I = !!(t.appendIcon || i.append), k = !!(t.icon && t.icon !== !0);
      return it(S(L, oe({
        type: L === "a" ? void 0 : "button",
        class: ["v-btn", m == null ? void 0 : m.selectedClass.value, {
          "v-btn--active": y.value,
          "v-btn--block": t.block,
          "v-btn--disabled": x.value,
          "v-btn--elevated": _.value,
          "v-btn--flat": t.flat,
          "v-btn--icon": !!t.icon,
          "v-btn--loading": t.loading,
          "v-btn--readonly": t.readonly,
          "v-btn--slim": t.slim,
          "v-btn--stacked": t.stacked
        }, a.value, o.value, p.value, r.value, s.value, u.value, d.value, h.value, f.value, P.value, t.class],
        style: [b.value, l.value, c.value, g.value, t.style],
        "aria-busy": t.loading ? !0 : void 0,
        disabled: x.value || void 0,
        tabindex: t.loading || t.readonly ? -1 : void 0,
        onClick: B,
        value: T.value
      }, v.linkProps), {
        default: () => {
          var G;
          return [To(!0, "v-btn"), !t.icon && z && w("span", {
            key: "prepend",
            class: "v-btn__prepend"
          }, [i.prepend ? S(We, {
            key: "prepend-defaults",
            disabled: !t.prependIcon,
            defaults: {
              VIcon: {
                icon: t.prependIcon
              }
            }
          }, i.prepend) : S(Be, {
            key: "prepend-icon",
            icon: t.prependIcon
          }, null)]), w("span", {
            class: "v-btn__content",
            "data-no-activator": ""
          }, [!i.default && k ? S(Be, {
            key: "content-icon",
            icon: t.icon
          }, null) : S(We, {
            key: "content-defaults",
            disabled: !k,
            defaults: {
              VIcon: {
                icon: t.icon
              }
            }
          }, {
            default: () => {
              var F;
              return [((F = i.default) == null ? void 0 : F.call(i)) ?? Ge(t.text)];
            }
          })]), !t.icon && I && w("span", {
            key: "append",
            class: "v-btn__append"
          }, [i.append ? S(We, {
            key: "append-defaults",
            disabled: !t.appendIcon,
            defaults: {
              VIcon: {
                icon: t.appendIcon
              }
            }
          }, i.append) : S(Be, {
            key: "append-icon",
            icon: t.appendIcon
          }, null)]), !!t.loading && w("span", {
            key: "loader",
            class: "v-btn__loader"
          }, [((G = i.loader) == null ? void 0 : G.call(i)) ?? S(gp, {
            color: typeof t.loading == "boolean" ? void 0 : t.loading,
            indeterminate: !0,
            width: "2"
          }, null)])];
        }
      }), [[fn, !x.value && t.ripple, "", {
        center: !!t.icon
      }]]);
    }), {
      group: m
    };
  }
}), Uf = ee()({
  name: "VCardActions",
  props: ve(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return ai({
      VBtn: {
        slim: !0,
        variant: "text"
      }
    }), le(() => {
      var i;
      return w("div", {
        class: te(["v-card-actions", t.class]),
        style: re(t.style)
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), yp = U({
  opacity: [Number, String],
  ...ve(),
  ...Oe()
}, "VCardSubtitle"), Yf = ee()({
  name: "VCardSubtitle",
  props: yp(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return le(() => S(t.tag, {
      class: te(["v-card-subtitle", t.class]),
      style: re([{
        "--v-card-subtitle-opacity": t.opacity
      }, t.style])
    }, n)), {};
  }
}), tu = ph("v-card-title"), Cp = U({
  appendAvatar: String,
  appendIcon: Pe,
  prependAvatar: String,
  prependIcon: Pe,
  subtitle: {
    type: [String, Number, Boolean],
    default: void 0
  },
  title: {
    type: [String, Number, Boolean],
    default: void 0
  },
  ...ve(),
  ...Dn()
}, "VCardItem"), pp = ee()({
  name: "VCardItem",
  props: Cp(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return le(() => {
      var u;
      const i = !!(t.prependAvatar || t.prependIcon), a = !!(i || n.prepend), o = !!(t.appendAvatar || t.appendIcon), r = !!(o || n.append), l = !!(t.title != null || n.title), s = !!(t.subtitle != null || n.subtitle);
      return w("div", {
        class: te(["v-card-item", t.class]),
        style: re(t.style)
      }, [a && w("div", {
        key: "prepend",
        class: "v-card-item__prepend"
      }, [n.prepend ? S(We, {
        key: "prepend-defaults",
        disabled: !i,
        defaults: {
          VAvatar: {
            density: t.density,
            image: t.prependAvatar
          },
          VIcon: {
            density: t.density,
            icon: t.prependIcon
          }
        }
      }, n.prepend) : w(pe, null, [t.prependAvatar && S(bi, {
        key: "prepend-avatar",
        density: t.density,
        image: t.prependAvatar
      }, null), t.prependIcon && S(Be, {
        key: "prepend-icon",
        density: t.density,
        icon: t.prependIcon
      }, null)])]), w("div", {
        class: "v-card-item__content"
      }, [l && S(tu, {
        key: "title"
      }, {
        default: () => {
          var c;
          return [((c = n.title) == null ? void 0 : c.call(n)) ?? Ge(t.title)];
        }
      }), s && S(Yf, {
        key: "subtitle"
      }, {
        default: () => {
          var c;
          return [((c = n.subtitle) == null ? void 0 : c.call(n)) ?? Ge(t.subtitle)];
        }
      }), (u = n.default) == null ? void 0 : u.call(n)]), r && w("div", {
        key: "append",
        class: "v-card-item__append"
      }, [n.append ? S(We, {
        key: "append-defaults",
        disabled: !o,
        defaults: {
          VAvatar: {
            density: t.density,
            image: t.appendAvatar
          },
          VIcon: {
            density: t.density,
            icon: t.appendIcon
          }
        }
      }, n.append) : w(pe, null, [t.appendIcon && S(Be, {
        key: "append-icon",
        density: t.density,
        icon: t.appendIcon
      }, null), t.appendAvatar && S(bi, {
        key: "append-avatar",
        density: t.density,
        image: t.appendAvatar
      }, null)])])]);
    }), {};
  }
}), _p = U({
  opacity: [Number, String],
  ...ve(),
  ...Oe()
}, "VCardText"), nu = ee()({
  name: "VCardText",
  props: _p(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return le(() => S(t.tag, {
      class: te(["v-card-text", t.class]),
      style: re([{
        "--v-card-text-opacity": t.opacity
      }, t.style])
    }, n)), {};
  }
}), Sp = U({
  appendAvatar: String,
  appendIcon: Pe,
  disabled: Boolean,
  flat: Boolean,
  hover: Boolean,
  image: String,
  link: {
    type: Boolean,
    default: void 0
  },
  prependAvatar: String,
  prependIcon: Pe,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  subtitle: {
    type: [String, Number, Boolean],
    default: void 0
  },
  text: {
    type: [String, Number, Boolean],
    default: void 0
  },
  title: {
    type: [String, Number, Boolean],
    default: void 0
  },
  ...vn(),
  ...ve(),
  ...Dn(),
  ...ln(),
  ...Cn(),
  ...js(),
  ...Dr(),
  ...Qs(),
  ...Tt(),
  ...kr(),
  ...Oe(),
  ...Ue(),
  ...wi({
    variant: "elevated"
  })
}, "VCard"), zo = ee()({
  name: "VCard",
  directives: {
    vRipple: fn
  },
  props: Sp(),
  setup(t, e) {
    let {
      attrs: n,
      slots: i
    } = e;
    const {
      themeClasses: a
    } = et(t), {
      borderClasses: o
    } = yn(t), {
      colorClasses: r,
      colorStyles: l,
      variantClasses: s
    } = wo(t), {
      densityClasses: u
    } = oi(t), {
      dimensionStyles: c
    } = sn(t), {
      elevationClasses: d
    } = pn(t), {
      loaderClasses: h
    } = Hs(t), {
      locationStyles: f
    } = Gr(t), {
      positionClasses: g
    } = eu(t), {
      roundedClasses: m
    } = wt(t), v = Fr(t, n);
    return le(() => {
      const y = t.link !== !1 && v.isLink.value, C = !t.disabled && t.link !== !1 && (t.link || v.isClickable.value), M = y ? "a" : t.tag, p = !!(i.title || t.title != null), b = !!(i.subtitle || t.subtitle != null), P = p || b, x = !!(i.append || t.appendAvatar || t.appendIcon), _ = !!(i.prepend || t.prependAvatar || t.prependIcon), T = !!(i.image || t.image), B = P || _ || x, L = !!(i.text || t.text != null);
      return it(S(M, oe({
        class: ["v-card", {
          "v-card--disabled": t.disabled,
          "v-card--flat": t.flat,
          "v-card--hover": t.hover && !(t.disabled || t.flat),
          "v-card--link": C
        }, a.value, o.value, r.value, u.value, d.value, h.value, g.value, m.value, s.value, t.class],
        style: [l.value, c.value, f.value, t.style],
        onClick: C && v.navigate,
        tabindex: t.disabled ? -1 : void 0
      }, v.linkProps), {
        default: () => {
          var z;
          return [T && w("div", {
            key: "image",
            class: "v-card__image"
          }, [i.image ? S(We, {
            key: "image-defaults",
            disabled: !t.image,
            defaults: {
              VImg: {
                cover: !0,
                src: t.image
              }
            }
          }, i.image) : S(nn, {
            key: "image-img",
            cover: !0,
            src: t.image
          }, null)]), S(wf, {
            name: "v-card",
            active: !!t.loading,
            color: typeof t.loading == "boolean" ? void 0 : t.loading
          }, {
            default: i.loader
          }), B && S(pp, {
            key: "item",
            prependAvatar: t.prependAvatar,
            prependIcon: t.prependIcon,
            title: t.title,
            subtitle: t.subtitle,
            appendAvatar: t.appendAvatar,
            appendIcon: t.appendIcon
          }, {
            default: i.item,
            prepend: i.prepend,
            title: i.title,
            subtitle: i.subtitle,
            append: i.append
          }), L && S(nu, {
            key: "text"
          }, {
            default: () => {
              var I;
              return [((I = i.text) == null ? void 0 : I.call(i)) ?? t.text];
            }
          }), (z = i.default) == null ? void 0 : z.call(i), i.actions && S(Uf, null, {
            default: i.actions
          }), To(C, "v-card")];
        }
      }), [[fn, C && t.ripple]]);
    }), {};
  }
}), bp = { class: "font-weight-bold" }, Mp = { style: { "flex-grow": "1" } }, xp = { style: { "font-size": "16px", "font-weight": "bold" } }, Pp = { style: { display: "flex", "align-items": "center" } }, Tp = { style: { "font-size": "15px", "font-weight": "bold" } }, wp = {
  __name: "Cart",
  setup(t) {
    const e = dp(), n = ah(), i = Z([]), a = Z(!1), o = Z(!1), r = wa(), l = kn(), { data: s } = tn(l), u = s.value.store;
    Qa.getRequest("products", {}, function(x) {
      i.value = x;
    });
    const c = E(() => n.products.reduce((x, _) => x + _.quantity, 0)), d = E(() => n.products.reduce((x, _) => {
      const T = M(_.product);
      return x + T * _.quantity;
    }, 0).toFixed(2) + " "), h = async () => {
      u.addressMode ? a.value = !0 : await f();
    }, f = async () => {
      const { products: x } = tn(n);
      Qa.postRequest("stripe-session", {
        user_id: u.userId,
        products: x.value
      }, function(_) {
        _.checkout_url ? window.location.href = _.checkout_url : _.status == "ko" && alert(_.message);
      });
    }, g = () => {
      a.value = !1;
    }, m = () => {
      try {
        n.removeAllProduct(), e.setPopup("Carrello svuotato correttamente!", "success");
      } catch {
        e.setPopup("Impossibile svuotare il carrello!", "error");
      }
    }, v = Z({}), y = (x) => {
      if (v.value[x] = i.value.find((_) => _.id == x).name, v.value[x]) {
        const _ = v.value[x];
        if (_.length > 18) {
          const T = _.slice(0, 19);
          return T.endsWith(" ") ? T.trimEnd() + "..." : T + "...";
        }
        return _;
      }
      return "Caricamento...";
    }, C = Z({}), M = (x) => {
      const _ = i.value.find((T) => T.id == x).price;
      return C.value[x] = parseFloat(_) / 100, C.value[x] ? C.value[x] : 0;
    }, p = (x) => {
      n.addProduct(x);
    }, b = (x) => {
      n.removeProduct(x);
    }, P = (x) => {
      const _ = i.value.find((T) => T.id == x);
      return _ != null && _.image ? _.image : "https://4kwallpapers.com/images/walls/thumbs_3t/11056.jpg";
    };
    return (x, _) => (J(), Ce(Or, {
      modelValue: o.value,
      "onUpdate:modelValue": _[2] || (_[2] = (T) => o.value = T),
      transition: "scale-transition",
      "close-on-content-click": !1,
      "onClick:outside": _[3] || (_[3] = (T) => o.value = !1)
    }, {
      activator: H(({ props: T }) => [
        W(r) ? (J(), Ce(At, ju(oe({ key: 0 }, T)), {
          default: H(() => [
            S(Be, { icon: "mdi-cart-outline" }),
            ct(" (" + Ge(c.value) + ") ", 1)
          ]),
          _: 2
        }, 1040)) : Ae("", !0),
        W(r) ? Ae("", !0) : (J(), Ce(At, ju(oe({ key: 1 }, T)), {
          default: H(() => [
            S(Be, {
              icon: "mdi-cart-outline",
              start: ""
            }),
            ct(" Carrello (" + Ge(c.value) + ") ", 1)
          ]),
          _: 2
        }, 1040))
      ]),
      default: H(() => [
        S(zo, {
          class: "mt-4",
          style: { width: "400px", "background-color": "#f5f5f5" }
        }, {
          default: H(() => [
            S(tu, null, {
              default: H(() => [
                w("span", bp, Ge(a.value ? "Indirizzo di Spedizione" : "Riepilogo Ordini"), 1)
              ]),
              _: 1
            }),
            S(nu, null, {
              default: H(() => [
                a.value ? (J(), Ce(W(cp), { key: 0 })) : (J(), Ce(Ia, { key: 1 }, {
                  default: H(() => [
                    (J(!0), Ie(pe, null, Ft(W(n).products, (T) => (J(), Ce(Fn, { class: "py-4" }, {
                      default: H(() => [
                        S(pa, {
                          align: "center",
                          style: { width: "100%" }
                        }, {
                          default: H(() => [
                            S(dn, { class: "d-flex align-center" }, {
                              default: H(() => [
                                S(nn, {
                                  src: P(T.product),
                                  alt: "product image",
                                  width: "40",
                                  class: "mr-3"
                                }, null, 8, ["src"]),
                                w("div", Mp, [
                                  w("p", xp, Ge(y(T.product)), 1),
                                  w("div", Pp, [
                                    _[4] || (_[4] = w("p", { class: "text-caption" }, "Quantit:", -1)),
                                    S(At, {
                                      onClick: Ja((B) => b(T), ["stop"]),
                                      icon: "mdi-minus",
                                      size: "x-small",
                                      style: { margin: "0 5px", "box-shadow": "none" }
                                    }, null, 8, ["onClick"]),
                                    ct(" " + Ge(T.quantity) + " ", 1),
                                    S(At, {
                                      onClick: Ja((B) => p(T), ["stop"]),
                                      icon: "mdi-plus",
                                      size: "x-small",
                                      style: { margin: "0 0 0 5px", "box-shadow": "none" }
                                    }, null, 8, ["onClick"])
                                  ])
                                ]),
                                w("p", Tp, Ge(M(T.product) + " "), 1)
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          _: 2
                        }, 1024)
                      ]),
                      _: 2
                    }, 1024))), 256))
                  ]),
                  _: 1
                }))
              ]),
              _: 1
            }),
            a.value ? Ae("", !0) : (J(), Ce(Yf, {
              key: 0,
              class: "text-right",
              style: { "font-size": "18px", "font-weight": "bold", "padding-right": "16px" }
            }, {
              default: H(() => [
                ct(" Prezzo Totale: " + Ge(d.value), 1)
              ]),
              _: 1
            })),
            S(Uf, null, {
              default: H(() => [
                S(At, {
                  onClick: _[0] || (_[0] = (T) => a.value ? f() : h()),
                  color: "primary"
                }, {
                  default: H(() => [
                    ct(Ge(a.value ? "Invia Ordine" : "Procedi al Checkout"), 1)
                  ]),
                  _: 1
                }),
                S(At, {
                  onClick: _[1] || (_[1] = (T) => a.value ? g() : m()),
                  color: "error"
                }, {
                  default: H(() => [
                    ct(Ge(a.value ? "Torna Indietro" : "Svuota Carrello"), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"]));
  }
}, Fc = /* @__PURE__ */ rn(wp, [["__scopeId", "data-v-209409d1"]]), ri = So("language", {
  state: () => ({
    locale: "it"
  }),
  actions: {
    setLocale(t) {
      this.locale = t;
    },
    getText(t) {
      return typeof t == "string" ? t : typeof t == "object" ? t[this.locale] : "";
    },
    getAncor(t) {
      return t ? typeof t == "string" ? t : typeof t == "object" ? Object.values(t)[0] : "" : "";
    }
  },
  persist: {
    storage: localStorage
  }
}), Ep = ["src"], Ap = ["src"], Rp = ["src"], Ip = {
  __name: "Language",
  setup(t) {
    const e = kn(), n = ri(), { data: i } = tn(e), { locale: a } = tn(n), o = i.value.info.locales, r = E(() => o.length === 2 ? o.find((c) => c !== a.value) : null), l = (c) => `https://flagcdn.com/w40/${c}.png`, s = () => {
      r.value && (n.locale = r.value);
    }, u = (c) => {
      n.locale = c;
    };
    return (c, d) => (J(), Ie(pe, null, [
      W(o).length == 2 ? (J(), Ie("img", {
        key: 0,
        src: l(r.value),
        class: "flag",
        onClick: s,
        style: { margin: "16px" }
      }, null, 8, Ep)) : Ae("", !0),
      W(o).length > 2 ? (J(), Ce(Or, { key: 1 }, {
        activator: H(({ props: h }) => [
          w("div", oe(h, { class: "flag-wrapper" }), [
            w("img", {
              src: l(W(a)),
              class: "flag",
              style: { width: "20px", height: "20px" }
            }, null, 8, Ap),
            S(Be, { class: "arrow" }, {
              default: H(() => d[0] || (d[0] = [
                ct("mdi-menu-down", -1)
              ])),
              _: 1,
              __: [0]
            })
          ], 16)
        ]),
        default: H(() => [
          S(Ia, {
            style: { width: "48px", height: "fit-content" },
            class: "d-flex justify-center flex-column align-center"
          }, {
            default: H(() => [
              (J(!0), Ie(pe, null, Ft(W(o), (h) => (J(), Ce(Fn, {
                key: h,
                onClick: (f) => u(h),
                style: { padding: "0", height: "35px", "min-height": "auto" }
              }, {
                default: H(() => [
                  w("img", {
                    src: l(h),
                    style: { width: "20px", height: "20px" },
                    class: "flag"
                  }, null, 8, Rp)
                ]),
                _: 2
              }, 1032, ["onClick"]))), 128))
            ]),
            _: 1
          })
        ]),
        _: 1
      })) : Ae("", !0)
    ], 64));
  }
}, kc = /* @__PURE__ */ rn(Ip, [["__scopeId", "data-v-d1ce1a9a"]]), jf = U({
  text: String,
  ...ve(),
  ...Oe()
}, "VToolbarTitle"), Hf = ee()({
  name: "VToolbarTitle",
  props: jf(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return le(() => {
      const i = !!(n.default || n.text || t.text);
      return S(t.tag, {
        class: te(["v-toolbar-title", t.class]),
        style: re(t.style)
      }, {
        default: () => {
          var a;
          return [i && w("div", {
            class: "v-toolbar-title__placeholder"
          }, [n.text ? n.text() : t.text, (a = n.default) == null ? void 0 : a.call(n)])];
        }
      });
    }), {};
  }
}), zp = [null, "prominent", "default", "comfortable", "compact"], Zf = U({
  absolute: Boolean,
  collapse: Boolean,
  color: String,
  density: {
    type: String,
    default: "default",
    validator: (t) => zp.includes(t)
  },
  extended: {
    type: Boolean,
    default: null
  },
  extensionHeight: {
    type: [Number, String],
    default: 48
  },
  flat: Boolean,
  floating: Boolean,
  height: {
    type: [Number, String],
    default: 64
  },
  image: String,
  title: String,
  ...vn(),
  ...ve(),
  ...Cn(),
  ...Tt(),
  ...Oe({
    tag: "header"
  }),
  ...Ue()
}, "VToolbar"), Oc = ee()({
  name: "VToolbar",
  props: Zf(),
  setup(t, e) {
    var f;
    let {
      slots: n
    } = e;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: a
    } = xt(() => t.color), {
      borderClasses: o
    } = yn(t), {
      elevationClasses: r
    } = pn(t), {
      roundedClasses: l
    } = wt(t), {
      themeClasses: s
    } = et(t), {
      rtlClasses: u
    } = Wt(), c = Q(t.extended === null ? !!((f = n.extension) != null && f.call(n)) : t.extended), d = E(() => parseInt(Number(t.height) + (t.density === "prominent" ? Number(t.height) : 0) - (t.density === "comfortable" ? 8 : 0) - (t.density === "compact" ? 16 : 0), 10)), h = E(() => c.value ? parseInt(Number(t.extensionHeight) + (t.density === "prominent" ? Number(t.extensionHeight) : 0) - (t.density === "comfortable" ? 4 : 0) - (t.density === "compact" ? 8 : 0), 10) : 0);
    return ai({
      VBtn: {
        variant: "text"
      }
    }), le(() => {
      var y;
      const g = !!(t.title || n.title), m = !!(n.image || t.image), v = (y = n.extension) == null ? void 0 : y.call(n);
      return c.value = t.extended === null ? !!v : t.extended, S(t.tag, {
        class: te(["v-toolbar", {
          "v-toolbar--absolute": t.absolute,
          "v-toolbar--collapse": t.collapse,
          "v-toolbar--flat": t.flat,
          "v-toolbar--floating": t.floating,
          [`v-toolbar--density-${t.density}`]: !0
        }, i.value, o.value, r.value, l.value, s.value, u.value, t.class]),
        style: re([a.value, t.style])
      }, {
        default: () => [m && w("div", {
          key: "image",
          class: "v-toolbar__image"
        }, [n.image ? S(We, {
          key: "image-defaults",
          disabled: !t.image,
          defaults: {
            VImg: {
              cover: !0,
              src: t.image
            }
          }
        }, n.image) : S(nn, {
          key: "image-img",
          cover: !0,
          src: t.image
        }, null)]), S(We, {
          defaults: {
            VTabs: {
              height: he(d.value)
            }
          }
        }, {
          default: () => {
            var C, M, p;
            return [w("div", {
              class: "v-toolbar__content",
              style: {
                height: he(d.value)
              }
            }, [n.prepend && w("div", {
              class: "v-toolbar__prepend"
            }, [(C = n.prepend) == null ? void 0 : C.call(n)]), g && S(Hf, {
              key: "title",
              text: t.title
            }, {
              text: n.title
            }), (M = n.default) == null ? void 0 : M.call(n), n.append && w("div", {
              class: "v-toolbar__append"
            }, [(p = n.append) == null ? void 0 : p.call(n)])])];
          }
        }), S(We, {
          defaults: {
            VTabs: {
              height: he(h.value)
            }
          }
        }, {
          default: () => [S(Bs, null, {
            default: () => [c.value && w("div", {
              class: "v-toolbar__extension",
              style: {
                height: he(h.value)
              }
            }, [v])]
          })]
        })]
      });
    }), {
      contentHeight: d,
      extensionHeight: h
    };
  }
}), mr = Symbol.for("vuetify:layout"), Kf = Symbol.for("vuetify:layout-item"), Dc = 1e3, Lp = U({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout"), iu = U({
  name: {
    type: String
  },
  order: {
    type: [Number, String],
    default: 0
  },
  absolute: Boolean
}, "layout-item");
function Vp() {
  const t = Ne(mr);
  if (!t) throw new Error("[Vuetify] Could not find injected layout");
  return {
    getLayoutItem: t.getLayoutItem,
    mainRect: t.mainRect,
    mainStyles: t.mainStyles
  };
}
function au(t) {
  const e = Ne(mr);
  if (!e) throw new Error("[Vuetify] Could not find injected layout");
  const n = t.id ?? `layout-item-${Ti()}`, i = Qe("useLayoutItem");
  ht(Kf, {
    id: n
  });
  const a = Q(!1);
  xs(() => a.value = !0), Jd(() => a.value = !1);
  const {
    layoutItemStyles: o,
    layoutItemScrimStyles: r
  } = e.register(i, {
    ...t,
    active: E(() => a.value ? !1 : t.active.value),
    id: n
  });
  return pt(() => e.unregister(n)), {
    layoutItemStyles: o,
    layoutRect: e.layoutRect,
    layoutItemScrimStyles: r
  };
}
const Bp = (t, e, n, i) => {
  let a = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const o = [{
    id: "",
    layer: {
      ...a
    }
  }];
  for (const r of t) {
    const l = e.get(r), s = n.get(r), u = i.get(r);
    if (!l || !s || !u) continue;
    const c = {
      ...a,
      [l.value]: parseInt(a[l.value], 10) + (u.value ? parseInt(s.value, 10) : 0)
    };
    o.push({
      id: r,
      layer: c
    }), a = c;
  }
  return o;
};
function Fp(t) {
  const e = Ne(mr, null), n = E(() => e ? e.rootZIndex.value - 100 : Dc), i = Z([]), a = cn(/* @__PURE__ */ new Map()), o = cn(/* @__PURE__ */ new Map()), r = cn(/* @__PURE__ */ new Map()), l = cn(/* @__PURE__ */ new Map()), s = cn(/* @__PURE__ */ new Map()), {
    resizeRef: u,
    contentRect: c
  } = Wi(), d = E(() => {
    const P = /* @__PURE__ */ new Map(), x = t.overlaps ?? [];
    for (const _ of x.filter((T) => T.includes(":"))) {
      const [T, B] = _.split(":");
      if (!i.value.includes(T) || !i.value.includes(B)) continue;
      const L = a.get(T), z = a.get(B), I = o.get(T), k = o.get(B);
      !L || !z || !I || !k || (P.set(B, {
        position: L.value,
        amount: parseInt(I.value, 10)
      }), P.set(T, {
        position: z.value,
        amount: -parseInt(k.value, 10)
      }));
    }
    return P;
  }), h = E(() => {
    const P = [...new Set([...r.values()].map((_) => _.value))].sort((_, T) => _ - T), x = [];
    for (const _ of P) {
      const T = i.value.filter((B) => {
        var L;
        return ((L = r.get(B)) == null ? void 0 : L.value) === _;
      });
      x.push(...T);
    }
    return Bp(x, a, o, l);
  }), f = E(() => !Array.from(s.values()).some((P) => P.value)), g = E(() => h.value[h.value.length - 1].layer), m = O(() => ({
    "--v-layout-left": he(g.value.left),
    "--v-layout-right": he(g.value.right),
    "--v-layout-top": he(g.value.top),
    "--v-layout-bottom": he(g.value.bottom),
    ...f.value ? void 0 : {
      transition: "none"
    }
  })), v = E(() => h.value.slice(1).map((P, x) => {
    let {
      id: _
    } = P;
    const {
      layer: T
    } = h.value[x], B = o.get(_), L = a.get(_);
    return {
      id: _,
      ...T,
      size: Number(B.value),
      position: L.value
    };
  })), y = (P) => v.value.find((x) => x.id === P), C = Qe("createLayout"), M = Q(!1);
  at(() => {
    M.value = !0;
  }), ht(mr, {
    register: (P, x) => {
      let {
        id: _,
        order: T,
        position: B,
        layoutSize: L,
        elementSize: z,
        active: I,
        disableTransitions: k,
        absolute: G
      } = x;
      r.set(_, T), a.set(_, B), o.set(_, L), l.set(_, I), k && s.set(_, k);
      const q = la(Kf, C == null ? void 0 : C.vnode).indexOf(P);
      q > -1 ? i.value.splice(q, 0, _) : i.value.push(_);
      const j = E(() => v.value.findIndex((V) => V.id === _)), ne = E(() => n.value + h.value.length * 2 - j.value * 2), A = E(() => {
        const V = B.value === "left" || B.value === "right", X = B.value === "right", D = B.value === "bottom", Y = z.value ?? L.value, ce = Y === 0 ? "%" : "px", K = {
          [B.value]: 0,
          zIndex: ne.value,
          transform: `translate${V ? "X" : "Y"}(${(I.value ? 0 : -(Y === 0 ? 100 : Y)) * (X || D ? -1 : 1)}${ce})`,
          position: G.value || n.value !== Dc ? "absolute" : "fixed",
          ...f.value ? void 0 : {
            transition: "none"
          }
        };
        if (!M.value) return K;
        const se = v.value[j.value];
        se || In(`[Vuetify] Could not find layout item "${_}"`);
        const ge = d.value.get(_);
        return ge && (se[ge.position] += ge.amount), {
          ...K,
          height: V ? `calc(100% - ${se.top}px - ${se.bottom}px)` : z.value ? `${z.value}px` : void 0,
          left: X ? void 0 : `${se.left}px`,
          right: X ? `${se.right}px` : void 0,
          top: B.value !== "bottom" ? `${se.top}px` : void 0,
          bottom: B.value !== "top" ? `${se.bottom}px` : void 0,
          width: V ? z.value ? `${z.value}px` : void 0 : `calc(100% - ${se.left}px - ${se.right}px)`
        };
      }), R = E(() => ({
        zIndex: ne.value - 1
      }));
      return {
        layoutItemStyles: A,
        layoutItemScrimStyles: R,
        zIndex: ne
      };
    },
    unregister: (P) => {
      r.delete(P), a.delete(P), o.delete(P), l.delete(P), s.delete(P), i.value = i.value.filter((x) => x !== P);
    },
    mainRect: g,
    mainStyles: m,
    getLayoutItem: y,
    items: v,
    layoutRect: c,
    rootZIndex: n
  });
  const p = O(() => ["v-layout", {
    "v-layout--full-height": t.fullHeight
  }]), b = O(() => ({
    zIndex: e ? n.value : void 0,
    position: e ? "relative" : void 0,
    overflow: e ? "hidden" : void 0
  }));
  return {
    layoutClasses: p,
    layoutStyles: b,
    getLayoutItem: y,
    items: v,
    layoutRect: c,
    layoutRef: u
  };
}
const kp = U({
  scrollTarget: {
    type: String
  },
  scrollThreshold: {
    type: [String, Number],
    default: 300
  }
}, "scroll");
function Op(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    canScroll: n
  } = e;
  let i = 0, a = 0;
  const o = Z(null), r = Q(0), l = Q(0), s = Q(0), u = Q(!1), c = Q(!1), d = E(() => Number(t.scrollThreshold)), h = E(() => Gt((d.value - r.value) / d.value || 0)), f = () => {
    const g = o.value;
    if (!g || n && !n.value) return;
    i = r.value, r.value = "window" in g ? g.pageYOffset : g.scrollTop;
    const m = g instanceof Window ? document.documentElement.scrollHeight : g.scrollHeight;
    if (a !== m) {
      a = m;
      return;
    }
    c.value = r.value < i, s.value = Math.abs(r.value - d.value);
  };
  return ie(c, () => {
    l.value = l.value || r.value;
  }), ie(u, () => {
    l.value = 0;
  }), at(() => {
    ie(() => t.scrollTarget, (g) => {
      var v;
      const m = g ? document.querySelector(g) : window;
      if (!m) {
        In(`Unable to locate element with identifier ${g}`);
        return;
      }
      m !== o.value && ((v = o.value) == null || v.removeEventListener("scroll", f), o.value = m, o.value.addEventListener("scroll", f, {
        passive: !0
      }));
    }, {
      immediate: !0
    });
  }), pt(() => {
    var g;
    (g = o.value) == null || g.removeEventListener("scroll", f);
  }), n && ie(n, f, {
    immediate: !0
  }), {
    scrollThreshold: d,
    currentScroll: r,
    currentThreshold: s,
    isScrollActive: u,
    scrollRatio: h,
    // required only for testing
    // probably can be removed
    // later (2 chars chlng)
    isScrollingUp: c,
    savedScroll: l
  };
}
const Dp = U({
  scrollBehavior: String,
  modelValue: {
    type: Boolean,
    default: !0
  },
  location: {
    type: String,
    default: "top",
    validator: (t) => ["top", "bottom"].includes(t)
  },
  ...Zf(),
  ...iu(),
  ...kp(),
  height: {
    type: [Number, String],
    default: 64
  }
}, "VAppBar"), Gc = ee()({
  name: "VAppBar",
  props: Dp(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Z(), a = Xe(t, "modelValue"), o = E(() => {
      var M;
      const C = new Set(((M = t.scrollBehavior) == null ? void 0 : M.split(" ")) ?? []);
      return {
        hide: C.has("hide"),
        fullyHide: C.has("fully-hide"),
        inverted: C.has("inverted"),
        collapse: C.has("collapse"),
        elevate: C.has("elevate"),
        fadeImage: C.has("fade-image")
        // shrink: behavior.has('shrink'),
      };
    }), r = E(() => {
      const C = o.value;
      return C.hide || C.fullyHide || C.inverted || C.collapse || C.elevate || C.fadeImage || // behavior.shrink ||
      !a.value;
    }), {
      currentScroll: l,
      scrollThreshold: s,
      isScrollingUp: u,
      scrollRatio: c
    } = Op(t, {
      canScroll: r
    }), d = O(() => o.value.hide || o.value.fullyHide), h = E(() => t.collapse || o.value.collapse && (o.value.inverted ? c.value > 0 : c.value === 0)), f = E(() => t.flat || o.value.fullyHide && !a.value || o.value.elevate && (o.value.inverted ? l.value > 0 : l.value === 0)), g = E(() => o.value.fadeImage ? o.value.inverted ? 1 - c.value : c.value : void 0), m = E(() => {
      var p, b;
      if (o.value.hide && o.value.inverted) return 0;
      const C = ((p = i.value) == null ? void 0 : p.contentHeight) ?? 0, M = ((b = i.value) == null ? void 0 : b.extensionHeight) ?? 0;
      return d.value ? l.value < s.value || o.value.fullyHide ? C + M : C : C + M;
    });
    Nt(() => !!t.scrollBehavior, () => {
      Pt(() => {
        d.value ? o.value.inverted ? a.value = l.value > s.value : a.value = u.value || l.value < s.value : a.value = !0;
      });
    });
    const {
      ssrBootStyles: v
    } = Io(), {
      layoutItemStyles: y
    } = au({
      id: t.name,
      order: E(() => parseInt(t.order, 10)),
      position: O(() => t.location),
      layoutSize: m,
      elementSize: Q(void 0),
      active: a,
      absolute: O(() => t.absolute)
    });
    return le(() => {
      const C = Oc.filterProps(t);
      return S(Oc, oe({
        ref: i,
        class: ["v-app-bar", {
          "v-app-bar--bottom": t.location === "bottom"
        }, t.class],
        style: [{
          ...y.value,
          "--v-toolbar-image-opacity": g.value,
          height: void 0,
          ...v.value
        }, t.style]
      }, C, {
        collapse: h.value,
        flat: f.value
      }), n);
    }), {};
  }
}), Gp = U({
  ...Xf({
    icon: "$menu",
    variant: "text"
  })
}, "VAppBarNavIcon"), Nc = ee()({
  name: "VAppBarNavIcon",
  props: Gp(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return le(() => S(At, oe(t, {
      class: ["v-app-bar-nav-icon"]
    }), n)), {};
  }
}), Wc = ee()({
  name: "VAppBarTitle",
  props: jf(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    return le(() => S(Hf, oe(t, {
      class: "v-app-bar-title"
    }), n)), {};
  }
});
function Np(t) {
  let {
    rootEl: e,
    isSticky: n,
    layoutItemStyles: i
  } = t;
  const a = Q(!1), o = Q(0), r = E(() => {
    const u = typeof a.value == "boolean" ? "top" : a.value;
    return [n.value ? {
      top: "auto",
      bottom: "auto",
      height: void 0
    } : void 0, a.value ? {
      [u]: he(o.value)
    } : {
      top: i.value.top
    }];
  });
  at(() => {
    ie(n, (u) => {
      u ? window.addEventListener("scroll", s, {
        passive: !0
      }) : window.removeEventListener("scroll", s);
    }, {
      immediate: !0
    });
  }), pt(() => {
    window.removeEventListener("scroll", s);
  });
  let l = 0;
  function s() {
    const u = l > window.scrollY ? "up" : "down", c = e.value.getBoundingClientRect(), d = parseFloat(i.value.top ?? 0), h = window.scrollY - Math.max(0, o.value - d), f = c.height + Math.max(o.value, d) - window.scrollY - window.innerHeight, g = parseFloat(getComputedStyle(e.value).getPropertyValue("--v-body-scroll-y")) || 0;
    c.height < window.innerHeight - d ? (a.value = "top", o.value = d) : u === "up" && a.value === "bottom" || u === "down" && a.value === "top" ? (o.value = window.scrollY + c.top - g, a.value = !0) : u === "down" && f <= 0 ? (o.value = 0, a.value = "bottom") : u === "up" && h <= 0 && (g ? a.value !== "top" && (o.value = -h + g + d, a.value = "top") : (o.value = c.top + h, a.value = "top")), l = window.scrollY;
  }
  return {
    isStuck: a,
    stickyStyles: r
  };
}
const Wp = 100, $p = 20;
function $c(t) {
  return (t < 0 ? -1 : 1) * Math.sqrt(Math.abs(t)) * 1.41421356237;
}
function Xc(t) {
  if (t.length < 2)
    return 0;
  if (t.length === 2)
    return t[1].t === t[0].t ? 0 : (t[1].d - t[0].d) / (t[1].t - t[0].t);
  let e = 0;
  for (let n = t.length - 1; n > 0; n--) {
    if (t[n].t === t[n - 1].t)
      continue;
    const i = $c(e), a = (t[n].d - t[n - 1].d) / (t[n].t - t[n - 1].t);
    e += (a - i) * Math.abs(a), n === t.length - 1 && (e *= 0.5);
  }
  return $c(e) * 1e3;
}
function Xp() {
  const t = {};
  function e(a) {
    Array.from(a.changedTouches).forEach((o) => {
      (t[o.identifier] ?? (t[o.identifier] = new hh($p))).push([a.timeStamp, o]);
    });
  }
  function n(a) {
    Array.from(a.changedTouches).forEach((o) => {
      delete t[o.identifier];
    });
  }
  function i(a) {
    var u;
    const o = (u = t[a]) == null ? void 0 : u.values().reverse();
    if (!o)
      throw new Error(`No samples for touch id ${a}`);
    const r = o[0], l = [], s = [];
    for (const c of o) {
      if (r[0] - c[0] > Wp) break;
      l.push({
        t: c[0],
        d: c[1].clientX
      }), s.push({
        t: c[0],
        d: c[1].clientY
      });
    }
    return {
      x: Xc(l),
      y: Xc(s),
      get direction() {
        const {
          x: c,
          y: d
        } = this, [h, f] = [Math.abs(c), Math.abs(d)];
        return h > f && c >= 0 ? "right" : h > f && c <= 0 ? "left" : f > h && d >= 0 ? "down" : f > h && d <= 0 ? "up" : Up();
      }
    };
  }
  return {
    addMovement: e,
    endTouch: n,
    getVelocity: i
  };
}
function Up() {
  throw new Error();
}
function Yp(t) {
  let {
    el: e,
    isActive: n,
    isTemporary: i,
    width: a,
    touchless: o,
    position: r
  } = t;
  at(() => {
    window.addEventListener("touchstart", C, {
      passive: !0
    }), window.addEventListener("touchmove", M, {
      passive: !1
    }), window.addEventListener("touchend", p, {
      passive: !0
    });
  }), pt(() => {
    window.removeEventListener("touchstart", C), window.removeEventListener("touchmove", M), window.removeEventListener("touchend", p);
  });
  const l = E(() => ["left", "right"].includes(r.value)), {
    addMovement: s,
    endTouch: u,
    getVelocity: c
  } = Xp();
  let d = !1;
  const h = Q(!1), f = Q(0), g = Q(0);
  let m;
  function v(P, x) {
    return (r.value === "left" ? P : r.value === "right" ? document.documentElement.clientWidth - P : r.value === "top" ? P : r.value === "bottom" ? document.documentElement.clientHeight - P : Ki()) - (x ? a.value : 0);
  }
  function y(P) {
    let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const _ = r.value === "left" ? (P - g.value) / a.value : r.value === "right" ? (document.documentElement.clientWidth - P - g.value) / a.value : r.value === "top" ? (P - g.value) / a.value : r.value === "bottom" ? (document.documentElement.clientHeight - P - g.value) / a.value : Ki();
    return x ? Gt(_) : _;
  }
  function C(P) {
    if (o.value) return;
    const x = P.changedTouches[0].clientX, _ = P.changedTouches[0].clientY, T = 25, B = r.value === "left" ? x < T : r.value === "right" ? x > document.documentElement.clientWidth - T : r.value === "top" ? _ < T : r.value === "bottom" ? _ > document.documentElement.clientHeight - T : Ki(), L = n.value && (r.value === "left" ? x < a.value : r.value === "right" ? x > document.documentElement.clientWidth - a.value : r.value === "top" ? _ < a.value : r.value === "bottom" ? _ > document.documentElement.clientHeight - a.value : Ki());
    (B || L || n.value && i.value) && (m = [x, _], g.value = v(l.value ? x : _, n.value), f.value = y(l.value ? x : _), d = g.value > -20 && g.value < 80, u(P), s(P));
  }
  function M(P) {
    const x = P.changedTouches[0].clientX, _ = P.changedTouches[0].clientY;
    if (d) {
      if (!P.cancelable) {
        d = !1;
        return;
      }
      const B = Math.abs(x - m[0]), L = Math.abs(_ - m[1]);
      (l.value ? B > L && B > 3 : L > B && L > 3) ? (h.value = !0, d = !1) : (l.value ? L : B) > 3 && (d = !1);
    }
    if (!h.value) return;
    P.preventDefault(), s(P);
    const T = y(l.value ? x : _, !1);
    f.value = Math.max(0, Math.min(1, T)), T > 1 ? g.value = v(l.value ? x : _, !0) : T < 0 && (g.value = v(l.value ? x : _, !1));
  }
  function p(P) {
    if (d = !1, !h.value) return;
    s(P), h.value = !1;
    const x = c(P.changedTouches[0].identifier), _ = Math.abs(x.x), T = Math.abs(x.y);
    (l.value ? _ > T && _ > 400 : T > _ && T > 3) ? n.value = x.direction === ({
      left: "right",
      right: "left",
      top: "down",
      bottom: "up"
    }[r.value] || Ki()) : n.value = f.value > 0.5;
  }
  const b = E(() => h.value ? {
    transform: r.value === "left" ? `translateX(calc(-100% + ${f.value * a.value}px))` : r.value === "right" ? `translateX(calc(100% - ${f.value * a.value}px))` : r.value === "top" ? `translateY(calc(-100% + ${f.value * a.value}px))` : r.value === "bottom" ? `translateY(calc(100% - ${f.value * a.value}px))` : Ki(),
    transition: "none"
  } : void 0);
  return Nt(h, () => {
    var _, T;
    const P = ((_ = e.value) == null ? void 0 : _.style.transform) ?? null, x = ((T = e.value) == null ? void 0 : T.style.transition) ?? null;
    Pt(() => {
      var B, L, z, I;
      (L = e.value) == null || L.style.setProperty("transform", ((B = b.value) == null ? void 0 : B.transform) || "none"), (I = e.value) == null || I.style.setProperty("transition", ((z = b.value) == null ? void 0 : z.transition) || null);
    }), _t(() => {
      var B, L;
      (B = e.value) == null || B.style.setProperty("transform", P), (L = e.value) == null || L.style.setProperty("transition", x);
    });
  }), {
    isDragging: h,
    dragProgress: f,
    dragStyles: b
  };
}
function Ki() {
  throw new Error();
}
const jp = ["start", "end", "left", "right", "top", "bottom"], Hp = U({
  color: String,
  disableResizeWatcher: Boolean,
  disableRouteWatcher: Boolean,
  expandOnHover: Boolean,
  floating: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  permanent: Boolean,
  rail: {
    type: Boolean,
    default: null
  },
  railWidth: {
    type: [Number, String],
    default: 56
  },
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  image: String,
  temporary: Boolean,
  persistent: Boolean,
  touchless: Boolean,
  width: {
    type: [Number, String],
    default: 256
  },
  location: {
    type: String,
    default: "start",
    validator: (t) => jp.includes(t)
  },
  sticky: Boolean,
  ...vn(),
  ...ve(),
  ...Cf(),
  ...Yh({
    mobile: null
  }),
  ...Cn(),
  ...iu(),
  ...Tt(),
  ...Oe({
    tag: "nav"
  }),
  ...Ue()
}, "VNavigationDrawer"), Zp = ee()({
  name: "VNavigationDrawer",
  props: Hp(),
  emits: {
    "update:modelValue": (t) => !0,
    "update:rail": (t) => !0
  },
  setup(t, e) {
    let {
      attrs: n,
      emit: i,
      slots: a
    } = e;
    const {
      isRtl: o
    } = Wt(), {
      themeClasses: r
    } = et(t), {
      borderClasses: l
    } = yn(t), {
      backgroundColorClasses: s,
      backgroundColorStyles: u
    } = xt(() => t.color), {
      elevationClasses: c
    } = pn(t), {
      displayClasses: d,
      mobile: h
    } = Vr(t), {
      roundedClasses: f
    } = wt(t), g = Qh(), m = Xe(t, "modelValue", null, (A) => !!A), {
      ssrBootStyles: v
    } = Io(), {
      scopeId: y
    } = Ys(), C = Z(), M = Q(!1), {
      runOpenDelay: p,
      runCloseDelay: b
    } = pf(t, (A) => {
      M.value = A;
    }), P = E(() => t.rail && t.expandOnHover && M.value ? Number(t.width) : Number(t.rail ? t.railWidth : t.width)), x = E(() => Ul(t.location, o.value)), _ = O(() => t.persistent), T = E(() => !t.permanent && (h.value || t.temporary)), B = E(() => t.sticky && !T.value && x.value !== "bottom");
    Nt(() => t.expandOnHover && t.rail != null, () => {
      ie(M, (A) => i("update:rail", !A));
    }), Nt(() => !t.disableResizeWatcher, () => {
      ie(T, (A) => !t.permanent && Ye(() => m.value = !A));
    }), Nt(() => !t.disableRouteWatcher && !!g, () => {
      ie(g.currentRoute, () => T.value && (m.value = !1));
    }), ie(() => t.permanent, (A) => {
      A && (m.value = !0);
    }), t.modelValue == null && !T.value && (m.value = t.permanent || !h.value);
    const {
      isDragging: L,
      dragProgress: z
    } = Yp({
      el: C,
      isActive: m,
      isTemporary: T,
      width: P,
      touchless: O(() => t.touchless),
      position: x
    }), I = E(() => {
      const A = T.value ? 0 : t.rail && t.expandOnHover ? Number(t.railWidth) : P.value;
      return L.value ? A * z.value : A;
    }), {
      layoutItemStyles: k,
      layoutItemScrimStyles: G
    } = au({
      id: t.name,
      order: E(() => parseInt(t.order, 10)),
      position: x,
      layoutSize: I,
      elementSize: P,
      active: Ir(m),
      disableTransitions: O(() => L.value),
      absolute: E(() => (
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        t.absolute || B.value && typeof F.value != "string"
      ))
    }), {
      isStuck: F,
      stickyStyles: q
    } = Np({
      rootEl: C,
      isSticky: B,
      layoutItemStyles: k
    }), j = xt(() => typeof t.scrim == "string" ? t.scrim : null), ne = E(() => ({
      ...L.value ? {
        opacity: z.value * 0.2,
        transition: "none"
      } : void 0,
      ...G.value
    }));
    return ai({
      VList: {
        bgColor: "transparent"
      }
    }), le(() => {
      const A = a.image || t.image;
      return w(pe, null, [S(t.tag, oe({
        ref: C,
        onMouseenter: p,
        onMouseleave: b,
        class: ["v-navigation-drawer", `v-navigation-drawer--${x.value}`, {
          "v-navigation-drawer--expand-on-hover": t.expandOnHover,
          "v-navigation-drawer--floating": t.floating,
          "v-navigation-drawer--is-hovering": M.value,
          "v-navigation-drawer--rail": t.rail,
          "v-navigation-drawer--temporary": T.value,
          "v-navigation-drawer--persistent": _.value,
          "v-navigation-drawer--active": m.value,
          "v-navigation-drawer--sticky": B.value
        }, r.value, s.value, l.value, d.value, c.value, f.value, t.class],
        style: [u.value, k.value, v.value, q.value, t.style]
      }, y, n), {
        default: () => {
          var R, V, X;
          return [A && w("div", {
            key: "image",
            class: "v-navigation-drawer__img"
          }, [a.image ? S(We, {
            key: "image-defaults",
            disabled: !t.image,
            defaults: {
              VImg: {
                alt: "",
                cover: !0,
                height: "inherit",
                src: t.image
              }
            }
          }, a.image) : S(nn, {
            key: "image-img",
            alt: "",
            cover: !0,
            height: "inherit",
            src: t.image
          }, null)]), a.prepend && w("div", {
            class: "v-navigation-drawer__prepend"
          }, [(R = a.prepend) == null ? void 0 : R.call(a)]), w("div", {
            class: "v-navigation-drawer__content"
          }, [(V = a.default) == null ? void 0 : V.call(a)]), a.append && w("div", {
            class: "v-navigation-drawer__append"
          }, [(X = a.append) == null ? void 0 : X.call(a)])];
        }
      }), S(Si, {
        name: "fade-transition"
      }, {
        default: () => [T.value && (L.value || m.value) && !!t.scrim && w("div", oe({
          class: ["v-navigation-drawer__scrim", j.backgroundColorClasses.value],
          style: [ne.value, j.backgroundColorStyles.value],
          onClick: () => {
            _.value || (m.value = !1);
          }
        }, y), null)]
      })]);
    }), {
      isStuck: F
    };
  }
}), Kp = ["onClick"], qp = { class: "d-flex align-center" }, Jp = ["src"], Qp = {
  key: 1,
  style: { "margin-left": "10px" }
}, e_ = { class: "d-flex align-center" }, t_ = ["src"], n_ = {
  key: 1,
  style: { "margin-left": "10px" }
}, i_ = { class: "desktop-menu d-flex justify-center align-center" }, a_ = {
  __name: "AppBar",
  setup(t) {
    const { getText: e, getAncor: n } = ri(), i = ah(), a = Z(null), o = kn(), { data: r } = tn(o), l = r.value.info, s = r.value.components, u = r.value.addOn, c = u && u.includes("Shop"), d = u && u.includes("Multilingual") && l.locales.length > 1, h = wa(), f = (v) => {
      if (v.type === "ancor") {
        const y = n(v.path).toLowerCase(), C = document.getElementById(y);
        if (C) {
          const p = C.getBoundingClientRect().top + window.scrollY - 64;
          window.scrollTo({ top: p, behavior: "smooth" });
        }
      } else v.type === "externalLink" ? window.open(v.path, "_blank") : v.type === "internalLink" && (window.location.href = v.path);
    }, g = E(() => {
      let v = [];
      return u && u.includes("VirtualTour") && v.push({
        title: "Virtual Tour",
        path: "https://test-virtual-tour.replit.app/",
        type: "externalLink"
      }), u && u.includes("Blog") && v.push({
        title: "Blog",
        path: "/blog",
        type: "internalLink"
      }), v = v.concat(s.filter((y) => y.menu).map((y) => ({
        title: e(y.menu),
        path: n(y.menu).toLowerCase(),
        type: "ancor"
      }))), l.menuHomeLink ? [{ title: "Home", path: "/", type: "internalLink" }, ...v] : v;
    }), m = E(() => i.products.reduce((v, y) => v + y.quantity, 0));
    return (v, y) => (J(), Ie(pe, null, [
      S(Zp, {
        modelValue: a.value,
        "onUpdate:modelValue": y[0] || (y[0] = (C) => a.value = C),
        location: "bottom",
        temporary: "",
        touchless: ""
      }, {
        default: H(() => [
          S(Ia, null, {
            default: H(() => [
              (J(!0), Ie(pe, null, Ft(g.value, (C) => (J(), Ce(Fn, {
                key: C.path
              }, {
                default: H(() => [
                  w("div", {
                    onClick: (M) => f(C)
                  }, Ge(C.title), 9, Kp)
                ]),
                _: 2
              }, 1024))), 128))
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue"]),
      W(h) ? (J(), Ce(Gc, {
        key: 0,
        elevation: 2,
        color: W(l).primaryColor
      }, {
        default: H(() => [
          S(Nc, {
            onClick: y[1] || (y[1] = Ja((C) => a.value = !a.value, ["stop"]))
          }),
          S(Wc, null, {
            default: H(() => [
              w("div", qp, [
                W(l).logo && (W(l).logoMode === "logo" || W(l).logoMode === "both") ? (J(), Ie("img", {
                  key: 0,
                  src: W(l).logo,
                  alt: "Logo",
                  class: "app-logo"
                }, null, 8, Jp)) : Ae("", !0),
                W(l).logoMode === "text" || W(l).logoMode === "both" || !W(l).logoMode ? (J(), Ie("b", Qp, Ge(W(l).name), 1)) : Ae("", !0)
              ])
            ]),
            _: 1
          }),
          W(c) && m.value != 0 ? (J(), Ce(Fc, { key: 0 })) : Ae("", !0),
          W(d) ? (J(), Ce(kc, { key: 1 })) : Ae("", !0)
        ]),
        _: 1
      }, 8, ["color"])) : Ae("", !0),
      W(h) ? Ae("", !0) : (J(), Ce(Gc, {
        key: 1,
        elevation: 2,
        color: W(l).primaryColor
      }, {
        default: H(() => [
          W(h) ? (J(), Ce(Nc, {
            key: 0,
            onClick: y[2] || (y[2] = Ja((C) => a.value = !a.value, ["stop"]))
          })) : Ae("", !0),
          S(Wc, null, {
            default: H(() => [
              w("div", e_, [
                W(l).logo && (W(l).logoMode === "logo" || W(l).logoMode === "both") ? (J(), Ie("img", {
                  key: 0,
                  src: W(l).logo,
                  alt: "Logo",
                  class: "app-logo"
                }, null, 8, t_)) : Ae("", !0),
                W(l).logoMode === "text" || W(l).logoMode === "both" || !W(l).logoMode ? (J(), Ie("b", n_, Ge(W(l).name), 1)) : Ae("", !0)
              ])
            ]),
            _: 1
          }),
          w("div", i_, [
            (J(!0), Ie(pe, null, Ft(g.value, (C) => (J(), Ce(At, {
              key: C.path,
              variant: "text",
              onClick: (M) => f(C)
            }, {
              default: H(() => [
                ct(Ge(C.title), 1)
              ]),
              _: 2
            }, 1032, ["onClick"]))), 128)),
            W(c) && m.value != 0 ? (J(), Ce(Fc, { key: 0 })) : Ae("", !0),
            W(d) ? (J(), Ce(kc, { key: 1 })) : Ae("", !0)
          ])
        ]),
        _: 1
      }, 8, ["color"]))
    ], 64));
  }
}, qf = /* @__PURE__ */ rn(a_, [["__scopeId", "data-v-f9d3029e"]]), o_ = U({
  app: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...vn(),
  ...ve(),
  ...Cn(),
  ...iu(),
  ...Tt(),
  ...Oe({
    tag: "footer"
  }),
  ...Ue()
}, "VFooter"), r_ = ee()({
  name: "VFooter",
  props: o_(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Z(), {
      themeClasses: a
    } = et(t), {
      backgroundColorClasses: o,
      backgroundColorStyles: r
    } = xt(() => t.color), {
      borderClasses: l
    } = yn(t), {
      elevationClasses: s
    } = pn(t), {
      roundedClasses: u
    } = wt(t), c = Q(32), {
      resizeRef: d
    } = Wi((f) => {
      f.length && (c.value = f[0].target.clientHeight);
    }), h = E(() => t.height === "auto" ? c.value : parseInt(t.height, 10));
    return Nt(() => t.app, () => {
      const f = au({
        id: t.name,
        order: E(() => parseInt(t.order, 10)),
        position: O(() => "bottom"),
        layoutSize: h,
        elementSize: E(() => t.height === "auto" ? void 0 : h.value),
        active: O(() => t.app),
        absolute: O(() => t.absolute)
      });
      Pt(() => {
        i.value = f.layoutItemStyles.value;
      });
    }), le(() => S(t.tag, {
      ref: d,
      class: te(["v-footer", a.value, o.value, l.value, s.value, u.value, t.class]),
      style: re([r.value, t.app ? i.value : {
        height: he(t.height)
      }, t.style])
    }, n)), {};
  }
}), l_ = { key: 0 }, s_ = {
  href: "https://fastsite.it",
  class: "fast-site-link",
  target: "_blank"
}, u_ = {
  __name: "Footer",
  setup(t) {
    const e = kn(), { data: n } = tn(e);
    return (i, a) => (J(), Ce(r_, {
      elevation: "2",
      color: W(n).info.primaryColor
    }, {
      default: H(() => [
        S(gn, null, {
          default: H(() => [
            S(pa, null, {
              default: H(() => [
                S(dn, { cols: "6" }, {
                  default: H(() => [
                    ct(Ge((/* @__PURE__ */ new Date()).getFullYear()) + "  ", 1),
                    w("strong", null, Ge(W(n).info.name), 1),
                    W(n).info.iva ? (J(), Ie("div", l_, "P. IVA " + Ge(W(n).info.iva), 1)) : Ae("", !0)
                  ]),
                  _: 1
                }),
                S(dn, {
                  cols: "6",
                  class: "text-right"
                }, {
                  default: H(() => [
                    a[3] || (a[3] = w("a", {
                      href: "/PrivacyPolicyForm.pdf",
                      class: "footer-link",
                      target: "_blank"
                    }, "Privacy Policy", -1)),
                    w("div", null, [
                      a[2] || (a[2] = ct(" Powered by ", -1)),
                      w("a", s_, [
                        a[1] || (a[1] = ct(" Fast-Site ", -1)),
                        S(Be, { right: "" }, {
                          default: H(() => a[0] || (a[0] = [
                            ct("mdi-web", -1)
                          ])),
                          _: 1,
                          __: [0]
                        })
                      ])
                    ])
                  ]),
                  _: 1,
                  __: [3]
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["color"]));
  }
}, Jf = /* @__PURE__ */ rn(u_, [["__scopeId", "data-v-5d96d66f"]]);
let c_;
function d_() {
  return c_;
}
Xm[0];
function h_(t) {
  return typeof t == "function" ? t() : W(t);
}
function ts(t) {
  if (t instanceof Promise || t instanceof Date || t instanceof RegExp)
    return t;
  const e = h_(t);
  if (!t || !e)
    return e;
  if (Array.isArray(e))
    return e.map((n) => ts(n));
  if (typeof e == "object") {
    const n = {};
    for (const i in e)
      if (Object.prototype.hasOwnProperty.call(e, i)) {
        if (i === "titleTemplate" || i[0] === "o" && i[1] === "n") {
          n[i] = W(e[i]);
          continue;
        }
        n[i] = ts(e[i]);
      }
    return n;
  }
  return e;
}
const f_ = "usehead", Uc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Yc = "__unhead_injection_handler__";
function g_() {
  if (Yc in Uc)
    return Uc[Yc]();
  const t = Ne(f_);
  return !t && process.env.NODE_ENV !== "production" && console.warn("Unhead is missing Vue context, falling back to shared context. This may have unexpected results."), t || d_();
}
function m_(t, e = {}) {
  const n = e.head || g_();
  if (n)
    return n.ssr ? n.push(t, e) : v_(n, t, e);
}
function v_(t, e, n = {}) {
  const i = Z(!1), a = Z({});
  Pt(() => {
    a.value = i.value ? {} : ts(e);
  });
  const o = t.push(a.value, n);
  return ie(a, (l) => {
    o.patch(l);
  }), Kd() && (pt(() => {
    o.dispose();
  }), xs(() => {
    i.value = !0;
  }), Jd(() => {
    i.value = !1;
  })), o;
}
class li {
  /**
   * @param {string} type Type.
   */
  constructor(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
const _a = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class ou {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
function y_(t, e, n) {
  let i, a;
  n = n || ei;
  let o = 0, r = t.length, l = !1;
  for (; o < r; )
    i = o + (r - o >> 1), a = +n(t[i], e), a < 0 ? o = i + 1 : (r = i, l = !a);
  return l ? o : ~o;
}
function ei(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
}
function ru(t, e, n) {
  if (t[0] <= e)
    return 0;
  const i = t.length;
  if (e <= t[i - 1])
    return i - 1;
  if (typeof n == "function") {
    for (let a = 1; a < i; ++a) {
      const o = t[a];
      if (o === e)
        return a;
      if (o < e)
        return n(e, t[a - 1], o) > 0 ? a - 1 : a;
    }
    return i - 1;
  }
  if (n > 0) {
    for (let a = 1; a < i; ++a)
      if (t[a] < e)
        return a - 1;
    return i - 1;
  }
  if (n < 0) {
    for (let a = 1; a < i; ++a)
      if (t[a] <= e)
        return a;
    return i - 1;
  }
  for (let a = 1; a < i; ++a) {
    if (t[a] == e)
      return a;
    if (t[a] < e)
      return t[a - 1] - e < e - t[a] ? a - 1 : a;
  }
  return i - 1;
}
function C_(t, e, n) {
  for (; e < n; ) {
    const i = t[e];
    t[e] = t[n], t[n] = i, ++e, --n;
  }
}
function lu(t, e) {
  const n = Array.isArray(e) ? e : [e], i = n.length;
  for (let a = 0; a < i; a++)
    t[t.length] = n[a];
}
function Ei(t, e) {
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let i = 0; i < n; i++)
    if (t[i] !== e[i])
      return !1;
  return !0;
}
function p_(t, e, n) {
  const i = e || ei;
  return t.every(function(a, o) {
    if (o === 0)
      return !0;
    const r = i(t[o - 1], a);
    return !(r > 0 || r === 0);
  });
}
function oo() {
  return !0;
}
function Nr() {
  return !1;
}
function Sa() {
}
function Qf(t) {
  let e = !1, n, i, a;
  return function() {
    const o = Array.prototype.slice.call(arguments);
    return (!e || this !== a || !Ei(o, i)) && (e = !0, a = this, i = o, n = t.apply(this, arguments)), n;
  };
}
function __(t) {
  function e() {
    let n;
    try {
      n = t();
    } catch (i) {
      return Promise.reject(i);
    }
    return n instanceof Promise ? n : Promise.resolve(n);
  }
  return e();
}
function Lo(t) {
  for (const e in t)
    delete t[e];
}
function ba(t) {
  let e;
  for (e in t)
    return !1;
  return !e;
}
class Wr extends ou {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(e) {
    super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(e, n) {
    if (!e || !n)
      return;
    const i = this.listeners_ || (this.listeners_ = {}), a = i[e] || (i[e] = []);
    a.includes(n) || a.push(n);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(e) {
    const n = typeof e == "string", i = n ? e : e.type, a = this.listeners_ && this.listeners_[i];
    if (!a)
      return;
    const o = n ? new li(e) : (
      /** @type {Event} */
      e
    );
    o.target || (o.target = this.eventTarget_ || this);
    const r = this.dispatching_ || (this.dispatching_ = {}), l = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    i in r || (r[i] = 0, l[i] = 0), ++r[i];
    let s;
    for (let u = 0, c = a.length; u < c; ++u)
      if ("handleEvent" in a[u] ? s = /** @type {import("../events.js").ListenerObject} */
      a[u].handleEvent(o) : s = /** @type {import("../events.js").ListenerFunction} */
      a[u].call(this, o), s === !1 || o.propagationStopped) {
        s = !1;
        break;
      }
    if (--r[i] === 0) {
      let u = l[i];
      for (delete l[i]; u--; )
        this.removeEventListener(i, Sa);
      delete r[i];
    }
    return s;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && Lo(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(e) {
    return this.listeners_ && this.listeners_[e] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(e) {
    return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(e, n) {
    if (!this.listeners_)
      return;
    const i = this.listeners_[e];
    if (!i)
      return;
    const a = i.indexOf(n);
    a !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (i[a] = Sa, ++this.pendingRemovals_[e]) : (i.splice(a, 1), i.length === 0 && delete this.listeners_[e]));
  }
}
const Se = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function we(t, e, n, i, a) {
  if (i && i !== t && (n = n.bind(i)), a) {
    const r = n;
    n = function() {
      t.removeEventListener(e, n), r.apply(this, arguments);
    };
  }
  const o = {
    target: t,
    type: e,
    listener: n
  };
  return t.addEventListener(e, n), o;
}
function vr(t, e, n, i) {
  return we(t, e, n, i, !0);
}
function $e(t) {
  t && t.target && (t.target.removeEventListener(t.type, t.listener), Lo(t));
}
class Vo extends Wr {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(Se.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(e, n) {
    if (Array.isArray(e)) {
      const i = e.length, a = new Array(i);
      for (let o = 0; o < i; ++o)
        a[o] = we(this, e[o], n);
      return a;
    }
    return we(
      this,
      /** @type {string} */
      e,
      n
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(e, n) {
    let i;
    if (Array.isArray(e)) {
      const a = e.length;
      i = new Array(a);
      for (let o = 0; o < a; ++o)
        i[o] = vr(this, e[o], n);
    } else
      i = vr(
        this,
        /** @type {string} */
        e,
        n
      );
    return n.ol_key = i, i;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(e, n) {
    const i = (
      /** @type {Object} */
      n.ol_key
    );
    if (i)
      S_(i);
    else if (Array.isArray(e))
      for (let a = 0, o = e.length; a < o; ++a)
        this.removeEventListener(e[a], n);
    else
      this.removeEventListener(e, n);
  }
}
Vo.prototype.on;
Vo.prototype.once;
Vo.prototype.un;
function S_(t) {
  if (Array.isArray(t))
    for (let e = 0, n = t.length; e < n; ++e)
      $e(t[e]);
  else
    $e(
      /** @type {import("./events.js").EventsKey} */
      t
    );
}
function Re() {
  throw new Error("Unimplemented abstract method.");
}
let b_ = 0;
function Ve(t) {
  return t.ol_uid || (t.ol_uid = String(++b_));
}
class jc extends li {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(e, n, i) {
    super(e), this.key = n, this.oldValue = i;
  }
}
class _n extends Vo {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, Ve(this), this.values_ = null, e !== void 0 && this.setProperties(e);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(e) {
    let n;
    return this.values_ && this.values_.hasOwnProperty(e) && (n = this.values_[e]), n;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(e, n) {
    let i;
    i = `change:${e}`, this.hasListener(i) && this.dispatchEvent(new jc(i, e, n)), i = _a.PROPERTYCHANGE, this.hasListener(i) && this.dispatchEvent(new jc(i, e, n));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(e, n) {
    this.addEventListener(`change:${e}`, n);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(e, n) {
    this.removeEventListener(`change:${e}`, n);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(e, n, i) {
    const a = this.values_ || (this.values_ = {});
    if (i)
      a[e] = n;
    else {
      const o = a[e];
      a[e] = n, o !== n && this.notify(e, o);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(e, n) {
    for (const i in e)
      this.set(i, e[i], n);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(e) {
    e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(e, n) {
    if (this.values_ && e in this.values_) {
      const i = this.values_[e];
      delete this.values_[e], ba(this.values_) && (this.values_ = null), n || this.notify(e, i);
    }
  }
}
const Rt = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, Hc = {
  LENGTH: "length"
};
class Uo extends li {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(e, n, i) {
    super(e), this.element = n, this.index = i;
  }
}
class wn extends _n {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(e, n) {
    if (super(), this.on, this.once, this.un, n = n || {}, this.unique_ = !!n.unique, this.array_ = e || [], this.unique_)
      for (let i = 0, a = this.array_.length; i < a; ++i)
        this.assertUnique_(this.array_[i], i);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(e) {
    for (let n = 0, i = e.length; n < i; ++n)
      this.push(e[n]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(e) {
    const n = this.array_;
    for (let i = 0, a = n.length; i < a; ++i)
      e(n[i], i, n);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(e) {
    return this.array_[e];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(Hc.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(e, n) {
    if (e < 0 || e > this.getLength())
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(n), this.array_.splice(e, 0, n), this.updateLength_(), this.dispatchEvent(
      new Uo(Rt.ADD, n, e)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(e) {
    this.unique_ && this.assertUnique_(e);
    const n = this.getLength();
    return this.insertAt(n, e), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(e) {
    const n = this.array_;
    for (let i = 0, a = n.length; i < a; ++i)
      if (n[i] === e)
        return this.removeAt(i);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(e) {
    if (e < 0 || e >= this.getLength())
      return;
    const n = this.array_[e];
    return this.array_.splice(e, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Uo(Rt.REMOVE, n, e)
    ), n;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(e, n) {
    const i = this.getLength();
    if (e >= i) {
      this.insertAt(e, n);
      return;
    }
    if (e < 0)
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(n, e);
    const a = this.array_[e];
    this.array_[e] = n, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Uo(Rt.REMOVE, a, e)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Uo(Rt.ADD, n, e)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(Hc.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(e, n) {
    for (let i = 0, a = this.array_.length; i < a; ++i)
      if (this.array_[i] === e && i !== n)
        throw new Error("Duplicate item added to a unique collection");
  }
}
const Fe = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
function Ee(t, e) {
  if (!t)
    throw new Error(e);
}
function tt(t, e, n) {
  return Math.min(Math.max(t, e), n);
}
function M_(t, e, n, i, a, o) {
  const r = a - n, l = o - i;
  if (r !== 0 || l !== 0) {
    const s = ((t - n) * r + (e - i) * l) / (r * r + l * l);
    s > 1 ? (n = a, i = o) : s > 0 && (n += r * s, i += l * s);
  }
  return fa(t, e, n, i);
}
function fa(t, e, n, i) {
  const a = n - t, o = i - e;
  return a * a + o * o;
}
function x_(t) {
  const e = t.length;
  for (let i = 0; i < e; i++) {
    let a = i, o = Math.abs(t[i][i]);
    for (let l = i + 1; l < e; l++) {
      const s = Math.abs(t[l][i]);
      s > o && (o = s, a = l);
    }
    if (o === 0)
      return null;
    const r = t[a];
    t[a] = t[i], t[i] = r;
    for (let l = i + 1; l < e; l++) {
      const s = -t[l][i] / t[i][i];
      for (let u = i; u < e + 1; u++)
        i == u ? t[l][u] = 0 : t[l][u] += s * t[i][u];
    }
  }
  const n = new Array(e);
  for (let i = e - 1; i >= 0; i--) {
    n[i] = t[i][e] / t[i][i];
    for (let a = i - 1; a >= 0; a--)
      t[a][e] -= t[a][i] * n[i];
  }
  return n;
}
function ar(t) {
  return t * Math.PI / 180;
}
function ga(t, e) {
  const n = t % e;
  return n * e < 0 ? n + e : n;
}
function qt(t, e, n) {
  return t + n * (e - t);
}
function su(t, e) {
  const n = Math.pow(10, e);
  return Math.round(t * n) / n;
}
function Yo(t, e) {
  return Math.floor(su(t, e));
}
function jo(t, e) {
  return Math.ceil(su(t, e));
}
class eg extends _n {
  /**
   * @param {Options} options Layer options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.background_ = e.background;
    const n = Object.assign({}, e);
    typeof e.properties == "object" && (delete n.properties, Object.assign(n, e.properties)), n[Fe.OPACITY] = e.opacity !== void 0 ? e.opacity : 1, Ee(
      typeof n[Fe.OPACITY] == "number",
      "Layer opacity must be a number"
    ), n[Fe.VISIBLE] = e.visible !== void 0 ? e.visible : !0, n[Fe.Z_INDEX] = e.zIndex, n[Fe.MAX_RESOLUTION] = e.maxResolution !== void 0 ? e.maxResolution : 1 / 0, n[Fe.MIN_RESOLUTION] = e.minResolution !== void 0 ? e.minResolution : 0, n[Fe.MIN_ZOOM] = e.minZoom !== void 0 ? e.minZoom : -1 / 0, n[Fe.MAX_ZOOM] = e.maxZoom !== void 0 ? e.maxZoom : 1 / 0, this.className_ = n.className !== void 0 ? n.className : "ol-layer", delete n.className, this.setProperties(n), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(e) {
    const n = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: e === void 0 ? !0 : e
    }, i = this.getZIndex();
    return n.opacity = tt(Math.round(this.getOpacity() * 100) / 100, 0, 1), n.visible = this.getVisible(), n.extent = this.getExtent(), n.zIndex = i === void 0 && !n.managed ? 1 / 0 : i, n.maxResolution = this.getMaxResolution(), n.minResolution = Math.max(this.getMinResolution(), 0), n.minZoom = this.getMinZoom(), n.maxZoom = this.getMaxZoom(), this.state_ = n, n;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return Re();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return Re();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(Fe.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(Fe.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(Fe.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(Fe.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(Fe.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(Fe.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return Re();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(Fe.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(Fe.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(e) {
    this.background_ = e, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(e) {
    this.set(Fe.EXTENT, e);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(e) {
    this.set(Fe.MAX_RESOLUTION, e);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(e) {
    this.set(Fe.MIN_RESOLUTION, e);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(e) {
    this.set(Fe.MAX_ZOOM, e);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(e) {
    this.set(Fe.MIN_ZOOM, e);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(e) {
    Ee(typeof e == "number", "Layer opacity must be a number"), this.set(Fe.OPACITY, e);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(e) {
    this.set(Fe.VISIBLE, e);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(e) {
    this.set(Fe.Z_INDEX, e);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
const Qt = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
}, vt = {
  ANIMATING: 0,
  INTERACTING: 1
}, un = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
}, P_ = 42, uu = 256, cu = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
class tg {
  /**
   * @param {Options} options Projection options.
   */
  constructor(e) {
    this.code_ = e.code, this.units_ = /** @type {import("./Units.js").Units} */
    e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || cu[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(e) {
    this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(e) {
    this.defaultTileGrid_ = e;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(e) {
    this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(e) {
    this.worldExtent_ = e;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(e) {
    this.getPointResolutionFunc_ = e;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const Bo = 6378137, ua = Math.PI * Bo, T_ = [-ua, -ua, ua, ua], w_ = [-180, -85, 180, 85], Ho = Bo * Math.log(Math.tan(Math.PI / 2));
class qi extends tg {
  /**
   * @param {string} code Code.
   */
  constructor(e) {
    super({
      code: e,
      units: "m",
      extent: T_,
      global: !0,
      worldExtent: w_,
      getPointResolution: function(n, i) {
        return n / Math.cosh(i[1] / Bo);
      }
    });
  }
}
const Zc = [
  new qi("EPSG:3857"),
  new qi("EPSG:102100"),
  new qi("EPSG:102113"),
  new qi("EPSG:900913"),
  new qi("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new qi("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function E_(t, e, n) {
  const i = t.length;
  n = n > 1 ? n : 2, e === void 0 && (n > 2 ? e = t.slice() : e = new Array(i));
  for (let a = 0; a < i; a += n) {
    e[a] = ua * t[a] / 180;
    let o = Bo * Math.log(Math.tan(Math.PI * (+t[a + 1] + 90) / 360));
    o > Ho ? o = Ho : o < -Ho && (o = -Ho), e[a + 1] = o;
  }
  return e;
}
function A_(t, e, n) {
  const i = t.length;
  n = n > 1 ? n : 2, e === void 0 && (n > 2 ? e = t.slice() : e = new Array(i));
  for (let a = 0; a < i; a += n)
    e[a] = 180 * t[a] / ua, e[a + 1] = 360 * Math.atan(Math.exp(t[a + 1] / Bo)) / Math.PI - 90;
  return e;
}
const R_ = 6378137, Kc = [-180, -90, 180, 90], I_ = Math.PI * R_ / 180;
class zi extends tg {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(e, n) {
    super({
      code: e,
      units: "degrees",
      extent: Kc,
      axisOrientation: n,
      global: !0,
      metersPerUnit: I_,
      worldExtent: Kc
    });
  }
}
const qc = [
  new zi("CRS:84"),
  new zi("EPSG:4326", "neu"),
  new zi("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new zi("urn:ogc:def:crs:OGC:2:84"),
  new zi("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new zi("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new zi("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let ns = {};
function z_(t) {
  return ns[t] || ns[t.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function L_(t, e) {
  ns[t] = e;
}
let ma = {};
function yr(t, e, n) {
  const i = t.getCode(), a = e.getCode();
  i in ma || (ma[i] = {}), ma[i][a] = n;
}
function V_(t, e) {
  let n;
  return t in ma && e in ma[t] && (n = ma[t][e]), n;
}
const ot = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function Jc(t) {
  const e = an();
  for (let n = 0, i = t.length; n < i; ++n)
    Za(e, t[n]);
  return e;
}
function du(t, e, n) {
  return n ? (n[0] = t[0] - e, n[1] = t[1] - e, n[2] = t[2] + e, n[3] = t[3] + e, n) : [
    t[0] - e,
    t[1] - e,
    t[2] + e,
    t[3] + e
  ];
}
function ng(t, e) {
  return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t.slice();
}
function ig(t, e, n) {
  let i, a;
  return e < t[0] ? i = t[0] - e : t[2] < e ? i = e - t[2] : i = 0, n < t[1] ? a = t[1] - n : t[3] < n ? a = n - t[3] : a = 0, i * i + a * a;
}
function Ma(t, e) {
  return ag(t, e[0], e[1]);
}
function Bi(t, e) {
  return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3];
}
function ag(t, e, n) {
  return t[0] <= e && e <= t[2] && t[1] <= n && n <= t[3];
}
function is(t, e) {
  const n = t[0], i = t[1], a = t[2], o = t[3], r = e[0], l = e[1];
  let s = ot.UNKNOWN;
  return r < n ? s = s | ot.LEFT : r > a && (s = s | ot.RIGHT), l < i ? s = s | ot.BELOW : l > o && (s = s | ot.ABOVE), s === ot.UNKNOWN && (s = ot.INTERSECTING), s;
}
function an() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function Mi(t, e, n, i, a) {
  return a ? (a[0] = t, a[1] = e, a[2] = n, a[3] = i, a) : [t, e, n, i];
}
function $r(t) {
  return Mi(1 / 0, 1 / 0, -1 / 0, -1 / 0, t);
}
function og(t, e) {
  const n = t[0], i = t[1];
  return Mi(n, i, n, i, e);
}
function hu(t, e, n, i, a) {
  const o = $r(a);
  return rg(o, t, e, n, i);
}
function ro(t, e) {
  return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3];
}
function B_(t, e) {
  return e[0] < t[0] && (t[0] = e[0]), e[2] > t[2] && (t[2] = e[2]), e[1] < t[1] && (t[1] = e[1]), e[3] > t[3] && (t[3] = e[3]), t;
}
function Za(t, e) {
  e[0] < t[0] && (t[0] = e[0]), e[0] > t[2] && (t[2] = e[0]), e[1] < t[1] && (t[1] = e[1]), e[1] > t[3] && (t[3] = e[1]);
}
function rg(t, e, n, i, a) {
  for (; n < i; n += a)
    F_(t, e[n], e[n + 1]);
  return t;
}
function F_(t, e, n) {
  t[0] = Math.min(t[0], e), t[1] = Math.min(t[1], n), t[2] = Math.max(t[2], e), t[3] = Math.max(t[3], n);
}
function lg(t, e) {
  let n;
  return n = e(Xr(t)), n || (n = e(Ur(t)), n) || (n = e(Yr(t)), n) || (n = e(Ui(t)), n) ? n : !1;
}
function as(t) {
  let e = 0;
  return jr(t) || (e = ke(t) * Mt(t)), e;
}
function Xr(t) {
  return [t[0], t[1]];
}
function Ur(t) {
  return [t[2], t[1]];
}
function $i(t) {
  return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2];
}
function k_(t, e) {
  let n;
  if (e === "bottom-left")
    n = Xr(t);
  else if (e === "bottom-right")
    n = Ur(t);
  else if (e === "top-left")
    n = Ui(t);
  else if (e === "top-right")
    n = Yr(t);
  else
    throw new Error("Invalid corner");
  return n;
}
function os(t, e, n, i, a) {
  const [o, r, l, s, u, c, d, h] = rs(
    t,
    e,
    n,
    i
  );
  return Mi(
    Math.min(o, l, u, d),
    Math.min(r, s, c, h),
    Math.max(o, l, u, d),
    Math.max(r, s, c, h),
    a
  );
}
function rs(t, e, n, i) {
  const a = e * i[0] / 2, o = e * i[1] / 2, r = Math.cos(n), l = Math.sin(n), s = a * r, u = a * l, c = o * r, d = o * l, h = t[0], f = t[1];
  return [
    h - s + d,
    f - u - c,
    h - s - d,
    f - u + c,
    h + s - d,
    f + u + c,
    h + s + d,
    f + u - c,
    h - s + d,
    f - u - c
  ];
}
function Mt(t) {
  return t[3] - t[1];
}
function Ka(t, e, n) {
  const i = n || an();
  return zt(t, e) ? (t[0] > e[0] ? i[0] = t[0] : i[0] = e[0], t[1] > e[1] ? i[1] = t[1] : i[1] = e[1], t[2] < e[2] ? i[2] = t[2] : i[2] = e[2], t[3] < e[3] ? i[3] = t[3] : i[3] = e[3]) : $r(i), i;
}
function Ui(t) {
  return [t[0], t[3]];
}
function Yr(t) {
  return [t[2], t[3]];
}
function ke(t) {
  return t[2] - t[0];
}
function zt(t, e) {
  return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1];
}
function jr(t) {
  return t[2] < t[0] || t[3] < t[1];
}
function O_(t, e) {
  return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t;
}
function D_(t, e, n) {
  let i = !1;
  const a = is(t, e), o = is(t, n);
  if (a === ot.INTERSECTING || o === ot.INTERSECTING)
    i = !0;
  else {
    const r = t[0], l = t[1], s = t[2], u = t[3], c = e[0], d = e[1], h = n[0], f = n[1], g = (f - d) / (h - c);
    let m, v;
    o & ot.ABOVE && !(a & ot.ABOVE) && (m = h - (f - u) / g, i = m >= r && m <= s), !i && o & ot.RIGHT && !(a & ot.RIGHT) && (v = f - (h - s) * g, i = v >= l && v <= u), !i && o & ot.BELOW && !(a & ot.BELOW) && (m = h - (f - l) / g, i = m >= r && m <= s), !i && o & ot.LEFT && !(a & ot.LEFT) && (v = f - (h - r) * g, i = v >= l && v <= u);
  }
  return i;
}
function sg(t, e) {
  const n = e.getExtent(), i = $i(t);
  if (e.canWrapX() && (i[0] < n[0] || i[0] >= n[2])) {
    const a = ke(n), r = Math.floor(
      (i[0] - n[0]) / a
    ) * a;
    t[0] -= r, t[2] -= r;
  }
  return t;
}
function ug(t, e, n) {
  if (e.canWrapX()) {
    const i = e.getExtent();
    if (!isFinite(t[0]) || !isFinite(t[2]))
      return [[i[0], t[1], i[2], t[3]]];
    sg(t, e);
    const a = ke(i);
    if (ke(t) > a && !n)
      return [[i[0], t[1], i[2], t[3]]];
    if (t[0] < i[0])
      return [
        [t[0] + a, t[1], i[2], t[3]],
        [i[0], t[1], t[2], t[3]]
      ];
    if (t[2] > i[2])
      return [
        [t[0], t[1], i[2], t[3]],
        [i[0], t[1], t[2] - a, t[3]]
      ];
  }
  return [t];
}
function G_(t, e) {
  return t[0] += +e[0], t[1] += +e[1], t;
}
function Cr(t, e) {
  let n = !0;
  for (let i = t.length - 1; i >= 0; --i)
    if (t[i] != e[i]) {
      n = !1;
      break;
    }
  return n;
}
function fu(t, e) {
  const n = Math.cos(e), i = Math.sin(e), a = t[0] * n - t[1] * i, o = t[1] * n + t[0] * i;
  return t[0] = a, t[1] = o, t;
}
function N_(t, e) {
  return t[0] *= e, t[1] *= e, t;
}
function cg(t, e) {
  if (e.canWrapX()) {
    const n = ke(e.getExtent()), i = W_(t, e, n);
    i && (t[0] -= i * n);
  }
  return t;
}
function W_(t, e, n) {
  const i = e.getExtent();
  let a = 0;
  return e.canWrapX() && (t[0] < i[0] || t[0] > i[2]) && (n = n || ke(i), a = Math.floor(
    (t[0] - i[0]) / n
  )), a;
}
const $_ = 63710088e-1;
function Qc(t, e, n) {
  n = n || $_;
  const i = ar(t[1]), a = ar(e[1]), o = (a - i) / 2, r = ar(e[0] - t[0]) / 2, l = Math.sin(o) * Math.sin(o) + Math.sin(r) * Math.sin(r) * Math.cos(i) * Math.cos(a);
  return 2 * n * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l));
}
function dg(...t) {
  console.warn(...t);
}
let ls = !0;
function hg(t) {
  ls = !1;
}
function gu(t, e) {
  if (e !== void 0) {
    for (let n = 0, i = t.length; n < i; ++n)
      e[n] = t[n];
    e = e;
  } else
    e = t.slice();
  return e;
}
function fg(t, e) {
  if (e !== void 0 && t !== e) {
    for (let n = 0, i = t.length; n < i; ++n)
      e[n] = t[n];
    t = e;
  }
  return t;
}
function X_(t) {
  L_(t.getCode(), t), yr(t, t, gu);
}
function U_(t) {
  t.forEach(X_);
}
function on(t) {
  return typeof t == "string" ? z_(
    /** @type {string} */
    t
  ) : (
    /** @type {Projection} */
    t || null
  );
}
function ed(t, e, n, i) {
  t = on(t);
  let a;
  const o = t.getPointResolutionFunc();
  if (o)
    a = o(e, n);
  else {
    const r = t.getUnits();
    if (r == "degrees" && !i || i == "degrees")
      a = e;
    else {
      const l = vu(
        t,
        on("EPSG:4326")
      );
      if (l === fg && r !== "degrees")
        a = e * t.getMetersPerUnit();
      else {
        let u = [
          n[0] - e / 2,
          n[1],
          n[0] + e / 2,
          n[1],
          n[0],
          n[1] - e / 2,
          n[0],
          n[1] + e / 2
        ];
        u = l(u, u, 2);
        const c = Qc(u.slice(0, 2), u.slice(2, 4)), d = Qc(u.slice(4, 6), u.slice(6, 8));
        a = (c + d) / 2;
      }
      const s = t.getMetersPerUnit();
      s !== void 0 && (a /= s);
    }
  }
  return a;
}
function td(t) {
  U_(t), t.forEach(function(e) {
    t.forEach(function(n) {
      e !== n && yr(e, n, gu);
    });
  });
}
function Y_(t, e, n, i) {
  t.forEach(function(a) {
    e.forEach(function(o) {
      yr(a, o, n), yr(o, a, i);
    });
  });
}
function mu(t, e) {
  return t ? typeof t == "string" ? on(t) : (
    /** @type {Projection} */
    t
  ) : on(e);
}
function nd(t, e) {
  return hg(), gg(
    t,
    "EPSG:4326",
    "EPSG:3857"
  );
}
function na(t, e) {
  if (t === e)
    return !0;
  const n = t.getUnits() === e.getUnits();
  return (t.getCode() === e.getCode() || vu(t, e) === gu) && n;
}
function vu(t, e) {
  const n = t.getCode(), i = e.getCode();
  let a = V_(n, i);
  return a || (a = fg), a;
}
function pr(t, e) {
  const n = on(t), i = on(e);
  return vu(n, i);
}
function gg(t, e, n) {
  return pr(e, n)(t, void 0, t.length);
}
function ss(t, e) {
  return t;
}
function jn(t, e) {
  return ls && !Cr(t, [0, 0]) && t[0] >= -180 && t[0] <= 180 && t[1] >= -90 && t[1] <= 90 && (ls = !1, dg(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), t;
}
function mg(t, e) {
  return t;
}
function Fi(t, e) {
  return t;
}
function j_() {
  td(Zc), td(qc), Y_(
    qc,
    Zc,
    E_,
    A_
  );
}
j_();
function id(t, e, n) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(i, a, o, r, l) {
      if (!i)
        return;
      if (!a && !e)
        return i;
      const s = e ? 0 : o[0] * a, u = e ? 0 : o[1] * a, c = l ? l[0] : 0, d = l ? l[1] : 0;
      let h = t[0] + s / 2 + c, f = t[2] - s / 2 + c, g = t[1] + u / 2 + d, m = t[3] - u / 2 + d;
      h > f && (h = (f + h) / 2, f = h), g > m && (g = (m + g) / 2, m = g);
      let v = tt(i[0], h, f), y = tt(i[1], g, m);
      if (r && n && a) {
        const C = 30 * a;
        v += -C * Math.log(1 + Math.max(0, h - i[0]) / C) + C * Math.log(1 + Math.max(0, i[0] - f) / C), y += -C * Math.log(1 + Math.max(0, g - i[1]) / C) + C * Math.log(1 + Math.max(0, i[1] - m) / C);
      }
      return [v, y];
    }
  );
}
function H_(t) {
  return t;
}
function yu(t, e, n, i) {
  const a = ke(e) / n[0], o = Mt(e) / n[1];
  return i ? Math.min(t, Math.max(a, o)) : Math.min(t, Math.min(a, o));
}
function Cu(t, e, n) {
  let i = Math.min(t, e);
  const a = 50;
  return i *= Math.log(1 + a * Math.max(0, t / e - 1)) / a + 1, n && (i = Math.max(i, n), i /= Math.log(1 + a * Math.max(0, n / t - 1)) / a + 1), tt(i, n / 2, e * 2);
}
function Z_(t, e, n, i) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(a, o, r, l) {
    if (a !== void 0) {
      const s = t[0], u = t[t.length - 1], c = n ? yu(
        s,
        n,
        r,
        i
      ) : s;
      if (l)
        return e ? Cu(
          a,
          c,
          u
        ) : tt(a, u, c);
      const d = Math.min(c, a), h = Math.floor(ru(t, d, o));
      return t[h] > c && h < t.length - 1 ? t[h + 1] : t[h];
    }
  };
}
function K_(t, e, n, i, a, o) {
  return i = i !== void 0 ? i : !0, n = n !== void 0 ? n : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(r, l, s, u) {
    if (r !== void 0) {
      const c = a ? yu(
        e,
        a,
        s,
        o
      ) : e;
      if (u)
        return i ? Cu(
          r,
          c,
          n
        ) : tt(r, n, c);
      const d = 1e-9, h = Math.ceil(
        Math.log(e / c) / Math.log(t) - d
      ), f = -l * (0.5 - d) + 0.5, g = Math.min(c, r), m = Math.floor(
        Math.log(e / g) / Math.log(t) + f
      ), v = Math.max(h, m), y = e / Math.pow(t, v);
      return tt(y, n, c);
    }
  };
}
function ad(t, e, n, i, a) {
  return n = n !== void 0 ? n : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(o, r, l, s) {
    if (o !== void 0) {
      const u = i ? yu(
        t,
        i,
        l,
        a
      ) : t;
      return !n || !s ? tt(o, e, u) : Cu(
        o,
        u,
        e
      );
    }
  };
}
function pu(t) {
  if (t !== void 0)
    return 0;
}
function od(t) {
  if (t !== void 0)
    return t;
}
function q_(t) {
  const e = 2 * Math.PI / t;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(n, i) {
      if (i)
        return n;
      if (n !== void 0)
        return n = Math.floor(n / e + 0.5) * e, n;
    }
  );
}
function J_(t) {
  const e = ar(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(n, i) {
      return i || n === void 0 ? n : Math.abs(n) <= e ? 0 : n;
    }
  );
}
function vg(t) {
  return Math.pow(t, 3);
}
function za(t) {
  return 1 - vg(1 - t);
}
function Q_(t) {
  return 3 * t * t - 2 * t * t * t;
}
function eS(t) {
  return t;
}
new Array(6);
function hn() {
  return [1, 0, 0, 1, 0, 0];
}
function tS(t, e) {
  return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;
}
function ut(t, e) {
  const n = e[0], i = e[1];
  return e[0] = t[0] * n + t[2] * i + t[4], e[1] = t[1] * n + t[3] * i + t[5], e;
}
function ii(t, e, n, i, a, o, r, l) {
  const s = Math.sin(o), u = Math.cos(o);
  return t[0] = i * u, t[1] = a * s, t[2] = -i * s, t[3] = a * u, t[4] = r * i * u - l * i * s + e, t[5] = r * a * s + l * a * u + n, t;
}
function yg(t, e) {
  const n = nS(e);
  Ee(n !== 0, "Transformation matrix cannot be inverted");
  const i = e[0], a = e[1], o = e[2], r = e[3], l = e[4], s = e[5];
  return t[0] = r / n, t[1] = -a / n, t[2] = -o / n, t[3] = i / n, t[4] = (o * s - r * l) / n, t[5] = -(i * s - a * l) / n, t;
}
function nS(t) {
  return t[0] * t[3] - t[1] * t[2];
}
const rd = [1e6, 1e6, 1e6, 1e6, 2, 2];
function iS(t) {
  return "matrix(" + t.map(
    (n, i) => Math.round(n * rd[i]) / rd[i]
  ).join(", ") + ")";
}
function pi(t, e, n, i, a, o) {
  o = o || [];
  let r = 0;
  for (let l = e; l < n; l += i) {
    const s = t[l], u = t[l + 1];
    o[r++] = a[0] * s + a[2] * u + a[4], o[r++] = a[1] * s + a[3] * u + a[5];
  }
  return o && o.length != r && (o.length = r), o;
}
function Cg(t, e, n, i, a, o, r) {
  r = r || [];
  const l = Math.cos(a), s = Math.sin(a), u = o[0], c = o[1];
  let d = 0;
  for (let h = e; h < n; h += i) {
    const f = t[h] - u, g = t[h + 1] - c;
    r[d++] = u + f * l - g * s, r[d++] = c + f * s + g * l;
    for (let m = h + 2; m < h + i; ++m)
      r[d++] = t[m];
  }
  return r && r.length != d && (r.length = d), r;
}
function aS(t, e, n, i, a, o, r, l) {
  l = l || [];
  const s = r[0], u = r[1];
  let c = 0;
  for (let d = e; d < n; d += i) {
    const h = t[d] - s, f = t[d + 1] - u;
    l[c++] = s + a * h, l[c++] = u + o * f;
    for (let g = d + 2; g < d + i; ++g)
      l[c++] = t[g];
  }
  return l && l.length != c && (l.length = c), l;
}
function oS(t, e, n, i, a, o, r) {
  r = r || [];
  let l = 0;
  for (let s = e; s < n; s += i) {
    r[l++] = t[s] + a, r[l++] = t[s + 1] + o;
    for (let u = s + 2; u < s + i; ++u)
      r[l++] = t[u];
  }
  return r && r.length != l && (r.length = l), r;
}
const ld = hn();
class rS extends _n {
  constructor() {
    super(), this.extent_ = an(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = Qf(
      (e, n, i) => {
        if (!i)
          return this.getSimplifiedGeometry(n);
        const a = this.clone();
        return a.applyTransform(i), a.getSimplifiedGeometry(n);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(e, n) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      e,
      n
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return Re();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, n, i, a) {
    return Re();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, n) {
    const i = this.getClosestPoint([e, n]);
    return i[0] === e && i[1] === n;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(e, n) {
    return n = n || [NaN, NaN], this.closestPointXY(e[0], e[1], n, 1 / 0), n;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(e) {
    return this.containsXY(e[0], e[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Re();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(e) {
    if (this.extentRevision_ != this.getRevision()) {
      const n = this.computeExtent(this.extent_);
      (isNaN(n[0]) || isNaN(n[1])) && $r(n), this.extentRevision_ = this.getRevision();
    }
    return O_(this.extent_, e);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, n) {
    Re();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, n, i) {
    Re();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(e) {
    return this.getSimplifiedGeometry(e * e);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return Re();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return Re();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(e) {
    Re();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(e) {
    return Re();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, n) {
    Re();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(e, n) {
    const i = on(e), a = i.getUnits() == "tile-pixels" ? function(o, r, l) {
      const s = i.getExtent(), u = i.getWorldExtent(), c = Mt(u) / Mt(s);
      return ii(
        ld,
        u[0],
        u[3],
        c,
        -c,
        0,
        0,
        0
      ), pi(
        o,
        0,
        o.length,
        l,
        ld,
        r
      ), pr(i, n)(
        o,
        r,
        l
      );
    } : pr(i, n);
    return this.applyTransform(a), this;
  }
}
class _u extends rS {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return hu(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return Re();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const n = this.getSimplifiedGeometryInternal(e);
    return n.getFlatCoordinates().length < this.flatCoordinates.length ? n : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(e, n) {
    this.stride = sd(e), this.layout = e, this.flatCoordinates = n;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(e, n) {
    Re();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(e, n, i) {
    let a;
    if (e)
      a = sd(e);
    else {
      for (let o = 0; o < i; ++o) {
        if (n.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        n = /** @type {Array<unknown>} */
        n[0];
      }
      a = n.length, e = lS(a);
    }
    this.layout = e, this.stride = a;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    this.flatCoordinates && (e(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, n) {
    const i = this.getFlatCoordinates();
    if (i) {
      const a = this.getStride();
      Cg(
        i,
        0,
        i.length,
        a,
        e,
        n,
        i
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, n, i) {
    n === void 0 && (n = e), i || (i = $i(this.getExtent()));
    const a = this.getFlatCoordinates();
    if (a) {
      const o = this.getStride();
      aS(
        a,
        0,
        a.length,
        o,
        e,
        n,
        i,
        a
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, n) {
    const i = this.getFlatCoordinates();
    if (i) {
      const a = this.getStride();
      oS(
        i,
        0,
        i.length,
        a,
        e,
        n,
        i
      ), this.changed();
    }
  }
}
function lS(t) {
  let e;
  return t == 2 ? e = "XY" : t == 3 ? e = "XYZ" : t == 4 && (e = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  e;
}
function sd(t) {
  let e;
  return t == "XY" ? e = 2 : t == "XYZ" || t == "XYM" ? e = 3 : t == "XYZM" && (e = 4), /** @type {number} */
  e;
}
function sS(t, e, n) {
  const i = t.getFlatCoordinates();
  if (!i)
    return null;
  const a = t.getStride();
  return pi(
    i,
    0,
    i.length,
    a,
    e,
    n
  );
}
function ud(t, e, n, i, a, o, r) {
  const l = t[e], s = t[e + 1], u = t[n] - l, c = t[n + 1] - s;
  let d;
  if (u === 0 && c === 0)
    d = e;
  else {
    const h = ((a - l) * u + (o - s) * c) / (u * u + c * c);
    if (h > 1)
      d = n;
    else if (h > 0) {
      for (let f = 0; f < i; ++f)
        r[f] = qt(
          t[e + f],
          t[n + f],
          h
        );
      r.length = i;
      return;
    } else
      d = e;
  }
  for (let h = 0; h < i; ++h)
    r[h] = t[d + h];
  r.length = i;
}
function pg(t, e, n, i, a) {
  let o = t[e], r = t[e + 1];
  for (e += i; e < n; e += i) {
    const l = t[e], s = t[e + 1], u = fa(o, r, l, s);
    u > a && (a = u), o = l, r = s;
  }
  return a;
}
function uS(t, e, n, i, a) {
  for (let o = 0, r = n.length; o < r; ++o) {
    const l = n[o];
    a = pg(t, e, l, i, a), e = l;
  }
  return a;
}
function _g(t, e, n, i, a, o, r, l, s, u, c) {
  if (e == n)
    return u;
  let d, h;
  if (a === 0) {
    if (h = fa(
      r,
      l,
      t[e],
      t[e + 1]
    ), h < u) {
      for (d = 0; d < i; ++d)
        s[d] = t[e + d];
      return s.length = i, h;
    }
    return u;
  }
  c = c || [NaN, NaN];
  let f = e + i;
  for (; f < n; )
    if (ud(
      t,
      f - i,
      f,
      i,
      r,
      l,
      c
    ), h = fa(r, l, c[0], c[1]), h < u) {
      for (u = h, d = 0; d < i; ++d)
        s[d] = c[d];
      s.length = i, f += i;
    } else
      f += i * Math.max(
        (Math.sqrt(h) - Math.sqrt(u)) / a | 0,
        1
      );
  if (ud(
    t,
    n - i,
    e,
    i,
    r,
    l,
    c
  ), h = fa(r, l, c[0], c[1]), h < u) {
    for (u = h, d = 0; d < i; ++d)
      s[d] = c[d];
    s.length = i;
  }
  return u;
}
function cS(t, e, n, i, a, o, r, l, s, u, c) {
  c = c || [NaN, NaN];
  for (let d = 0, h = n.length; d < h; ++d) {
    const f = n[d];
    u = _g(
      t,
      e,
      f,
      i,
      a,
      o,
      r,
      l,
      s,
      u,
      c
    ), e = f;
  }
  return u;
}
function dS(t, e, n, i) {
  for (let a = 0, o = n.length; a < o; ++a)
    t[e++] = n[a];
  return e;
}
function Sg(t, e, n, i) {
  for (let a = 0, o = n.length; a < o; ++a) {
    const r = n[a];
    for (let l = 0; l < i; ++l)
      t[e++] = r[l];
  }
  return e;
}
function hS(t, e, n, i, a) {
  a = a || [];
  let o = 0;
  for (let r = 0, l = n.length; r < l; ++r) {
    const s = Sg(
      t,
      e,
      n[r],
      i
    );
    a[o++] = s, e = s;
  }
  return a.length = o, a;
}
function Su(t, e, n, i, a, o, r) {
  const l = (n - e) / i;
  if (l < 3) {
    for (; e < n; e += i)
      o[r++] = t[e], o[r++] = t[e + 1];
    return r;
  }
  const s = new Array(l);
  s[0] = 1, s[l - 1] = 1;
  const u = [e, n - i];
  let c = 0;
  for (; u.length > 0; ) {
    const d = u.pop(), h = u.pop();
    let f = 0;
    const g = t[h], m = t[h + 1], v = t[d], y = t[d + 1];
    for (let C = h + i; C < d; C += i) {
      const M = t[C], p = t[C + 1], b = M_(M, p, g, m, v, y);
      b > f && (c = C, f = b);
    }
    f > a && (s[(c - e) / i] = 1, h + i < c && u.push(h, c), c + i < d && u.push(c, d));
  }
  for (let d = 0; d < l; ++d)
    s[d] && (o[r++] = t[e + d * i], o[r++] = t[e + d * i + 1]);
  return r;
}
function fS(t, e, n, i, a, o, r, l) {
  for (let s = 0, u = n.length; s < u; ++s) {
    const c = n[s];
    r = Su(
      t,
      e,
      c,
      i,
      a,
      o,
      r
    ), l.push(r), e = c;
  }
  return r;
}
function Vi(t, e) {
  return e * Math.round(t / e);
}
function gS(t, e, n, i, a, o, r) {
  if (e == n)
    return r;
  let l = Vi(t[e], a), s = Vi(t[e + 1], a);
  e += i, o[r++] = l, o[r++] = s;
  let u, c;
  do
    if (u = Vi(t[e], a), c = Vi(t[e + 1], a), e += i, e == n)
      return o[r++] = u, o[r++] = c, r;
  while (u == l && c == s);
  for (; e < n; ) {
    const d = Vi(t[e], a), h = Vi(t[e + 1], a);
    if (e += i, d == u && h == c)
      continue;
    const f = u - l, g = c - s, m = d - l, v = h - s;
    if (f * v == g * m && (f < 0 && m < f || f == m || f > 0 && m > f) && (g < 0 && v < g || g == v || g > 0 && v > g)) {
      u = d, c = h;
      continue;
    }
    o[r++] = u, o[r++] = c, l = u, s = c, u = d, c = h;
  }
  return o[r++] = u, o[r++] = c, r;
}
function bg(t, e, n, i, a, o, r, l) {
  for (let s = 0, u = n.length; s < u; ++s) {
    const c = n[s];
    r = gS(
      t,
      e,
      c,
      i,
      a,
      o,
      r
    ), l.push(r), e = c;
  }
  return r;
}
function ca(t, e, n, i, a) {
  a = a !== void 0 ? a : [];
  let o = 0;
  for (let r = e; r < n; r += i)
    a[o++] = t.slice(r, r + i);
  return a.length = o, a;
}
function _r(t, e, n, i, a) {
  a = a !== void 0 ? a : [];
  let o = 0;
  for (let r = 0, l = n.length; r < l; ++r) {
    const s = n[r];
    a[o++] = ca(
      t,
      e,
      s,
      i,
      a[o]
    ), e = s;
  }
  return a.length = o, a;
}
function cd(t, e, n, i, a) {
  a = a !== void 0 ? a : [];
  let o = 0;
  for (let r = 0, l = n.length; r < l; ++r) {
    const s = n[r];
    a[o++] = s.length === 1 && s[0] === e ? [] : _r(
      t,
      e,
      s,
      i,
      a[o]
    ), e = s[s.length - 1];
  }
  return a.length = o, a;
}
function Mg(t, e, n, i) {
  let a = 0, o = t[n - i], r = t[n - i + 1];
  for (; e < n; e += i) {
    const l = t[e], s = t[e + 1];
    a += r * l - o * s, o = l, r = s;
  }
  return a / 2;
}
function mS(t, e, n, i) {
  let a = 0;
  for (let o = 0, r = n.length; o < r; ++o) {
    const l = n[o];
    a += Mg(t, e, l, i), e = l;
  }
  return a;
}
class lo extends _u {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, n) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, n !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      n
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new lo(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, n, i, a) {
    return a < ig(this.getExtent(), e, n) ? a : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      pg(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), _g(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      n,
      i,
      a
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return Mg(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return ca(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const n = [];
    return n.length = Su(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      n,
      0
    ), new lo(n, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, n) {
    this.setLayout(n, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Sg(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
class Hr extends _u {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, n) {
    super(), this.setCoordinates(e, n);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const e = new Hr(this.flatCoordinates.slice(), this.layout);
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, n, i, a) {
    const o = this.flatCoordinates, r = fa(
      e,
      n,
      o[0],
      o[1]
    );
    if (r < a) {
      const l = this.stride;
      for (let s = 0; s < l; ++s)
        i[s] = o[s];
      return i.length = l, r;
    }
    return a;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return og(this.flatCoordinates, e);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return ag(e, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, n) {
    this.setLayout(n, e, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = dS(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
function vS(t, e, n, i, a) {
  return !lg(
    a,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(r) {
      return !ki(
        t,
        e,
        n,
        i,
        r[0],
        r[1]
      );
    }
  );
}
function ki(t, e, n, i, a, o) {
  let r = 0, l = t[n - i], s = t[n - i + 1];
  for (; e < n; e += i) {
    const u = t[e], c = t[e + 1];
    s <= o ? c > o && (u - l) * (o - s) - (a - l) * (c - s) > 0 && r++ : c <= o && (u - l) * (o - s) - (a - l) * (c - s) < 0 && r--, l = u, s = c;
  }
  return r !== 0;
}
function xg(t, e, n, i, a, o) {
  if (n.length === 0 || !ki(t, e, n[0], i, a, o))
    return !1;
  for (let r = 1, l = n.length; r < l; ++r)
    if (ki(t, n[r - 1], n[r], i, a, o))
      return !1;
  return !0;
}
function bu(t, e, n, i, a, o, r) {
  let l, s, u, c, d, h, f;
  const g = a[o + 1], m = [];
  for (let C = 0, M = n.length; C < M; ++C) {
    const p = n[C];
    for (c = t[p - i], h = t[p - i + 1], l = e; l < p; l += i)
      d = t[l], f = t[l + 1], (g <= h && f <= g || h <= g && g <= f) && (u = (g - h) / (f - h) * (d - c) + c, m.push(u)), c = d, h = f;
  }
  let v = NaN, y = -1 / 0;
  for (m.sort(ei), c = m[0], l = 1, s = m.length; l < s; ++l) {
    d = m[l];
    const C = Math.abs(d - c);
    C > y && (u = (c + d) / 2, xg(t, e, n, i, u, g) && (v = u, y = C)), c = d;
  }
  return isNaN(v) && (v = a[o]), r ? (r.push(v, g, y), r) : [v, g, y];
}
function yS(t, e, n, i, a) {
  let o = [];
  for (let r = 0, l = n.length; r < l; ++r) {
    const s = n[r];
    o = bu(
      t,
      e,
      s,
      i,
      a,
      2 * r,
      o
    ), e = s[s.length - 1];
  }
  return o;
}
function CS(t, e, n, i, a) {
  let o;
  for (e += i; e < n; e += i)
    if (o = a(
      t.slice(e - i, e),
      t.slice(e, e + i)
    ), o)
      return o;
  return !1;
}
function Pg(t, e, n, i, a) {
  const o = rg(
    an(),
    t,
    e,
    n,
    i
  );
  return zt(a, o) ? Bi(a, o) || o[0] >= a[0] && o[2] <= a[2] || o[1] >= a[1] && o[3] <= a[3] ? !0 : CS(
    t,
    e,
    n,
    i,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(r, l) {
      return D_(a, r, l);
    }
  ) : !1;
}
function Tg(t, e, n, i, a) {
  return !!(Pg(t, e, n, i, a) || ki(
    t,
    e,
    n,
    i,
    a[0],
    a[1]
  ) || ki(
    t,
    e,
    n,
    i,
    a[0],
    a[3]
  ) || ki(
    t,
    e,
    n,
    i,
    a[2],
    a[1]
  ) || ki(
    t,
    e,
    n,
    i,
    a[2],
    a[3]
  ));
}
function pS(t, e, n, i, a) {
  if (!Tg(t, e, n[0], i, a))
    return !1;
  if (n.length === 1)
    return !0;
  for (let o = 1, r = n.length; o < r; ++o)
    if (vS(
      t,
      n[o - 1],
      n[o],
      i,
      a
    ) && !Pg(
      t,
      n[o - 1],
      n[o],
      i,
      a
    ))
      return !1;
  return !0;
}
function _S(t, e, n, i) {
  for (; e < n - i; ) {
    for (let a = 0; a < i; ++a) {
      const o = t[e + a];
      t[e + a] = t[n - i + a], t[n - i + a] = o;
    }
    e += i, n -= i;
  }
}
function Mu(t, e, n, i) {
  let a = 0, o = t[n - i], r = t[n - i + 1];
  for (; e < n; e += i) {
    const l = t[e], s = t[e + 1];
    a += (l - o) * (s + r), o = l, r = s;
  }
  return a === 0 ? void 0 : a > 0;
}
function SS(t, e, n, i, a) {
  a = a !== void 0 ? a : !1;
  for (let o = 0, r = n.length; o < r; ++o) {
    const l = n[o], s = Mu(
      t,
      e,
      l,
      i
    );
    if (o === 0) {
      if (a && s || !a && !s)
        return !1;
    } else if (a && !s || !a && s)
      return !1;
    e = l;
  }
  return !0;
}
function dd(t, e, n, i, a) {
  a = a !== void 0 ? a : !1;
  for (let o = 0, r = n.length; o < r; ++o) {
    const l = n[o], s = Mu(
      t,
      e,
      l,
      i
    );
    (o === 0 ? a && s || !a && !s : a && !s || !a && s) && _S(t, e, l, i), e = l;
  }
  return e;
}
function bS(t, e) {
  const n = [];
  let i = 0, a = 0, o;
  for (let r = 0, l = e.length; r < l; ++r) {
    const s = e[r], u = Mu(t, i, s, 2);
    if (o === void 0 && (o = u), u === o)
      n.push(e.slice(a, r + 1));
    else {
      if (n.length === 0)
        continue;
      n[n.length - 1].push(e[a]);
    }
    a = r + 1, i = s;
  }
  return n;
}
class so extends _u {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(e, n, i) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, n !== void 0 && i ? (this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      e
    ), this.ends_ = i) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      e,
      n
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(e) {
    this.flatCoordinates ? lu(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const e = new so(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, n, i, a) {
    return a < ig(this.getExtent(), e, n) ? a : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      uS(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), cS(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      n,
      i,
      a
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, n) {
    return xg(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e,
      n
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return mS(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let n;
    return e !== void 0 ? (n = this.getOrientedFlatCoordinates().slice(), dd(n, 0, this.ends_, this.stride, e)) : n = this.flatCoordinates, _r(n, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const e = $i(this.getExtent());
      this.flatInteriorPoint_ = bu(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        e,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new Hr(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(e) {
    return e < 0 || this.ends_.length <= e ? null : new lo(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const e = this.layout, n = this.flatCoordinates, i = this.ends_, a = [];
    let o = 0;
    for (let r = 0, l = i.length; r < l; ++r) {
      const s = i[r], u = new lo(
        n.slice(o, s),
        e
      );
      a.push(u), o = s;
    }
    return a;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      SS(e, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = dd(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const n = [], i = [];
    return n.length = bg(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(e),
      n,
      0,
      i
    ), new so(n, "XY", i);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return pS(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, n) {
    this.setLayout(n, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const i = hS(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
  }
}
function hd(t) {
  if (jr(t))
    throw new Error("Cannot create polygon from empty extent");
  const e = t[0], n = t[1], i = t[2], a = t[3], o = [
    e,
    n,
    e,
    a,
    i,
    a,
    i,
    n,
    e,
    n
  ];
  return new so(o, "XY", [o.length]);
}
const xl = 0;
class Pn extends _n {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = Object.assign({}, e), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = mu(e.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, e.projection && hg(), e.center && (e.center = jn(e.center, this.projection_)), e.extent && (e.extent = Fi(e.extent, this.projection_)), this.applyOptions_(e);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(e) {
    const n = Object.assign({}, e);
    for (const l in un)
      delete n[l];
    this.setProperties(n, !0);
    const i = xS(e);
    this.maxResolution_ = i.maxResolution, this.minResolution_ = i.minResolution, this.zoomFactor_ = i.zoomFactor, this.resolutions_ = e.resolutions, this.padding_ = e.padding, this.minZoom_ = i.minZoom;
    const a = MS(e), o = i.constraint, r = PS(e);
    this.constraints_ = {
      center: a,
      resolution: o,
      rotation: r
    }, this.setRotation(e.rotation !== void 0 ? e.rotation : 0), this.setCenterInternal(
      e.center !== void 0 ? e.center : null
    ), e.resolution !== void 0 ? this.setResolution(e.resolution) : e.zoom !== void 0 && this.setZoom(e.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(e) {
    let n = this.padding_;
    this.padding_ = e;
    const i = this.getCenterInternal();
    if (i) {
      const a = e || [0, 0, 0, 0];
      n = n || [0, 0, 0, 0];
      const o = this.getResolution(), r = o / 2 * (a[3] - n[3] + n[1] - a[1]), l = o / 2 * (a[0] - n[0] + n[2] - a[2]);
      this.setCenterInternal([i[0] + r, i[1] - l]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(e) {
    const n = this.getProperties();
    return n.resolution !== void 0 ? n.resolution = this.getResolution() : n.zoom = this.getZoom(), n.center = this.getCenterInternal(), n.rotation = this.getRotation(), Object.assign({}, n, e);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(e) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const n = new Array(arguments.length);
    for (let i = 0; i < n.length; ++i) {
      let a = arguments[i];
      a.center && (a = Object.assign({}, a), a.center = jn(
        a.center,
        this.getProjection()
      )), a.anchor && (a = Object.assign({}, a), a.anchor = jn(
        a.anchor,
        this.getProjection()
      )), n[i] = a;
    }
    this.animateInternal.apply(this, n);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(e) {
    let n = arguments.length, i;
    n > 1 && typeof arguments[n - 1] == "function" && (i = arguments[n - 1], --n);
    let a = 0;
    for (; a < n && !this.isDef(); ++a) {
      const c = arguments[a];
      c.center && this.setCenterInternal(c.center), c.zoom !== void 0 ? this.setZoom(c.zoom) : c.resolution && this.setResolution(c.resolution), c.rotation !== void 0 && this.setRotation(c.rotation);
    }
    if (a === n) {
      i && Zo(i, !0);
      return;
    }
    let o = Date.now(), r = this.targetCenter_.slice(), l = this.targetResolution_, s = this.targetRotation_;
    const u = [];
    for (; a < n; ++a) {
      const c = (
        /** @type {AnimationOptions} */
        arguments[a]
      ), d = {
        start: o,
        complete: !1,
        anchor: c.anchor,
        duration: c.duration !== void 0 ? c.duration : 1e3,
        easing: c.easing || Q_,
        callback: i
      };
      if (c.center && (d.sourceCenter = r, d.targetCenter = c.center.slice(), r = d.targetCenter), c.zoom !== void 0 ? (d.sourceResolution = l, d.targetResolution = this.getResolutionForZoom(c.zoom), l = d.targetResolution) : c.resolution && (d.sourceResolution = l, d.targetResolution = c.resolution, l = d.targetResolution), c.rotation !== void 0) {
        d.sourceRotation = s;
        const h = ga(c.rotation - s + Math.PI, 2 * Math.PI) - Math.PI;
        d.targetRotation = s + h, s = d.targetRotation;
      }
      TS(d) ? d.complete = !0 : o += d.duration, u.push(d);
    }
    this.animations_.push(u), this.setHint(vt.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[vt.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[vt.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(vt.ANIMATING, -this.hints_[vt.ANIMATING]);
    let e;
    for (let n = 0, i = this.animations_.length; n < i; ++n) {
      const a = this.animations_[n];
      if (a[0].callback && Zo(a[0].callback, !1), !e)
        for (let o = 0, r = a.length; o < r; ++o) {
          const l = a[o];
          if (!l.complete) {
            e = l.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = e, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const e = Date.now();
    let n = !1;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const a = this.animations_[i];
      let o = !0;
      for (let r = 0, l = a.length; r < l; ++r) {
        const s = a[r];
        if (s.complete)
          continue;
        const u = e - s.start;
        let c = s.duration > 0 ? u / s.duration : 1;
        c >= 1 ? (s.complete = !0, c = 1) : o = !1;
        const d = s.easing(c);
        if (s.sourceCenter) {
          const h = s.sourceCenter[0], f = s.sourceCenter[1], g = s.targetCenter[0], m = s.targetCenter[1];
          this.nextCenter_ = s.targetCenter;
          const v = h + d * (g - h), y = f + d * (m - f);
          this.targetCenter_ = [v, y];
        }
        if (s.sourceResolution && s.targetResolution) {
          const h = d === 1 ? s.targetResolution : s.sourceResolution + d * (s.targetResolution - s.sourceResolution);
          if (s.anchor) {
            const f = this.getViewportSize_(this.getRotation()), g = this.constraints_.resolution(
              h,
              0,
              f,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              g,
              s.anchor
            );
          }
          this.nextResolution_ = s.targetResolution, this.targetResolution_ = h, this.applyTargetState_(!0);
        }
        if (s.sourceRotation !== void 0 && s.targetRotation !== void 0) {
          const h = d === 1 ? ga(s.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : s.sourceRotation + d * (s.targetRotation - s.sourceRotation);
          if (s.anchor) {
            const f = this.constraints_.rotation(
              h,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              f,
              s.anchor
            );
          }
          this.nextRotation_ = s.targetRotation, this.targetRotation_ = h;
        }
        if (this.applyTargetState_(!0), n = !0, !s.complete)
          break;
      }
      if (o) {
        this.animations_[i] = null, this.setHint(vt.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const r = a[0].callback;
        r && Zo(r, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), n && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(e, n) {
    let i;
    const a = this.getCenterInternal();
    return a !== void 0 && (i = [a[0] - n[0], a[1] - n[1]], fu(i, e - this.getRotation()), G_(i, n)), i;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(e, n) {
    let i;
    const a = this.getCenterInternal(), o = this.getResolution();
    if (a !== void 0 && o !== void 0) {
      const r = n[0] - e * (n[0] - a[0]) / o, l = n[1] - e * (n[1] - a[1]) / o;
      i = [r, l];
    }
    return i;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(e) {
    const n = this.viewportSize_;
    if (e) {
      const i = n[0], a = n[1];
      return [
        Math.abs(i * Math.cos(e)) + Math.abs(a * Math.sin(e)),
        Math.abs(i * Math.sin(e)) + Math.abs(a * Math.cos(e))
      ];
    }
    return n;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(e) {
    this.viewportSize_ = Array.isArray(e) ? e.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const e = this.getCenterInternal();
    return e && ss(e, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(un.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(e) {
    return e !== void 0 ? (e[0] = this.hints_[0], e[1] = this.hints_[1], e) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(e) {
    const n = this.calculateExtentInternal(e);
    return mg(n, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(e) {
    e = e || this.getViewportSizeMinusPadding_();
    const n = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    Ee(n, "The view center is not defined");
    const i = (
      /** @type {!number} */
      this.getResolution()
    );
    Ee(i !== void 0, "The view resolution is not defined");
    const a = (
      /** @type {!number} */
      this.getRotation()
    );
    return Ee(a !== void 0, "The view rotation is not defined"), os(n, i, a, e);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: e }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: e }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(e) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: e }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(un.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(e, n) {
    return this.getResolutionForExtentInternal(
      Fi(e, this.getProjection()),
      n
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(e, n) {
    n = n || this.getViewportSizeMinusPadding_();
    const i = ke(e) / n[0], a = Mt(e) / n[1];
    return Math.max(i, a);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(e) {
    e = e || 2;
    const n = this.getConstrainedResolution(this.maxResolution_), i = this.minResolution_, a = Math.log(n / i) / Math.log(e);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(o) {
        return n / Math.pow(e, o * a);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(un.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(e) {
    const n = Math.log(e || 2), i = this.getConstrainedResolution(this.maxResolution_), a = this.minResolution_, o = Math.log(i / a) / n;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(r) {
        return Math.log(i / r) / n / o;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(e) {
    let n = this.getViewportSize_(e);
    const i = this.padding_;
    return i && (n = [
      n[0] - i[1] - i[3],
      n[1] - i[0] - i[2]
    ]), n;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const e = this.getProjection(), n = this.getResolution(), i = this.getRotation();
    let a = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const o = this.padding_;
    if (o) {
      const r = this.getViewportSizeMinusPadding_();
      a = Pl(
        a,
        this.getViewportSize_(),
        [r[0] / 2 + o[3], r[1] / 2 + o[0]],
        n,
        i
      );
    }
    return {
      center: a.slice(0),
      projection: e !== void 0 ? e : null,
      resolution: n,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: i,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let e;
    const n = this.getResolution();
    return n !== void 0 && (e = this.getZoomForResolution(n)), e;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(e) {
    let n = this.minZoom_ || 0, i, a;
    if (this.resolutions_) {
      const o = ru(this.resolutions_, e, 1);
      n = o, i = this.resolutions_[o], o == this.resolutions_.length - 1 ? a = 2 : a = i / this.resolutions_[o + 1];
    } else
      i = this.maxResolution_, a = this.zoomFactor_;
    return n + Math.log(i / e) / Math.log(a);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(e) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      const n = tt(
        Math.floor(e),
        0,
        this.resolutions_.length - 2
      ), i = this.resolutions_[n] / this.resolutions_[n + 1];
      return this.resolutions_[n] / Math.pow(i, tt(e - n, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, e - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(e, n) {
    let i;
    if (Ee(
      Array.isArray(e) || typeof /** @type {?} */
      e.getSimplifiedGeometry == "function",
      "Invalid extent or geometry provided as `geometry`"
    ), Array.isArray(e)) {
      Ee(
        !jr(e),
        "Cannot fit empty extent provided as `geometry`"
      );
      const a = Fi(e, this.getProjection());
      i = hd(a);
    } else if (e.getType() === "Circle") {
      const a = Fi(
        e.getExtent(),
        this.getProjection()
      );
      i = hd(a), i.rotate(this.getRotation(), $i(a));
    } else
      i = e;
    this.fitInternal(i, n);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(e) {
    const n = this.getRotation(), i = Math.cos(n), a = Math.sin(-n), o = e.getFlatCoordinates(), r = e.getStride();
    let l = 1 / 0, s = 1 / 0, u = -1 / 0, c = -1 / 0;
    for (let d = 0, h = o.length; d < h; d += r) {
      const f = o[d] * i - o[d + 1] * a, g = o[d] * a + o[d + 1] * i;
      l = Math.min(l, f), s = Math.min(s, g), u = Math.max(u, f), c = Math.max(c, g);
    }
    return [l, s, u, c];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(e, n) {
    n = n || {};
    let i = n.size;
    i || (i = this.getViewportSizeMinusPadding_());
    const a = n.padding !== void 0 ? n.padding : [0, 0, 0, 0], o = n.nearest !== void 0 ? n.nearest : !1;
    let r;
    n.minResolution !== void 0 ? r = n.minResolution : n.maxZoom !== void 0 ? r = this.getResolutionForZoom(n.maxZoom) : r = 0;
    const l = this.rotatedExtentForGeometry(e);
    let s = this.getResolutionForExtentInternal(l, [
      i[0] - a[1] - a[3],
      i[1] - a[0] - a[2]
    ]);
    s = isNaN(s) ? r : Math.max(s, r), s = this.getConstrainedResolution(s, o ? 0 : 1);
    const u = this.getRotation(), c = Math.sin(u), d = Math.cos(u), h = $i(l);
    h[0] += (a[1] - a[3]) / 2 * s, h[1] += (a[0] - a[2]) / 2 * s;
    const f = h[0] * d - h[1] * c, g = h[1] * d + h[0] * c, m = this.getConstrainedCenter([f, g], s), v = n.callback ? n.callback : Sa;
    n.duration !== void 0 ? this.animateInternal(
      {
        resolution: s,
        center: m,
        duration: n.duration,
        easing: n.easing
      },
      v
    ) : (this.targetResolution_ = s, this.targetCenter_ = m, this.applyTargetState_(!1, !0), Zo(v, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(e, n, i) {
    this.centerOnInternal(
      jn(e, this.getProjection()),
      n,
      i
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(e, n, i) {
    this.setCenterInternal(
      Pl(
        e,
        n,
        i,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(e, n, i, a) {
    let o;
    const r = this.padding_;
    if (r && e) {
      const l = this.getViewportSizeMinusPadding_(-i), s = Pl(
        e,
        a,
        [l[0] / 2 + r[3], l[1] / 2 + r[0]],
        n,
        i
      );
      o = [
        e[0] - s[0],
        e[1] - s[1]
      ];
    }
    return o;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(e) {
    const n = ss(this.targetCenter_, this.getProjection());
    this.setCenter([
      n[0] + e[0],
      n[1] + e[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(e) {
    const n = this.targetCenter_;
    this.setCenterInternal([
      n[0] + e[0],
      n[1] + e[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(e, n) {
    n = n && jn(n, this.getProjection()), this.adjustResolutionInternal(e, n);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(e, n) {
    const i = this.getAnimating() || this.getInteracting(), a = this.getViewportSize_(this.getRotation()), o = this.constraints_.resolution(
      this.targetResolution_ * e,
      0,
      a,
      i
    );
    n && (this.targetCenter_ = this.calculateCenterZoom(o, n)), this.targetResolution_ *= e, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(e, n) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -e), n);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(e, n) {
    n && (n = jn(n, this.getProjection())), this.adjustRotationInternal(e, n);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(e, n) {
    const i = this.getAnimating() || this.getInteracting(), a = this.constraints_.rotation(
      this.targetRotation_ + e,
      i
    );
    n && (this.targetCenter_ = this.calculateCenterRotate(a, n)), this.targetRotation_ += e, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(e) {
    this.setCenterInternal(
      e && jn(e, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(e) {
    this.targetCenter_ = e, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(e, n) {
    return this.hints_[e] += n, this.changed(), this.hints_[e];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(e) {
    this.targetResolution_ = e, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(e) {
    this.targetRotation_ = e, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(e) {
    this.setResolution(this.getResolutionForZoom(e));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(e, n) {
    const i = this.getAnimating() || this.getInteracting() || n, a = this.constraints_.rotation(
      this.targetRotation_,
      i
    ), o = this.getViewportSize_(a), r = this.constraints_.resolution(
      this.targetResolution_,
      0,
      o,
      i
    ), l = this.constraints_.center(
      this.targetCenter_,
      r,
      o,
      i,
      this.calculateCenterShift(
        this.targetCenter_,
        r,
        a,
        o
      )
    );
    this.get(un.ROTATION) !== a && this.set(un.ROTATION, a), this.get(un.RESOLUTION) !== r && (this.set(un.RESOLUTION, r), this.set("zoom", this.getZoom(), !0)), (!l || !this.get(un.CENTER) || !Cr(this.get(un.CENTER), l)) && this.set(un.CENTER, l), this.getAnimating() && !e && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(e, n, i) {
    e = e !== void 0 ? e : 200;
    const a = n || 0, o = this.constraints_.rotation(this.targetRotation_), r = this.getViewportSize_(o), l = this.constraints_.resolution(
      this.targetResolution_,
      a,
      r
    ), s = this.constraints_.center(
      this.targetCenter_,
      l,
      r,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        l,
        o,
        r
      )
    );
    if (e === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = l, this.targetRotation_ = o, this.targetCenter_ = s, this.applyTargetState_();
      return;
    }
    i = i || (e === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== l || this.getRotation() !== o || !this.getCenterInternal() || !Cr(this.getCenterInternal(), s)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: o,
      center: s,
      resolution: l,
      duration: e,
      easing: za,
      anchor: i
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(vt.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(e, n, i) {
    i = i && jn(i, this.getProjection()), this.endInteractionInternal(e, n, i);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(e, n, i) {
    this.getInteracting() && (this.setHint(vt.INTERACTING, -1), this.resolveConstraints(e, n, i));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(e, n) {
    const i = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      e,
      n || this.getResolution(),
      i
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(e, n) {
    const i = this.getResolutionForZoom(e);
    return this.getZoomForResolution(
      this.getConstrainedResolution(i, n)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(e, n) {
    n = n || 0;
    const i = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(e, n, i);
  }
}
function Zo(t, e) {
  setTimeout(function() {
    t(e);
  }, 0);
}
function MS(t) {
  if (t.extent !== void 0) {
    const n = t.smoothExtentConstraint !== void 0 ? t.smoothExtentConstraint : !0;
    return id(t.extent, t.constrainOnlyCenter, n);
  }
  const e = mu(t.projection, "EPSG:3857");
  if (t.multiWorld !== !0 && e.isGlobal()) {
    const n = e.getExtent().slice();
    return n[0] = -1 / 0, n[2] = 1 / 0, id(n, !1, !1);
  }
  return H_;
}
function xS(t) {
  let e, n, i, r = t.minZoom !== void 0 ? t.minZoom : xl, l = t.maxZoom !== void 0 ? t.maxZoom : 28;
  const s = t.zoomFactor !== void 0 ? t.zoomFactor : 2, u = t.multiWorld !== void 0 ? t.multiWorld : !1, c = t.smoothResolutionConstraint !== void 0 ? t.smoothResolutionConstraint : !0, d = t.showFullExtent !== void 0 ? t.showFullExtent : !1, h = mu(t.projection, "EPSG:3857"), f = h.getExtent();
  let g = t.constrainOnlyCenter, m = t.extent;
  if (!u && !m && h.isGlobal() && (g = !1, m = f), t.resolutions !== void 0) {
    const v = t.resolutions;
    n = v[r], i = v[l] !== void 0 ? v[l] : v[v.length - 1], t.constrainResolution ? e = Z_(
      v,
      c,
      !g && m,
      d
    ) : e = ad(
      n,
      i,
      c,
      !g && m,
      d
    );
  } else {
    const y = (f ? Math.max(ke(f), Mt(f)) : (
      // use an extent that can fit the whole world if need be
      360 * cu.degrees / h.getMetersPerUnit()
    )) / uu / Math.pow(2, xl), C = y / Math.pow(2, 28 - xl);
    n = t.maxResolution, n !== void 0 ? r = 0 : n = y / Math.pow(s, r), i = t.minResolution, i === void 0 && (t.maxZoom !== void 0 ? t.maxResolution !== void 0 ? i = n / Math.pow(s, l) : i = y / Math.pow(s, l) : i = C), l = r + Math.floor(
      Math.log(n / i) / Math.log(s)
    ), i = n / Math.pow(s, l - r), t.constrainResolution ? e = K_(
      s,
      n,
      i,
      c,
      !g && m,
      d
    ) : e = ad(
      n,
      i,
      c,
      !g && m,
      d
    );
  }
  return {
    constraint: e,
    maxResolution: n,
    minResolution: i,
    minZoom: r,
    zoomFactor: s
  };
}
function PS(t) {
  if (t.enableRotation !== void 0 ? t.enableRotation : !0) {
    const n = t.constrainRotation;
    return n === void 0 || n === !0 ? J_() : n === !1 ? od : typeof n == "number" ? q_(n) : od;
  }
  return pu;
}
function TS(t) {
  return !(t.sourceCenter && t.targetCenter && !Cr(t.sourceCenter, t.targetCenter) || t.sourceResolution !== t.targetResolution || t.sourceRotation !== t.targetRotation);
}
function Pl(t, e, n, i, a) {
  const o = Math.cos(-a);
  let r = Math.sin(-a), l = t[0] * o - t[1] * r, s = t[1] * o + t[0] * r;
  l += (e[0] / 2 - n[0]) * i, s += (n[1] - e[1] / 2) * i, r = -r;
  const u = l * o - s * r, c = s * o + l * r;
  return [u, c];
}
class Zr extends eg {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(e) {
    const n = Object.assign({}, e);
    delete n.source, super(n), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, e.render && (this.render = e.render), e.map && this.setMap(e.map), this.addChangeListener(
      Fe.SOURCE,
      this.handleSourcePropertyChange_
    );
    const i = e.source ? (
      /** @type {SourceType} */
      e.source
    ) : null;
    this.setSource(i);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e || [], e.push(this), e;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return e = e || [], e.push(this.getLayerState()), e;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(Fe.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const e = this.getSource();
    return e ? e.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && ($e(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const e = this.getSource();
    e && (this.sourceChangeKey_ = we(
      e,
      Se.CHANGE,
      this.handleSourceChange_,
      this
    ), e.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return this.renderer_ ? this.renderer_.getFeatures(e) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(e);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(e) {
    let n;
    const i = this.getMapInternal();
    !e && i && (e = i.getView()), e instanceof Pn ? n = {
      viewState: e.getState(),
      extent: e.calculateExtent()
    } : n = e, !n.layerStatesArray && i && (n.layerStatesArray = i.getLayerGroup().getLayerStatesArray());
    let a;
    n.layerStatesArray ? a = n.layerStatesArray.find(
      (r) => r.layer === this
    ) : a = this.getLayerState();
    const o = this.getExtent();
    return xu(a, n.viewState) && (!o || zt(o, n.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(e) {
    if (!this.isVisible(e))
      return [];
    let n;
    const i = this.getSource();
    if (i && (n = i.getAttributions()), !n)
      return [];
    const a = e instanceof Pn ? e.getViewStateAndExtent() : e;
    let o = n(a);
    return Array.isArray(o) || (o = [o]), o;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(e, n) {
    const i = this.getRenderer();
    return i.prepareFrame(e) ? (this.rendered = !0, i.renderFrame(e, n)) : null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /** @return {string} Declutter */
  getDeclutter() {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, n) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(e) {
    const n = this.getRenderer();
    n && n.renderDeferred(e);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(e) {
    e || this.unrender(), this.set(Fe.MAP, e);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(Fe.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.mapPrecomposeKey_ && ($e(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), e || this.changed(), this.mapRenderKey_ && ($e(this.mapRenderKey_), this.mapRenderKey_ = null), e && (this.mapPrecomposeKey_ = we(
      e,
      Qt.PRECOMPOSE,
      function(n) {
        const a = /** @type {import("../render/Event.js").default} */ n.frameState.layerStatesArray, o = this.getLayerState(!1);
        Ee(
          !a.some(function(r) {
            return r.layer === o.layer;
          }),
          "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
        ), a.push(o);
      },
      this
    ), this.mapRenderKey_ = we(this, Se.CHANGE, e.render, e), this.changed());
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(e) {
    this.set(Fe.SOURCE, e);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
  }
}
function xu(t, e) {
  if (!t.visible)
    return !1;
  const n = e.resolution;
  if (n < t.minResolution || n >= t.maxResolution)
    return !1;
  const i = e.zoom;
  return i > t.minZoom && i <= t.maxZoom;
}
function wS(t, e, n, i, a) {
  wg(t, e, n || 0, i || t.length - 1, a || ES);
}
function wg(t, e, n, i, a) {
  for (; i > n; ) {
    if (i - n > 600) {
      var o = i - n + 1, r = e - n + 1, l = Math.log(o), s = 0.5 * Math.exp(2 * l / 3), u = 0.5 * Math.sqrt(l * s * (o - s) / o) * (r - o / 2 < 0 ? -1 : 1), c = Math.max(n, Math.floor(e - r * s / o + u)), d = Math.min(i, Math.floor(e + (o - r) * s / o + u));
      wg(t, e, c, d, a);
    }
    var h = t[e], f = n, g = i;
    for (Da(t, n, e), a(t[i], h) > 0 && Da(t, n, i); f < g; ) {
      for (Da(t, f, g), f++, g--; a(t[f], h) < 0; ) f++;
      for (; a(t[g], h) > 0; ) g--;
    }
    a(t[n], h) === 0 ? Da(t, n, g) : (g++, Da(t, g, i)), g <= e && (n = g + 1), e <= g && (i = g - 1);
  }
}
function Da(t, e, n) {
  var i = t[e];
  t[e] = t[n], t[n] = i;
}
function ES(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
let Eg = class {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let n = this.data;
    const i = [];
    if (!qo(e, n)) return i;
    const a = this.toBBox, o = [];
    for (; n; ) {
      for (let r = 0; r < n.children.length; r++) {
        const l = n.children[r], s = n.leaf ? a(l) : l;
        qo(e, s) && (n.leaf ? i.push(l) : wl(e, s) ? this._all(l, i) : o.push(l));
      }
      n = o.pop();
    }
    return i;
  }
  collides(e) {
    let n = this.data;
    if (!qo(e, n)) return !1;
    const i = [];
    for (; n; ) {
      for (let a = 0; a < n.children.length; a++) {
        const o = n.children[a], r = n.leaf ? this.toBBox(o) : o;
        if (qo(e, r)) {
          if (n.leaf || wl(e, r)) return !0;
          i.push(o);
        }
      }
      n = i.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length)) return this;
    if (e.length < this._minEntries) {
      for (let i = 0; i < e.length; i++)
        this.insert(e[i]);
      return this;
    }
    let n = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const i = this.data;
        this.data = n, n = i;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = ia([]), this;
  }
  remove(e, n) {
    if (!e) return this;
    let i = this.data;
    const a = this.toBBox(e), o = [], r = [];
    let l, s, u;
    for (; i || o.length; ) {
      if (i || (i = o.pop(), s = o[o.length - 1], l = r.pop(), u = !0), i.leaf) {
        const c = AS(e, i.children, n);
        if (c !== -1)
          return i.children.splice(c, 1), o.push(i), this._condense(o), this;
      }
      !u && !i.leaf && wl(i, a) ? (o.push(i), r.push(l), l = 0, s = i, i = i.children[0]) : s ? (l++, i = s.children[l], u = !1) : i = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, n) {
    return e.minX - n.minX;
  }
  compareMinY(e, n) {
    return e.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, n) {
    const i = [];
    for (; e; )
      e.leaf ? n.push(...e.children) : i.push(...e.children), e = i.pop();
    return n;
  }
  _build(e, n, i, a) {
    const o = i - n + 1;
    let r = this._maxEntries, l;
    if (o <= r)
      return l = ia(e.slice(n, i + 1)), Ji(l, this.toBBox), l;
    a || (a = Math.ceil(Math.log(o) / Math.log(r)), r = Math.ceil(o / Math.pow(r, a - 1))), l = ia([]), l.leaf = !1, l.height = a;
    const s = Math.ceil(o / r), u = s * Math.ceil(Math.sqrt(r));
    fd(e, n, i, u, this.compareMinX);
    for (let c = n; c <= i; c += u) {
      const d = Math.min(c + u - 1, i);
      fd(e, c, d, s, this.compareMinY);
      for (let h = c; h <= d; h += s) {
        const f = Math.min(h + s - 1, d);
        l.children.push(this._build(e, h, f, a - 1));
      }
    }
    return Ji(l, this.toBBox), l;
  }
  _chooseSubtree(e, n, i, a) {
    for (; a.push(n), !(n.leaf || a.length - 1 === i); ) {
      let o = 1 / 0, r = 1 / 0, l;
      for (let s = 0; s < n.children.length; s++) {
        const u = n.children[s], c = Tl(u), d = zS(e, u) - c;
        d < r ? (r = d, o = c < o ? c : o, l = u) : d === r && c < o && (o = c, l = u);
      }
      n = l || n.children[0];
    }
    return n;
  }
  _insert(e, n, i) {
    const a = i ? e : this.toBBox(e), o = [], r = this._chooseSubtree(a, this.data, n, o);
    for (r.children.push(e), Ya(r, a); n >= 0 && o[n].children.length > this._maxEntries; )
      this._split(o, n), n--;
    this._adjustParentBBoxes(a, o, n);
  }
  // split overflowed node into two
  _split(e, n) {
    const i = e[n], a = i.children.length, o = this._minEntries;
    this._chooseSplitAxis(i, o, a);
    const r = this._chooseSplitIndex(i, o, a), l = ia(i.children.splice(r, i.children.length - r));
    l.height = i.height, l.leaf = i.leaf, Ji(i, this.toBBox), Ji(l, this.toBBox), n ? e[n - 1].children.push(l) : this._splitRoot(i, l);
  }
  _splitRoot(e, n) {
    this.data = ia([e, n]), this.data.height = e.height + 1, this.data.leaf = !1, Ji(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, n, i) {
    let a, o = 1 / 0, r = 1 / 0;
    for (let l = n; l <= i - n; l++) {
      const s = Ua(e, 0, l, this.toBBox), u = Ua(e, l, i, this.toBBox), c = LS(s, u), d = Tl(s) + Tl(u);
      c < o ? (o = c, a = l, r = d < r ? d : r) : c === o && d < r && (r = d, a = l);
    }
    return a || i - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, n, i) {
    const a = e.leaf ? this.compareMinX : RS, o = e.leaf ? this.compareMinY : IS, r = this._allDistMargin(e, n, i, a), l = this._allDistMargin(e, n, i, o);
    r < l && e.children.sort(a);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, n, i, a) {
    e.children.sort(a);
    const o = this.toBBox, r = Ua(e, 0, n, o), l = Ua(e, i - n, i, o);
    let s = Ko(r) + Ko(l);
    for (let u = n; u < i - n; u++) {
      const c = e.children[u];
      Ya(r, e.leaf ? o(c) : c), s += Ko(r);
    }
    for (let u = i - n - 1; u >= n; u--) {
      const c = e.children[u];
      Ya(l, e.leaf ? o(c) : c), s += Ko(l);
    }
    return s;
  }
  _adjustParentBBoxes(e, n, i) {
    for (let a = i; a >= 0; a--)
      Ya(n[a], e);
  }
  _condense(e) {
    for (let n = e.length - 1, i; n >= 0; n--)
      e[n].children.length === 0 ? n > 0 ? (i = e[n - 1].children, i.splice(i.indexOf(e[n]), 1)) : this.clear() : Ji(e[n], this.toBBox);
  }
};
function AS(t, e, n) {
  if (!n) return e.indexOf(t);
  for (let i = 0; i < e.length; i++)
    if (n(t, e[i])) return i;
  return -1;
}
function Ji(t, e) {
  Ua(t, 0, t.children.length, e, t);
}
function Ua(t, e, n, i, a) {
  a || (a = ia(null)), a.minX = 1 / 0, a.minY = 1 / 0, a.maxX = -1 / 0, a.maxY = -1 / 0;
  for (let o = e; o < n; o++) {
    const r = t.children[o];
    Ya(a, t.leaf ? i(r) : r);
  }
  return a;
}
function Ya(t, e) {
  return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t;
}
function RS(t, e) {
  return t.minX - e.minX;
}
function IS(t, e) {
  return t.minY - e.minY;
}
function Tl(t) {
  return (t.maxX - t.minX) * (t.maxY - t.minY);
}
function Ko(t) {
  return t.maxX - t.minX + (t.maxY - t.minY);
}
function zS(t, e) {
  return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY));
}
function LS(t, e) {
  const n = Math.max(t.minX, e.minX), i = Math.max(t.minY, e.minY), a = Math.min(t.maxX, e.maxX), o = Math.min(t.maxY, e.maxY);
  return Math.max(0, a - n) * Math.max(0, o - i);
}
function wl(t, e) {
  return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;
}
function qo(t, e) {
  return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;
}
function ia(t) {
  return {
    children: t,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function fd(t, e, n, i, a) {
  const o = [e, n];
  for (; o.length; ) {
    if (n = o.pop(), e = o.pop(), n - e <= i) continue;
    const r = e + Math.ceil((n - e) / i / 2) * i;
    wS(t, r, e, n, a), o.push(e, r, r, n);
  }
}
const Me = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
};
function gd(t) {
  return t[0] > 0 && t[1] > 0;
}
function VS(t, e, n) {
  return n === void 0 && (n = [0, 0]), n[0] = t[0] * e + 0.5 | 0, n[1] = t[1] * e + 0.5 | 0, n;
}
function Dt(t, e) {
  return Array.isArray(t) ? t : (e === void 0 ? e = [t, t] : (e[0] = t, e[1] = t), e);
}
class Kr {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.opacity_ = e.opacity, this.rotateWithView_ = e.rotateWithView, this.rotation_ = e.rotation, this.scale_ = e.scale, this.scaleArray_ = Dt(e.scale), this.displacement_ = e.displacement, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new Kr({
      opacity: this.getOpacity(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return Re();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(e) {
    return Re();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return Re();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return Re();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return Re();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return Re();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return Re();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(e) {
    this.displacement_ = e;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(e) {
    this.opacity_ = e;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = Dt(e);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    Re();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    Re();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    Re();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}
const uo = {
  name: "rgb",
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ["red", "green", "blue"],
  alias: ["RGB"]
}, yt = {
  name: "xyz",
  min: [0, 0, 0],
  channel: ["X", "Y", "Z"],
  alias: ["XYZ", "ciexyz", "cie1931"],
  // Whitepoint reference values with observer/illuminant
  // http://en.wikipedia.org/wiki/Standard_illuminant
  whitepoint: {
    //1931 2
    2: {
      //incadescent
      A: [109.85, 100, 35.585],
      // B:[],
      C: [98.074, 100, 118.232],
      D50: [96.422, 100, 82.521],
      D55: [95.682, 100, 92.149],
      //daylight
      D65: [95.045592705167, 100, 108.9057750759878],
      D75: [94.972, 100, 122.638],
      //flourescent
      // F1: [],
      F2: [99.187, 100, 67.395],
      // F3: [],
      // F4: [],
      // F5: [],
      // F6:[],
      F7: [95.044, 100, 108.755],
      // F8: [],
      // F9: [],
      // F10: [],
      F11: [100.966, 100, 64.37],
      // F12: [],
      E: [100, 100, 100]
    },
    //1964  10
    10: {
      //incadescent
      A: [111.144, 100, 35.2],
      C: [97.285, 100, 116.145],
      D50: [96.72, 100, 81.427],
      D55: [95.799, 100, 90.926],
      //daylight
      D65: [94.811, 100, 107.304],
      D75: [94.416, 100, 120.641],
      //flourescent
      F2: [103.28, 100, 69.026],
      F7: [95.792, 100, 107.687],
      F11: [103.866, 100, 65.627],
      E: [100, 100, 100]
    }
  }
};
yt.max = yt.whitepoint[2].D65;
yt.rgb = function(t, e) {
  e = e || yt.whitepoint[2].E;
  var n = t[0] / e[0], i = t[1] / e[1], a = t[2] / e[2], o, r, l;
  return o = n * 3.240969941904521 + i * -1.537383177570093 + a * -0.498610760293, r = n * -0.96924363628087 + i * 1.87596750150772 + a * 0.041555057407175, l = n * 0.055630079696993 + i * -0.20397695888897 + a * 1.056971514242878, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o = o * 12.92, r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92, l = l > 31308e-7 ? 1.055 * Math.pow(l, 1 / 2.4) - 0.055 : l = l * 12.92, o = Math.min(Math.max(0, o), 1), r = Math.min(Math.max(0, r), 1), l = Math.min(Math.max(0, l), 1), [o * 255, r * 255, l * 255];
};
uo.xyz = function(t, e) {
  var n = t[0] / 255, i = t[1] / 255, a = t[2] / 255;
  n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92, a = a > 0.04045 ? Math.pow((a + 0.055) / 1.055, 2.4) : a / 12.92;
  var o = n * 0.41239079926595 + i * 0.35758433938387 + a * 0.18048078840183, r = n * 0.21263900587151 + i * 0.71516867876775 + a * 0.072192315360733, l = n * 0.019330818715591 + i * 0.11919477979462 + a * 0.95053215224966;
  return e = e || yt.whitepoint[2].E, [o * e[0], r * e[1], l * e[2]];
};
var Pu = {
  name: "luv",
  //NOTE: luv has no rigidly defined limits
  //easyrgb fails to get proper coords
  //boronine states no rigid limits
  //colorMine refers this ones:
  min: [0, -134, -140],
  max: [100, 224, 122],
  channel: ["lightness", "u", "v"],
  alias: ["LUV", "cieluv", "cie1976"],
  xyz: function(t, e, n) {
    var i, a, o, r, l, s, u, c, d, h, f, g, m;
    if (o = t[0], r = t[1], l = t[2], o === 0) return [0, 0, 0];
    var v = 0.0011070564598794539;
    return e = e || "D65", n = n || 2, d = yt.whitepoint[n][e][0], h = yt.whitepoint[n][e][1], f = yt.whitepoint[n][e][2], g = 4 * d / (d + 15 * h + 3 * f), m = 9 * h / (d + 15 * h + 3 * f), i = r / (13 * o) + g || 0, a = l / (13 * o) + m || 0, u = o > 8 ? h * Math.pow((o + 16) / 116, 3) : h * o * v, s = u * 9 * i / (4 * a) || 0, c = u * (12 - 3 * i - 20 * a) / (4 * a) || 0, [s, u, c];
  }
};
yt.luv = function(t, e, n) {
  var i, a, o, r, l, s, u, c, d, h, f, g, m, v = 0.008856451679035631, y = 903.2962962962961;
  e = e || "D65", n = n || 2, d = yt.whitepoint[n][e][0], h = yt.whitepoint[n][e][1], f = yt.whitepoint[n][e][2], g = 4 * d / (d + 15 * h + 3 * f), m = 9 * h / (d + 15 * h + 3 * f), s = t[0], u = t[1], c = t[2], i = 4 * s / (s + 15 * u + 3 * c) || 0, a = 9 * u / (s + 15 * u + 3 * c) || 0;
  var C = u / h;
  return o = C <= v ? y * C : 116 * Math.pow(C, 1 / 3) - 16, r = 13 * o * (i - g), l = 13 * o * (a - m), [o, r, l];
};
var Ag = {
  name: "lchuv",
  channel: ["lightness", "chroma", "hue"],
  alias: ["LCHuv", "cielchuv"],
  min: [0, 0, 0],
  max: [100, 100, 360],
  luv: function(t) {
    var e = t[0], n = t[1], i = t[2], a, o, r;
    return r = i / 360 * 2 * Math.PI, a = n * Math.cos(r), o = n * Math.sin(r), [e, a, o];
  },
  xyz: function(t) {
    return Pu.xyz(Ag.luv(t));
  }
};
Pu.lchuv = function(t) {
  var e = t[0], n = t[1], i = t[2], a = Math.sqrt(n * n + i * i), o = Math.atan2(i, n), r = o * 360 / 2 / Math.PI;
  return r < 0 && (r += 360), [e, a, r];
};
yt.lchuv = function(t) {
  return Pu.lchuv(yt.luv(t));
};
const md = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var vd = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function BS(t) {
  var c, d;
  var e, n = [], i = 1, a;
  if (typeof t == "number")
    return { space: "rgb", values: [t >>> 16, (t & 65280) >>> 8, t & 255], alpha: 1 };
  if (typeof t == "number") return { space: "rgb", values: [t >>> 16, (t & 65280) >>> 8, t & 255], alpha: 1 };
  if (t = String(t).toLowerCase(), md[t])
    n = md[t].slice(), a = "rgb";
  else if (t === "transparent")
    i = 0, a = "rgb", n = [0, 0, 0];
  else if (t[0] === "#") {
    var o = t.slice(1), r = o.length, l = r <= 4;
    i = 1, l ? (n = [
      parseInt(o[0] + o[0], 16),
      parseInt(o[1] + o[1], 16),
      parseInt(o[2] + o[2], 16)
    ], r === 4 && (i = parseInt(o[3] + o[3], 16) / 255)) : (n = [
      parseInt(o[0] + o[1], 16),
      parseInt(o[2] + o[3], 16),
      parseInt(o[4] + o[5], 16)
    ], r === 8 && (i = parseInt(o[6] + o[7], 16) / 255)), n[0] || (n[0] = 0), n[1] || (n[1] = 0), n[2] || (n[2] = 0), a = "rgb";
  } else if (e = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(t)) {
    var s = e[1];
    a = s.replace(/a$/, "");
    var u = a === "cmyk" ? 4 : a === "gray" ? 1 : 3;
    n = e[2].trim().split(/\s*[,\/]\s*|\s+/), a === "color" && (a = n.shift()), n = n.map(function(h, f) {
      if (h[h.length - 1] === "%")
        return h = parseFloat(h) / 100, f === 3 ? h : a === "rgb" ? h * 255 : a[0] === "h" || a[0] === "l" && !f ? h * 100 : a === "lab" ? h * 125 : a === "lch" ? f < 2 ? h * 150 : h * 360 : a[0] === "o" && !f ? h : a === "oklab" ? h * 0.4 : a === "oklch" ? f < 2 ? h * 0.4 : h * 360 : h;
      if (a[f] === "h" || f === 2 && a[a.length - 1] === "h") {
        if (vd[h] !== void 0) return vd[h];
        if (h.endsWith("deg")) return parseFloat(h);
        if (h.endsWith("turn")) return parseFloat(h) * 360;
        if (h.endsWith("grad")) return parseFloat(h) * 360 / 400;
        if (h.endsWith("rad")) return parseFloat(h) * 180 / Math.PI;
      }
      return h === "none" ? 0 : parseFloat(h);
    }), i = n.length > u ? n.pop() : 1;
  } else /[0-9](?:\s|\/|,)/.test(t) && (n = t.match(/([0-9]+)/g).map(function(h) {
    return parseFloat(h);
  }), a = ((d = (c = t.match(/([a-z])/ig)) == null ? void 0 : c.join("")) == null ? void 0 : d.toLowerCase()) || "rgb");
  return {
    space: a,
    values: n,
    alpha: i
  };
}
var El = {
  name: "hsl",
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ["hue", "saturation", "lightness"],
  alias: ["HSL"],
  rgb: function(t) {
    var e = t[0] / 360, n = t[1] / 100, i = t[2] / 100, a, o, r, l, s, u = 0;
    if (n === 0) return s = i * 255, [s, s, s];
    for (o = i < 0.5 ? i * (1 + n) : i + n - i * n, a = 2 * i - o, l = [0, 0, 0]; u < 3; )
      r = e + 1 / 3 * -(u - 1), r < 0 ? r++ : r > 1 && r--, s = 6 * r < 1 ? a + (o - a) * 6 * r : 2 * r < 1 ? o : 3 * r < 2 ? a + (o - a) * (2 / 3 - r) * 6 : a, l[u++] = s * 255;
    return l;
  }
};
uo.hsl = function(t) {
  var e = t[0] / 255, n = t[1] / 255, i = t[2] / 255, a = Math.min(e, n, i), o = Math.max(e, n, i), r = o - a, l, s, u;
  return o === a ? l = 0 : e === o ? l = (n - i) / r : n === o ? l = 2 + (i - e) / r : i === o && (l = 4 + (e - n) / r), l = Math.min(l * 60, 360), l < 0 && (l += 360), u = (a + o) / 2, o === a ? s = 0 : u <= 0.5 ? s = r / (o + a) : s = r / (2 - o - a), [l, s * 100, u * 100];
};
function FS(t) {
  Array.isArray(t) && t.raw && (t = String.raw(...arguments)), t instanceof Number && (t = +t);
  var e, n = BS(t);
  if (!n.space) return [];
  const i = n.space[0] === "h" ? El.min : uo.min, a = n.space[0] === "h" ? El.max : uo.max;
  return e = Array(3), e[0] = Math.min(Math.max(n.values[0], i[0]), a[0]), e[1] = Math.min(Math.max(n.values[1], i[1]), a[1]), e[2] = Math.min(Math.max(n.values[2], i[2]), a[2]), n.space[0] === "h" && (e = El.rgb(e)), e.push(Math.min(Math.max(n.alpha, 0), 1)), e;
}
function kS(t) {
  return typeof t == "string" ? t : wu(t);
}
const OS = 1024, Ga = {};
let Al = 0;
function DS(t) {
  if (t.length === 4)
    return t;
  const e = t.slice();
  return e[3] = 1, e;
}
function yd(t) {
  const e = yt.lchuv(uo.xyz(t));
  return e[3] = t[3], e;
}
function GS(t) {
  const e = yt.rgb(Ag.xyz(t));
  return e[3] = t[3], e;
}
function Tu(t) {
  if (Ga.hasOwnProperty(t))
    return Ga[t];
  if (Al >= OS) {
    let n = 0;
    for (const i in Ga)
      (n++ & 3) === 0 && (delete Ga[i], --Al);
  }
  const e = FS(t);
  if (e.length !== 4)
    throw new Error('Failed to parse "' + t + '" as color');
  for (const n of e)
    if (isNaN(n))
      throw new Error('Failed to parse "' + t + '" as color');
  return Rg(e), Ga[t] = e, ++Al, e;
}
function co(t) {
  return Array.isArray(t) ? t : Tu(t);
}
function Rg(t) {
  return t[0] = tt(t[0] + 0.5 | 0, 0, 255), t[1] = tt(t[1] + 0.5 | 0, 0, 255), t[2] = tt(t[2] + 0.5 | 0, 0, 255), t[3] = tt(t[3], 0, 1), t;
}
function wu(t) {
  let e = t[0];
  e != (e | 0) && (e = e + 0.5 | 0);
  let n = t[1];
  n != (n | 0) && (n = n + 0.5 | 0);
  let i = t[2];
  i != (i | 0) && (i = i + 0.5 | 0);
  const a = t[3] === void 0 ? 1 : Math.round(t[3] * 1e3) / 1e3;
  return "rgba(" + e + "," + n + "," + i + "," + a + ")";
}
function NS(t) {
  try {
    return Tu(t), !0;
  } catch {
    return !1;
  }
}
const xi = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", WS = xi.includes("firefox"), $S = xi.includes("safari") && !xi.includes("chrom");
$S && (xi.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(xi));
const XS = xi.includes("webkit") && !xi.includes("edge"), Ig = xi.includes("macintosh"), zg = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, Lg = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, Vg = typeof Image < "u" && Image.prototype.decode, Bg = function() {
  let t = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        t = !0;
      }
    });
    window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
  } catch {
  }
  return t;
}();
function dt(t, e, n, i) {
  let a;
  return n && n.length ? a = /** @type {HTMLCanvasElement} */
  n.shift() : Lg ? a = new OffscreenCanvas(t || 300, e || 300) : a = document.createElement("canvas"), t && (a.width = t), e && (a.height = e), /** @type {CanvasRenderingContext2D} */
  a.getContext("2d", i);
}
let Rl;
function Sr() {
  return Rl || (Rl = dt(1, 1)), Rl;
}
function qr(t) {
  const e = t.canvas;
  e.width = 1, e.height = 1, t.clearRect(0, 0, 1, 1);
}
function US(t) {
  let e = t.offsetWidth;
  const n = getComputedStyle(t);
  return e += parseInt(n.marginLeft, 10) + parseInt(n.marginRight, 10), e;
}
function YS(t) {
  let e = t.offsetHeight;
  const n = getComputedStyle(t);
  return e += parseInt(n.marginTop, 10) + parseInt(n.marginBottom, 10), e;
}
function Cd(t, e) {
  const n = e.parentNode;
  n && n.replaceChild(t, e);
}
function br(t) {
  return t && t.parentNode ? t.parentNode.removeChild(t) : null;
}
function Fg(t) {
  for (; t.lastChild; )
    t.removeChild(t.lastChild);
}
function jS(t, e) {
  const n = t.childNodes;
  for (let i = 0; ; ++i) {
    const a = n[i], o = e[i];
    if (!a && !o)
      break;
    if (a !== o) {
      if (!a) {
        t.appendChild(o);
        continue;
      }
      if (!o) {
        t.removeChild(a), --i;
        continue;
      }
      t.insertBefore(o, a);
    }
  }
}
function HS(t, e, n) {
  const i = (
    /** @type {HTMLImageElement} */
    t
  );
  let a = !0, o = !1, r = !1;
  const l = [
    vr(i, Se.LOAD, function() {
      r = !0, o || e();
    })
  ];
  return i.src && Vg ? (o = !0, i.decode().then(function() {
    a && e();
  }).catch(function(s) {
    a && (r ? e() : n());
  })) : l.push(vr(i, Se.ERROR, n)), function() {
    a = !1, l.forEach($e);
  };
}
function ZS(t, e) {
  return new Promise((n, i) => {
    function a() {
      r(), n(t);
    }
    function o() {
      r(), i(new Error("Image load error"));
    }
    function r() {
      t.removeEventListener("load", a), t.removeEventListener("error", o);
    }
    t.addEventListener("load", a), t.addEventListener("error", o);
  });
}
function KS(t, e) {
  return e && (t.src = e), t.src && Vg ? new Promise(
    (n, i) => t.decode().then(() => n(t)).catch(
      (a) => t.complete && t.width ? n(t) : i(a)
    )
  ) : ZS(t);
}
class qS {
  constructor() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let e = 0;
      for (const n in this.cache_) {
        const i = this.cache_[n];
        (e++ & 3) === 0 && !i.hasListener() && (delete this.cache_[n], delete this.patternCache_[n], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(e, n, i) {
    const a = Il(e, n, i);
    return a in this.cache_ ? this.cache_[a] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(e, n, i) {
    const a = Il(e, n, i);
    return a in this.patternCache_ ? this.patternCache_[a] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(e, n, i, a, o) {
    const r = Il(e, n, i), l = r in this.cache_;
    this.cache_[r] = a, o && (a.getImageState() === Me.IDLE && a.load(), a.getImageState() === Me.LOADING ? a.ready().then(() => {
      this.patternCache_[r] = Sr().createPattern(
        a.getImage(1),
        "repeat"
      );
    }) : this.patternCache_[r] = Sr().createPattern(
      a.getImage(1),
      "repeat"
    )), l || ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(e) {
    this.maxCacheSize_ = e, this.expire();
  }
}
function Il(t, e, n) {
  const i = n ? co(n) : "null";
  return e + ":" + t + ":" + i;
}
const En = new qS();
let Na = null;
class JS extends Wr {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(e, n, i, a, o) {
    super(), this.hitDetectionImage_ = null, this.image_ = e, this.crossOrigin_ = i, this.canvas_ = {}, this.color_ = o, this.imageState_ = a === void 0 ? Me.IDLE : a, this.size_ = e && e.width && e.height ? [e.width, e.height] : null, this.src_ = n, this.tainted_, this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === Me.LOADED) {
      Na || (Na = dt(1, 1, void 0, {
        willReadFrequently: !0
      })), Na.drawImage(this.image_, 0, 0);
      try {
        Na.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        Na = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(Se.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = Me.ERROR, this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = Me.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(e) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(e), this.canvas_[e] ? this.canvas_[e] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(e) {
    return this.replaceColor_(e), this.canvas_[e] ? e : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const e = this.size_[0], n = this.size_[1], i = dt(e, n);
        i.fillRect(0, 0, e, n), this.hitDetectionImage_ = i.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === Me.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = Me.LOADING;
      try {
        this.src_ !== void 0 && (this.image_.src = this.src_);
      } catch {
        this.handleImageError_();
      }
      this.image_ instanceof HTMLImageElement && KS(this.image_, this.src_).then((e) => {
        this.image_ = e, this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(e) {
    if (!this.color_ || this.canvas_[e] || this.imageState_ !== Me.LOADED)
      return;
    const n = this.image_, i = document.createElement("canvas");
    i.width = Math.ceil(n.width * e), i.height = Math.ceil(n.height * e);
    const a = i.getContext("2d");
    a.scale(e, e), a.drawImage(n, 0, 0), a.globalCompositeOperation = "multiply", a.fillStyle = kS(this.color_), a.fillRect(0, 0, i.width / e, i.height / e), a.globalCompositeOperation = "destination-in", a.drawImage(n, 0, 0), this.canvas_[e] = i;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    return this.ready_ || (this.ready_ = new Promise((e) => {
      this.imageState_ === Me.LOADED || this.imageState_ === Me.ERROR ? e() : this.addEventListener(Se.CHANGE, function n() {
        (this.imageState_ === Me.LOADED || this.imageState_ === Me.ERROR) && (this.removeEventListener(Se.CHANGE, n), e());
      });
    })), this.ready_;
  }
}
function Eu(t, e, n, i, a, o) {
  let r = e === void 0 ? void 0 : En.get(e, n, a);
  return r || (r = new JS(
    t,
    t && "src" in t ? t.src || void 0 : e,
    n,
    i,
    a
  ), En.set(e, n, a, r, o)), o && r && !En.getPattern(e, n, a) && En.set(e, n, a, r, o), r;
}
function An(t) {
  return t ? Array.isArray(t) ? wu(t) : typeof t == "object" && "src" in t ? QS(t) : t : null;
}
function QS(t) {
  if (!t.offset || !t.size)
    return En.getPattern(t.src, "anonymous", t.color);
  const e = t.src + ":" + t.offset, n = En.getPattern(
    e,
    void 0,
    t.color
  );
  if (n)
    return n;
  const i = En.get(t.src, "anonymous", null);
  if (i.getImageState() !== Me.LOADED)
    return null;
  const a = dt(
    t.size[0],
    t.size[1]
  );
  return a.drawImage(
    i.getImage(1),
    t.offset[0],
    t.offset[1],
    t.size[0],
    t.size[1],
    0,
    0,
    t.size[0],
    t.size[1]
  ), Eu(
    a.canvas,
    e,
    void 0,
    Me.LOADED,
    t.color,
    !0
  ), En.getPattern(e, void 0, t.color);
}
const Jo = "ol-hidden", eb = "ol-selectable", Jr = "ol-unselectable", Au = "ol-control", pd = "ol-collapsed", tb = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
), _d = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], kg = function(t) {
  const e = t.match(tb);
  if (!e)
    return null;
  const n = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let i = 0, a = _d.length; i < a; ++i) {
    const o = e[i + 1];
    o !== void 0 && (n[_d[i]] = o);
  }
  return n.families = n.family.split(/,\s?/), n;
}, Og = "10px sans-serif", It = "#000", xa = "round", ti = [], ni = 0, Pa = "round", ho = 10, fo = "#000", go = "center", Mr = "middle", Oi = [0, 0, 0, 0], mo = 1, Hn = new _n();
let aa = null, us;
const cs = {}, nb = function() {
  const e = "32px ", n = ["monospace", "serif"], i = n.length, a = "wmytzilWMYTZIL@#/&?$%10";
  let o, r;
  function l(u, c, d) {
    let h = !0;
    for (let f = 0; f < i; ++f) {
      const g = n[f];
      if (r = xr(
        u + " " + c + " " + e + g,
        a
      ), d != g) {
        const m = xr(
          u + " " + c + " " + e + d + "," + g,
          a
        );
        h = h && m != r;
      }
    }
    return !!h;
  }
  function s() {
    let u = !0;
    const c = Hn.getKeys();
    for (let d = 0, h = c.length; d < h; ++d) {
      const f = c[d];
      Hn.get(f) < 100 && (l.apply(this, f.split(`
`)) ? (Lo(cs), aa = null, us = void 0, Hn.set(f, 100)) : (Hn.set(f, Hn.get(f) + 1, !0), u = !1));
    }
    u && (clearInterval(o), o = void 0);
  }
  return function(u) {
    const c = kg(u);
    if (!c)
      return;
    const d = c.families;
    for (let h = 0, f = d.length; h < f; ++h) {
      const g = d[h], m = c.style + `
` + c.weight + `
` + g;
      Hn.get(m) === void 0 && (Hn.set(m, 100, !0), l(c.style, c.weight, g) || (Hn.set(m, 0, !0), o === void 0 && (o = setInterval(s, 32))));
    }
  };
}(), ib = /* @__PURE__ */ function() {
  let t;
  return function(e) {
    let n = cs[e];
    if (n == null) {
      if (Lg) {
        const i = kg(e), a = Dg(e, "g");
        n = (isNaN(Number(i.lineHeight)) ? 1.2 : Number(i.lineHeight)) * (a.actualBoundingBoxAscent + a.actualBoundingBoxDescent);
      } else
        t || (t = document.createElement("div"), t.innerHTML = "M", t.style.minHeight = "0", t.style.maxHeight = "none", t.style.height = "auto", t.style.padding = "0", t.style.border = "none", t.style.position = "absolute", t.style.display = "block", t.style.left = "-99999px"), t.style.font = e, document.body.appendChild(t), n = t.offsetHeight, document.body.removeChild(t);
      cs[e] = n;
    }
    return n;
  };
}();
function Dg(t, e) {
  return aa || (aa = dt(1, 1)), t != us && (aa.font = t, us = aa.font), aa.measureText(e);
}
function xr(t, e) {
  return Dg(t, e).width;
}
function Sd(t, e, n) {
  if (e in n)
    return n[e];
  const i = e.split(`
`).reduce((a, o) => Math.max(a, xr(t, o)), 0);
  return n[e] = i, i;
}
function ab(t, e) {
  const n = [], i = [], a = [];
  let o = 0, r = 0, l = 0, s = 0;
  for (let u = 0, c = e.length; u <= c; u += 2) {
    const d = e[u];
    if (d === `
` || u === c) {
      o = Math.max(o, r), a.push(r), r = 0, l += s, s = 0;
      continue;
    }
    const h = e[u + 1] || t.font, f = xr(h, d);
    n.push(f), r += f;
    const g = ib(h);
    i.push(g), s = Math.max(s, g);
  }
  return { width: o, height: l, widths: n, heights: i, lineWidths: a };
}
function ob(t, e, n, i, a, o, r, l, s, u, c) {
  t.save(), n !== 1 && (t.globalAlpha === void 0 ? t.globalAlpha = (d) => d.globalAlpha *= n : t.globalAlpha *= n), e && t.transform.apply(t, e), /** @type {*} */
  i.contextInstructions ? (t.translate(s, u), t.scale(c[0], c[1]), rb(
    /** @type {Label} */
    i,
    t
  )) : c[0] < 0 || c[1] < 0 ? (t.translate(s, u), t.scale(c[0], c[1]), t.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    i,
    a,
    o,
    r,
    l,
    0,
    0,
    r,
    l
  )) : t.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    i,
    a,
    o,
    r,
    l,
    s,
    u,
    r * c[0],
    l * c[1]
  ), t.restore();
}
function rb(t, e) {
  const n = t.contextInstructions;
  for (let i = 0, a = n.length; i < a; i += 2)
    Array.isArray(n[i + 1]) ? e[n[i]].apply(
      e,
      n[i + 1]
    ) : e[n[i]] = n[i + 1];
}
class Qr extends Kr {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super({
      opacity: 1,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      scale: e.scale !== void 0 ? e.scale : 1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    }), this.canvases_, this.hitDetectionCanvas_ = null, this.fill_ = e.fill !== void 0 ? e.fill : null, this.origin_ = [0, 0], this.points_ = e.points, this.radius_ = e.radius, this.radius2_ = e.radius2, this.angle_ = e.angle !== void 0 ? e.angle : 0, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? Me.LOADING : Me.LOADED, this.imageState_ === Me.LOADING && this.ready().then(() => this.imageState_ = Me.LOADED), this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), n = new Qr({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return n.setOpacity(this.getOpacity()), n;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const e = this.size_, n = this.getDisplacement(), i = this.getScaleArray();
    return [
      e[0] / 2 - n[0] / i[0],
      e[1] / 2 + n[1] / i[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
      this.renderOptions_
    )), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(e) {
    let n = this.canvases_[e];
    if (!n) {
      const i = this.renderOptions_, a = dt(
        i.size * e,
        i.size * e
      );
      this.draw_(i, a, e), n = a.canvas, this.canvases_[e] = n;
    }
    return n;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return e;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(e, n, i) {
    if (n === 0 || this.points_ === 1 / 0 || e !== "bevel" && e !== "miter")
      return n;
    let a = this.radius_, o = this.radius2_ === void 0 ? a : this.radius2_;
    if (a < o) {
      const P = a;
      a = o, o = P;
    }
    const r = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, l = 2 * Math.PI / r, s = o * Math.sin(l), u = Math.sqrt(o * o - s * s), c = a - u, d = Math.sqrt(s * s + c * c), h = d / s;
    if (e === "miter" && h <= i)
      return h * n;
    const f = n / 2 / h, g = n / 2 * (c / d), v = Math.sqrt((a + f) * (a + f) + g * g) - a;
    if (this.radius2_ === void 0 || e === "bevel")
      return v * 2;
    const y = a * Math.sin(l), C = Math.sqrt(a * a - y * y), M = o - C, b = Math.sqrt(y * y + M * M) / y;
    if (b <= i) {
      const P = b * n / 2 - o - a;
      return 2 * Math.max(v, P);
    }
    return v * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let e = xa, n = Pa, i = 0, a = null, o = 0, r, l = 0;
    this.stroke_ && (r = An(this.stroke_.getColor() ?? fo), l = this.stroke_.getWidth() ?? mo, a = this.stroke_.getLineDash(), o = this.stroke_.getLineDashOffset() ?? 0, n = this.stroke_.getLineJoin() ?? Pa, e = this.stroke_.getLineCap() ?? xa, i = this.stroke_.getMiterLimit() ?? ho);
    const s = this.calculateLineJoinSize_(n, l, i), u = Math.max(this.radius_, this.radius2_ || 0), c = Math.ceil(2 * u + s);
    return {
      strokeStyle: r,
      strokeWidth: l,
      size: c,
      lineCap: e,
      lineDash: a,
      lineDashOffset: o,
      lineJoin: n,
      miterLimit: i
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const e = this.renderOptions_.size;
    this.canvases_ = {}, this.hitDetectionCanvas_ = null, this.size_ = [e, e];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(e, n, i) {
    if (n.scale(i, i), n.translate(e.size / 2, e.size / 2), this.createPath_(n), this.fill_) {
      let a = this.fill_.getColor();
      a === null && (a = It), n.fillStyle = An(a), n.fill();
    }
    e.strokeStyle && (n.strokeStyle = e.strokeStyle, n.lineWidth = e.strokeWidth, e.lineDash && (n.setLineDash(e.lineDash), n.lineDashOffset = e.lineDashOffset), n.lineCap = e.lineCap, n.lineJoin = e.lineJoin, n.miterLimit = e.miterLimit, n.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(e) {
    let n;
    if (this.fill_) {
      let i = this.fill_.getColor(), a = 0;
      typeof i == "string" && (i = co(i)), i === null ? a = 1 : Array.isArray(i) && (a = i.length === 4 ? i[3] : 1), a === 0 && (n = dt(e.size, e.size), this.drawHitDetectionCanvas_(e, n));
    }
    return n ? n.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(e) {
    let n = this.points_;
    const i = this.radius_;
    if (n === 1 / 0)
      e.arc(0, 0, i, 0, 2 * Math.PI);
    else {
      const a = this.radius2_ === void 0 ? i : this.radius2_;
      this.radius2_ !== void 0 && (n *= 2);
      const o = this.angle_ - Math.PI / 2, r = 2 * Math.PI / n;
      for (let l = 0; l < n; l++) {
        const s = o + l * r, u = l % 2 === 0 ? i : a;
        e.lineTo(u * Math.cos(s), u * Math.sin(s));
      }
      e.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(e, n) {
    n.translate(e.size / 2, e.size / 2), this.createPath_(n), n.fillStyle = It, n.fill(), e.strokeStyle && (n.strokeStyle = e.strokeStyle, n.lineWidth = e.strokeWidth, e.lineDash && (n.setLineDash(e.lineDash), n.lineDashOffset = e.lineDashOffset), n.lineJoin = e.lineJoin, n.miterLimit = e.miterLimit, n.stroke());
  }
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}
class el extends Qr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || { radius: 5 }, super({
      points: 1 / 0,
      fill: e.fill,
      radius: e.radius,
      stroke: e.stroke,
      scale: e.scale !== void 0 ? e.scale : 1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), n = new el({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return n.setOpacity(this.getOpacity()), n;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(e) {
    this.radius_ = e, this.render();
  }
}
class Fo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.patternImage_ = null, this.color_ = null, e.color !== void 0 && this.setColor(e.color);
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new Fo({
      color: Array.isArray(e) ? e.slice() : e || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(e) {
    if (e !== null && typeof e == "object" && "src" in e) {
      const n = Eu(
        null,
        e.src,
        "anonymous",
        void 0,
        e.offset ? null : e.color ? e.color : null,
        !(e.offset && e.size)
      );
      n.ready().then(() => {
        this.patternImage_ = null;
      }), n.getImageState() === Me.IDLE && n.load(), n.getImageState() === Me.LOADING && (this.patternImage_ = n);
    }
    this.color_ = e;
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}
class tl {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.color_ = e.color !== void 0 ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = e.lineDash !== void 0 ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new tl({
      color: Array.isArray(e) ? e.slice() : e || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(e) {
    this.color_ = e;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(e) {
    this.lineCap_ = e;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(e) {
    this.lineDash_ = e;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(e) {
    this.lineDashOffset_ = e;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(e) {
    this.lineJoin_ = e;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(e) {
    this.miterLimit_ = e;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(e) {
    this.width_ = e;
  }
}
class _i {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(e) {
    e = e || {}, this.geometry_ = null, this.geometryFunction_ = bd, e.geometry !== void 0 && this.setGeometry(e.geometry), this.fill_ = e.fill !== void 0 ? e.fill : null, this.image_ = e.image !== void 0 ? e.image : null, this.renderer_ = e.renderer !== void 0 ? e.renderer : null, this.hitDetectionRenderer_ = e.hitDetectionRenderer !== void 0 ? e.hitDetectionRenderer : null, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.text_ = e.text !== void 0 ? e.text : null, this.zIndex_ = e.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let e = this.getGeometry();
    return e && typeof e == "object" && (e = /** @type {import("../geom/Geometry.js").default} */
    e.clone()), new _i({
      geometry: e ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(e) {
    this.renderer_ = e;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(e) {
    this.hitDetectionRenderer_ = e;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(e) {
    typeof e == "function" ? this.geometryFunction_ = e : typeof e == "string" ? this.geometryFunction_ = function(n) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        n.get(e)
      );
    } : e ? e !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e
      );
    }) : this.geometryFunction_ = bd, this.geometry_ = e;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(e) {
    this.zIndex_ = e;
  }
}
function lb(t) {
  let e;
  if (typeof t == "function")
    e = t;
  else {
    let n;
    Array.isArray(t) ? n = t : (Ee(
      typeof /** @type {?} */
      t.getZIndex == "function",
      "Expected an `Style` or an array of `Style`"
    ), n = [
      /** @type {Style} */
      t
    ]), e = function() {
      return n;
    };
  }
  return e;
}
let zl = null;
function Gg(t, e) {
  if (!zl) {
    const n = new Fo({
      color: "rgba(255,255,255,0.4)"
    }), i = new tl({
      color: "#3399CC",
      width: 1.25
    });
    zl = [
      new _i({
        image: new el({
          fill: n,
          stroke: i,
          radius: 5
        }),
        fill: n,
        stroke: i
      })
    ];
  }
  return zl;
}
function bd(t) {
  return t.getGeometry();
}
function Md(t, e, n, i) {
  return n !== void 0 && i !== void 0 ? [n / t, i / e] : n !== void 0 ? n / t : i !== void 0 ? i / e : 1;
}
class ko extends Kr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const n = e.opacity !== void 0 ? e.opacity : 1, i = e.rotation !== void 0 ? e.rotation : 0, a = e.scale !== void 0 ? e.scale : 1, o = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
    super({
      opacity: n,
      rotation: i,
      scale: a,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      rotateWithView: o,
      declutterMode: e.declutterMode
    }), this.anchor_ = e.anchor !== void 0 ? e.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = e.anchorOrigin !== void 0 ? e.anchorOrigin : "top-left", this.anchorXUnits_ = e.anchorXUnits !== void 0 ? e.anchorXUnits : "fraction", this.anchorYUnits_ = e.anchorYUnits !== void 0 ? e.anchorYUnits : "fraction", this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null;
    const r = e.img !== void 0 ? e.img : null;
    let l = e.src;
    Ee(
      !(l !== void 0 && r),
      "`image` and `src` cannot be provided at the same time"
    ), (l === void 0 || l.length === 0) && r && (l = /** @type {HTMLImageElement} */
    r.src || Ve(r)), Ee(
      l !== void 0 && l.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    ), Ee(
      !((e.width !== void 0 || e.height !== void 0) && e.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let s;
    if (e.src !== void 0 ? s = Me.IDLE : r !== void 0 && ("complete" in r ? r.complete ? s = r.src ? Me.LOADED : Me.IDLE : s = Me.LOADING : s = Me.LOADED), this.color_ = e.color !== void 0 ? co(e.color) : null, this.iconImage_ = Eu(
      r,
      /** @type {string} */
      l,
      this.crossOrigin_,
      s,
      this.color_
    ), this.offset_ = e.offset !== void 0 ? e.offset : [0, 0], this.offsetOrigin_ = e.offsetOrigin !== void 0 ? e.offsetOrigin : "top-left", this.origin_ = null, this.size_ = e.size !== void 0 ? e.size : null, e.width !== void 0 || e.height !== void 0) {
      let u, c;
      if (e.size)
        [u, c] = e.size;
      else {
        const d = this.getImage(1);
        if (d.width && d.height)
          u = d.width, c = d.height;
        else if (d instanceof HTMLImageElement) {
          this.initialOptions_ = e;
          const h = () => {
            if (this.unlistenImageChange(h), !this.initialOptions_)
              return;
            const f = this.iconImage_.getSize();
            this.setScale(
              Md(
                f[0],
                f[1],
                e.width,
                e.height
              )
            );
          };
          this.listenImageChange(h);
          return;
        }
      }
      u !== void 0 && this.setScale(
        Md(u, c, e.width, e.height)
      );
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    let e, n, i;
    return this.initialOptions_ ? (n = this.initialOptions_.width, i = this.initialOptions_.height) : (e = this.getScale(), e = Array.isArray(e) ? e.slice() : e), new ko({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: e,
      width: n,
      height: i,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let e = this.normalizedAnchor_;
    if (!e) {
      e = this.anchor_;
      const a = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!a)
          return null;
        e = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (e[0] *= a[0]), this.anchorYUnits_ == "fraction" && (e[1] *= a[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!a)
          return null;
        e === this.anchor_ && (e = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (e[0] = -e[0] + a[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (e[1] = -e[1] + a[1]);
      }
      this.normalizedAnchor_ = e;
    }
    const n = this.getDisplacement(), i = this.getScaleArray();
    return [
      e[0] - n[0] / i[0],
      e[1] + n[1] / i[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(e) {
    this.anchor_ = e, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   */
  getImage(e) {
    return this.iconImage_.getImage(e);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(e) {
    return this.iconImage_.getPixelRatio(e);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let e = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const n = this.getSize(), i = this.iconImage_.getSize();
      if (!n || !i)
        return null;
      e = e.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (e[0] = i[0] - n[0] - e[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (e[1] = i[1] - n[1] - e[1]);
    }
    return this.origin_ = e, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[0] * e[0];
    if (this.iconImage_.getImageState() == Me.LOADED)
      return this.iconImage_.getSize()[0] * e[0];
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[1] * e[1];
    if (this.iconImage_.getImageState() == Me.LOADED)
      return this.iconImage_.getSize()[1] * e[1];
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    delete this.initialOptions_, super.setScale(e);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    this.iconImage_.addEventListener(Se.CHANGE, e);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    this.iconImage_.removeEventListener(Se.CHANGE, e);
  }
  ready() {
    return this.iconImage_.ready();
  }
}
const sb = "#333";
class Ru {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.scale_ = e.scale, this.scaleArray_ = Dt(e.scale !== void 0 ? e.scale : 1), this.text_ = e.text, this.textAlign_ = e.textAlign, this.justify_ = e.justify, this.repeat_ = e.repeat, this.textBaseline_ = e.textBaseline, this.fill_ = e.fill !== void 0 ? e.fill : new Fo({ color: sb }), this.maxAngle_ = e.maxAngle !== void 0 ? e.maxAngle : Math.PI / 4, this.placement_ = e.placement !== void 0 ? e.placement : "point", this.overflow_ = !!e.overflow, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.offsetX_ = e.offsetX !== void 0 ? e.offsetX : 0, this.offsetY_ = e.offsetY !== void 0 ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = e.padding === void 0 ? null : e.padding, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new Ru({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(e) {
    this.overflow_ = e;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(e) {
    this.font_ = e;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(e) {
    this.maxAngle_ = e;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(e) {
    this.offsetX_ = e;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(e) {
    this.offsetY_ = e;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(e) {
    this.placement_ = e;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(e) {
    this.repeat_ = e;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = Dt(e !== void 0 ? e : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(e) {
    this.textAlign_ = e;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(e) {
    this.justify_ = e;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(e) {
    this.textBaseline_ = e;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(e) {
    this.backgroundFill_ = e;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(e) {
    this.backgroundStroke_ = e;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(e) {
    this.padding_ = e;
  }
}
let Yi = 0;
const La = 0, qe = 1 << Yi++, ue = 1 << Yi++, kt = 1 << Yi++, rt = 1 << Yi++, zn = 1 << Yi++, qa = 1 << Yi++, gt = Math.pow(2, Yi) - 1, Ng = {
  [qe]: "boolean",
  [ue]: "number",
  [kt]: "string",
  [rt]: "color",
  [zn]: "number[]",
  [qa]: "size"
}, ub = Object.keys(Ng).map(Number).sort(ei);
function Ct(t) {
  const e = [];
  for (const n of ub)
    cb(t, n) && e.push(Ng[n]);
  return e.length === 0 ? "untyped" : e.length < 3 ? e.join(" or ") : e.slice(0, -1).join(", ") + ", or " + e[e.length - 1];
}
function cb(t, e) {
  return (t & e) === e;
}
function Ln(t, e) {
  return !!(t & e);
}
function nl(t, e) {
  return t === e;
}
class yi {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
}
class db {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(e, n, ...i) {
    this.type = e, this.operator = n, this.args = i;
  }
}
function Wg() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: !1,
    geometryType: !1,
    style: {}
  };
}
function hb(t) {
  switch (t) {
    case "string":
      return kt;
    case "color":
      return rt;
    case "number":
      return ue;
    case "boolean":
      return qe;
    case "number[]":
      return zn;
    default:
      throw new Error(`Unrecognized type hint: ${t}`);
  }
}
function Le(t, e, n) {
  switch (typeof t) {
    case "boolean":
      return new yi(qe, t);
    case "number":
      return new yi(
        n === qa ? qa : ue,
        t
      );
    case "string": {
      let a = kt;
      return NS(t) && (a |= rt), nl(a & n, La) || (a &= n), new yi(a, t);
    }
  }
  if (!Array.isArray(t))
    throw new Error("Expression must be an array or a primitive value");
  if (t.length === 0)
    throw new Error("Empty expression");
  if (typeof t[0] == "string")
    return xb(t, e, n);
  for (const a of t)
    if (typeof a != "number")
      throw new Error("Expected an array of numbers");
  let i = zn;
  return t.length === 2 ? i |= qa : (t.length === 3 || t.length === 4) && (i |= rt), n && (i &= n), new yi(i, t);
}
const N = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string"
}, fb = {
  [N.Get]: _e(
    ([t, e]) => e !== void 0 ? hb(
      /** @type {string} */
      /** @type {LiteralExpression} */
      e.value
    ) : gt,
    be(1, 2),
    gb
  ),
  [N.Var]: _e(
    ([t]) => t.type,
    be(1, 1),
    mb
  ),
  [N.Id]: _e(ue | kt, Wa, vb),
  [N.Concat]: _e(
    kt,
    be(2, 1 / 0),
    Te(gt)
  ),
  [N.GeometryType]: _e(kt, Wa, yb),
  [N.Resolution]: _e(ue, Wa),
  [N.Zoom]: _e(ue, Wa),
  [N.Time]: _e(ue, Wa),
  [N.Any]: _e(
    qe,
    be(2, 1 / 0),
    Te(qe)
  ),
  [N.All]: _e(
    qe,
    be(2, 1 / 0),
    Te(qe)
  ),
  [N.Not]: _e(
    qe,
    be(1, 1),
    Te(qe)
  ),
  [N.Equal]: _e(
    qe,
    be(2, 2),
    Te(gt),
    ci
  ),
  [N.NotEqual]: _e(
    qe,
    be(2, 2),
    Te(gt),
    ci
  ),
  [N.GreaterThan]: _e(
    qe,
    be(2, 2),
    Te(gt),
    ci
  ),
  [N.GreaterThanOrEqualTo]: _e(
    qe,
    be(2, 2),
    Te(gt),
    ci
  ),
  [N.LessThan]: _e(
    qe,
    be(2, 2),
    Te(gt),
    ci
  ),
  [N.LessThanOrEqualTo]: _e(
    qe,
    be(2, 2),
    Te(gt),
    ci
  ),
  [N.Multiply]: _e(
    (t) => {
      let e = ue | rt;
      for (let n = 0; n < t.length; n++)
        e &= t[n].type;
      return e;
    },
    be(2, 1 / 0),
    Te(ue | rt),
    ci
  ),
  [N.Coalesce]: _e(
    (t) => {
      let e = gt;
      for (let n = 1; n < t.length; n += 2)
        e &= t[n].type;
      return e &= t[t.length - 1].type, e;
    },
    be(2, 1 / 0),
    Te(gt),
    ci
  ),
  [N.Divide]: _e(
    ue,
    be(2, 2),
    Te(ue)
  ),
  [N.Add]: _e(
    ue,
    be(2, 1 / 0),
    Te(ue)
  ),
  [N.Subtract]: _e(
    ue,
    be(2, 2),
    Te(ue)
  ),
  [N.Clamp]: _e(
    ue,
    be(3, 3),
    Te(ue)
  ),
  [N.Mod]: _e(
    ue,
    be(2, 2),
    Te(ue)
  ),
  [N.Pow]: _e(
    ue,
    be(2, 2),
    Te(ue)
  ),
  [N.Abs]: _e(
    ue,
    be(1, 1),
    Te(ue)
  ),
  [N.Floor]: _e(
    ue,
    be(1, 1),
    Te(ue)
  ),
  [N.Ceil]: _e(
    ue,
    be(1, 1),
    Te(ue)
  ),
  [N.Round]: _e(
    ue,
    be(1, 1),
    Te(ue)
  ),
  [N.Sin]: _e(
    ue,
    be(1, 1),
    Te(ue)
  ),
  [N.Cos]: _e(
    ue,
    be(1, 1),
    Te(ue)
  ),
  [N.Atan]: _e(
    ue,
    be(1, 2),
    Te(ue)
  ),
  [N.Sqrt]: _e(
    ue,
    be(1, 1),
    Te(ue)
  ),
  [N.Match]: _e(
    (t) => {
      let e = gt;
      for (let n = 2; n < t.length; n += 2)
        e &= t[n].type;
      return e &= t[t.length - 1].type, e;
    },
    be(4, 1 / 0),
    xd,
    pb
  ),
  [N.Between]: _e(
    qe,
    be(3, 3),
    Te(ue)
  ),
  [N.Interpolate]: _e(
    (t) => {
      let e = rt | ue;
      for (let n = 3; n < t.length; n += 2)
        e &= t[n].type;
      return e;
    },
    be(6, 1 / 0),
    xd,
    _b
  ),
  [N.Case]: _e(
    (t) => {
      let e = gt;
      for (let n = 1; n < t.length; n += 2)
        e &= t[n].type;
      return e &= t[t.length - 1].type, e;
    },
    be(3, 1 / 0),
    Cb,
    Sb
  ),
  [N.In]: _e(qe, be(2, 2), bb),
  [N.Number]: _e(
    ue,
    be(1, 1 / 0),
    Te(gt)
  ),
  [N.String]: _e(
    kt,
    be(1, 1 / 0),
    Te(gt)
  ),
  [N.Array]: _e(
    (t) => t.length === 2 ? zn | qa : t.length === 3 || t.length === 4 ? zn | rt : zn,
    be(1, 1 / 0),
    Te(ue)
  ),
  [N.Color]: _e(
    rt,
    be(1, 4),
    Te(ue)
  ),
  [N.Band]: _e(
    ue,
    be(1, 3),
    Te(ue)
  ),
  [N.Palette]: _e(rt, be(2, 2), Mb),
  [N.ToString]: _e(
    kt,
    be(1, 1),
    Te(qe | ue | kt | rt)
  )
};
function gb(t, e) {
  const n = Le(t[1], e);
  if (!(n instanceof yi))
    throw new Error("Expected a literal argument for get operation");
  if (typeof n.value != "string")
    throw new Error("Expected a string argument for get operation");
  if (e.properties.add(n.value), t.length === 3) {
    const i = Le(t[2], e);
    return [n, i];
  }
  return [n];
}
function mb(t, e, n, i) {
  const a = t[1];
  if (typeof a != "string")
    throw new Error("Expected a string argument for var operation");
  if (e.variables.add(a), !("variables" in e.style) || e.style.variables[a] === void 0)
    return [new yi(gt, a)];
  const o = e.style.variables[a], r = (
    /** @type {LiteralExpression} */
    Le(o, e)
  );
  if (r.value = a, i && !Ln(i, r.type))
    throw new Error(
      `The variable ${a} has type ${Ct(
        r.type
      )} but the following type was expected: ${Ct(i)}`
    );
  return [r];
}
function vb(t, e) {
  e.featureId = !0;
}
function yb(t, e) {
  e.geometryType = !0;
}
function Wa(t, e) {
  const n = t[0];
  if (t.length !== 1)
    throw new Error(`Expected no arguments for ${n} operation`);
  return [];
}
function be(t, e) {
  return function(n, i) {
    const a = n[0], o = n.length - 1;
    if (t === e) {
      if (o !== t) {
        const r = t === 1 ? "" : "s";
        throw new Error(
          `Expected ${t} argument${r} for ${a}, got ${o}`
        );
      }
    } else if (o < t || o > e) {
      const r = e === 1 / 0 ? `${t} or more` : `${t} to ${e}`;
      throw new Error(
        `Expected ${r} arguments for ${a}, got ${o}`
      );
    }
  };
}
function Te(t) {
  return function(e, n) {
    const i = e[0], a = e.length - 1, o = new Array(a);
    for (let r = 0; r < a; ++r) {
      const l = Le(e[r + 1], n);
      if (!Ln(t, l.type)) {
        const s = Ct(t), u = Ct(l.type);
        throw new Error(
          `Unexpected type for argument ${r} of ${i} operation, got ${s} but expected ${u}`
        );
      }
      l.type &= t, o[r] = l;
    }
    return o;
  };
}
function ci(t, e, n) {
  const i = t[0], a = t.length - 1;
  let o = gt;
  for (let l = 0; l < n.length; ++l)
    o &= n[l].type;
  if (o === La)
    throw new Error(
      `No common type could be found for arguments of ${i} operation`
    );
  const r = new Array(a);
  for (let l = 0; l < a; ++l)
    r[l] = Le(t[l + 1], e, o);
  return r;
}
function Cb(t, e) {
  const n = t[0], i = t.length - 1;
  if (i % 2 === 0)
    throw new Error(
      `An odd amount of arguments was expected for operation ${n}, got ${JSON.stringify(
        i
      )} instead`
    );
}
function xd(t, e) {
  const n = t[0], i = t.length - 1;
  if (i % 2 === 1)
    throw new Error(
      `An even amount of arguments was expected for operation ${n}, got ${JSON.stringify(
        i
      )} instead`
    );
}
function pb(t, e, n, i) {
  const a = t.length - 1;
  let r = Le(t[1], e).type;
  const l = Le(t[t.length - 1], e);
  let s = i !== void 0 ? i & l.type : l.type;
  const u = new Array(a - 2);
  for (let d = 0; d < a - 2; d += 2) {
    const h = Le(t[d + 2], e), f = Le(t[d + 3], e);
    r &= h.type, s &= f.type, u[d] = h, u[d + 1] = f;
  }
  const c = kt | ue | qe;
  if (!Ln(c, r))
    throw new Error(
      `Expected an input of type ${Ct(
        c
      )} for the interpolate operation, got ${Ct(r)} instead`
    );
  if (r &= c, nl(s, La))
    throw new Error(
      "Could not find a common output type for the following match operation: " + JSON.stringify(t)
    );
  for (let d = 0; d < a - 2; d += 2) {
    const h = Le(t[d + 2], e, r), f = Le(t[d + 3], e, s);
    u[d] = h, u[d + 1] = f;
  }
  return [
    Le(t[1], e, r),
    ...u,
    Le(t[t.length - 1], e, s)
  ];
}
function _b(t, e, n, i) {
  const a = t[1];
  let o;
  switch (a[0]) {
    case "linear":
      o = 1;
      break;
    case "exponential":
      if (o = a[1], typeof o != "number")
        throw new Error(
          `Expected a number base for exponential interpolation, got ${JSON.stringify(o)} instead`
        );
      break;
    default:
      o = null;
  }
  if (!o)
    throw new Error(
      `Invalid interpolation type: ${JSON.stringify(a)}`
    );
  o = Le(o, e);
  let r = Le(t[2], e);
  if (!Ln(ue, r.type))
    throw new Error(
      `Expected an input of type number for the interpolate operation, got ${Ct(r.type)} instead`
    );
  r = Le(t[2], e, ue);
  const l = new Array(t.length - 3);
  for (let s = 0; s < l.length; s += 2) {
    let u = Le(t[s + 3], e);
    if (!Ln(ue, u.type))
      throw new Error(
        `Expected all stop input values in the interpolate operation to be of type number, got ${Ct(u.type)} at position ${s + 2} instead`
      );
    let c = Le(t[s + 4], e);
    if (!Ln(ue | rt, c.type))
      throw new Error(
        `Expected all stop output values in the interpolate operation to be a number or color, got ${Ct(c.type)} at position ${s + 3} instead`
      );
    u = Le(t[s + 3], e, ue), c = Le(t[s + 4], e, ue | rt), l[s] = u, l[s + 1] = c;
  }
  return [o, r, ...l];
}
function Sb(t, e, n, i) {
  const a = Le(t[t.length - 1], e, i);
  let o = i !== void 0 ? i & a.type : a.type;
  const r = new Array(t.length - 1);
  for (let l = 0; l < r.length - 1; l += 2) {
    const s = Le(t[l + 1], e), u = Le(t[l + 2], e, i);
    if (!Ln(qe, s.type))
      throw new Error(
        `Expected all conditions in the case operation to be of type boolean, got ${Ct(s.type)} at position ${l} instead`
      );
    o &= u.type, r[l] = s, r[l + 1] = u;
  }
  if (nl(o, La))
    throw new Error(
      "Could not find a common output type for the following case operation: " + JSON.stringify(t)
    );
  for (let l = 0; l < r.length - 1; l += 2)
    r[l + 1] = Le(t[l + 2], e, o);
  return r[r.length - 1] = Le(
    t[t.length - 1],
    e,
    o
  ), r;
}
function bb(t, e) {
  let n = (
    /** @type {any} */
    t[2]
  );
  if (!Array.isArray(n))
    throw new Error(
      'The "in" operator was provided a literal value which was not an array as second argument.'
    );
  if (typeof n[0] == "string") {
    if (n[0] !== "literal")
      throw new Error(
        'For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.'
      );
    if (!Array.isArray(n[1]))
      throw new Error(
        'The "in" operator was provided a literal value which was not an array as second argument.'
      );
    n = n[1];
  }
  let i = kt | ue;
  const a = new Array(n.length);
  for (let r = 0; r < a.length; r++) {
    const l = Le(n[r], e);
    i &= l.type, a[r] = l;
  }
  if (nl(i, La))
    throw new Error(
      "Could not find a common type for the following in operation: " + JSON.stringify(t)
    );
  return [Le(t[1], e, i), ...a];
}
function Mb(t, e) {
  const n = Le(t[1], e, ue);
  if (n.type !== ue)
    throw new Error(
      `The first argument of palette must be an number, got ${Ct(
        n.type
      )} instead`
    );
  const i = t[2];
  if (!Array.isArray(i))
    throw new Error("The second argument of palette must be an array");
  const a = new Array(i.length);
  for (let o = 0; o < a.length; o++) {
    const r = Le(i[o], e, rt);
    if (!(r instanceof yi))
      throw new Error(
        `The palette color at index ${o} must be a literal value`
      );
    if (!Ln(r.type, rt))
      throw new Error(
        `The palette color at index ${o} should be of type color, got ${Ct(
          r.type
        )} instead`
      );
    a[o] = r;
  }
  return [n, ...a];
}
function _e(t, ...e) {
  return function(n, i, a) {
    const o = n[0];
    let r = [];
    for (let s = 0; s < e.length; s++)
      r = e[s](n, i, r, a) || r;
    let l = typeof t == "function" ? t(r) : t;
    if (a !== void 0) {
      if (!Ln(l, a))
        throw new Error(
          `The following expression was expected to return ${Ct(
            a
          )}, but returns ${Ct(l)} instead: ${JSON.stringify(
            n
          )}`
        );
      l &= a;
    }
    if (l === La)
      throw new Error(
        `No matching type was found for the following expression: ${JSON.stringify(
          n
        )}`
      );
    return new db(l, o, ...r);
  };
}
function xb(t, e, n) {
  const i = t[0], a = fb[i];
  if (!a)
    throw new Error(`Unknown operator: ${i}`);
  return a(t, e, n);
}
function $g(t) {
  if (!t)
    return "";
  const e = t.getType();
  switch (e) {
    case "Point":
    case "LineString":
    case "Polygon":
      return e;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        e.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return $g(
        /** @type {import("../geom/GeometryCollection.js").default} */
        t.getGeometries()[0]
      );
    default:
      return "";
  }
}
function Xg() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function si(t, e, n) {
  const i = Le(t, n);
  if (!Ln(e, i.type)) {
    const a = Ct(e), o = Ct(i.type);
    throw new Error(
      `Expected expression to be of type ${a}, got ${o}`
    );
  }
  return mn(i);
}
function mn(t, e) {
  if (t instanceof yi) {
    if (t.type === rt && typeof t.value == "string") {
      const i = Tu(t.value);
      return function() {
        return i;
      };
    }
    return function() {
      return t.value;
    };
  }
  const n = t.operator;
  switch (n) {
    case N.Number:
    case N.String:
    case N.Coalesce:
      return Pb(t);
    case N.Get:
    case N.Var:
      return Tb(t);
    case N.Id:
      return (i) => i.featureId;
    case N.GeometryType:
      return (i) => i.geometryType;
    case N.Concat: {
      const i = t.args.map((a) => mn(a));
      return (a) => "".concat(...i.map((o) => o(a).toString()));
    }
    case N.Resolution:
      return (i) => i.resolution;
    case N.Any:
    case N.All:
    case N.Between:
    case N.In:
    case N.Not:
      return Eb(t);
    case N.Equal:
    case N.NotEqual:
    case N.LessThan:
    case N.LessThanOrEqualTo:
    case N.GreaterThan:
    case N.GreaterThanOrEqualTo:
      return wb(t);
    case N.Multiply:
    case N.Divide:
    case N.Add:
    case N.Subtract:
    case N.Clamp:
    case N.Mod:
    case N.Pow:
    case N.Abs:
    case N.Floor:
    case N.Ceil:
    case N.Round:
    case N.Sin:
    case N.Cos:
    case N.Atan:
    case N.Sqrt:
      return Ab(t);
    case N.Case:
      return Rb(t);
    case N.Match:
      return Ib(t);
    case N.Interpolate:
      return zb(t);
    case N.ToString:
      return Lb(t);
    default:
      throw new Error(`Unsupported operator ${n}`);
  }
}
function Pb(t, e) {
  const n = t.operator, i = t.args.length, a = new Array(i);
  for (let o = 0; o < i; ++o)
    a[o] = mn(t.args[o]);
  switch (n) {
    case N.Coalesce:
      return (o) => {
        for (let r = 0; r < i; ++r) {
          const l = a[r](o);
          if (typeof l < "u" && l !== null)
            return l;
        }
        throw new Error("Expected one of the values to be non-null");
      };
    case N.Number:
    case N.String:
      return (o) => {
        for (let r = 0; r < i; ++r) {
          const l = a[r](o);
          if (typeof l === n)
            return l;
        }
        throw new Error(`Expected one of the values to be a ${n}`);
      };
    default:
      throw new Error(`Unsupported assertion operator ${n}`);
  }
}
function Tb(t, e) {
  const i = (
    /** @type {string} */
    /** @type {LiteralExpression} */
    t.args[0].value
  );
  switch (t.operator) {
    case N.Get:
      return (a) => a.properties[i];
    case N.Var:
      return (a) => a.variables[i];
    default:
      throw new Error(`Unsupported accessor operator ${t.operator}`);
  }
}
function wb(t, e) {
  const n = t.operator, i = mn(t.args[0]), a = mn(t.args[1]);
  switch (n) {
    case N.Equal:
      return (o) => i(o) === a(o);
    case N.NotEqual:
      return (o) => i(o) !== a(o);
    case N.LessThan:
      return (o) => i(o) < a(o);
    case N.LessThanOrEqualTo:
      return (o) => i(o) <= a(o);
    case N.GreaterThan:
      return (o) => i(o) > a(o);
    case N.GreaterThanOrEqualTo:
      return (o) => i(o) >= a(o);
    default:
      throw new Error(`Unsupported comparison operator ${n}`);
  }
}
function Eb(t, e) {
  const n = t.operator, i = t.args.length, a = new Array(i);
  for (let o = 0; o < i; ++o)
    a[o] = mn(t.args[o]);
  switch (n) {
    case N.Any:
      return (o) => {
        for (let r = 0; r < i; ++r)
          if (a[r](o))
            return !0;
        return !1;
      };
    case N.All:
      return (o) => {
        for (let r = 0; r < i; ++r)
          if (!a[r](o))
            return !1;
        return !0;
      };
    case N.Between:
      return (o) => {
        const r = a[0](o), l = a[1](o), s = a[2](o);
        return r >= l && r <= s;
      };
    case N.In:
      return (o) => {
        const r = a[0](o);
        for (let l = 1; l < i; ++l)
          if (r === a[l](o))
            return !0;
        return !1;
      };
    case N.Not:
      return (o) => !a[0](o);
    default:
      throw new Error(`Unsupported logical operator ${n}`);
  }
}
function Ab(t, e) {
  const n = t.operator, i = t.args.length, a = new Array(i);
  for (let o = 0; o < i; ++o)
    a[o] = mn(t.args[o]);
  switch (n) {
    case N.Multiply:
      return (o) => {
        let r = 1;
        for (let l = 0; l < i; ++l)
          r *= a[l](o);
        return r;
      };
    case N.Divide:
      return (o) => a[0](o) / a[1](o);
    case N.Add:
      return (o) => {
        let r = 0;
        for (let l = 0; l < i; ++l)
          r += a[l](o);
        return r;
      };
    case N.Subtract:
      return (o) => a[0](o) - a[1](o);
    case N.Clamp:
      return (o) => {
        const r = a[0](o), l = a[1](o);
        if (r < l)
          return l;
        const s = a[2](o);
        return r > s ? s : r;
      };
    case N.Mod:
      return (o) => a[0](o) % a[1](o);
    case N.Pow:
      return (o) => Math.pow(a[0](o), a[1](o));
    case N.Abs:
      return (o) => Math.abs(a[0](o));
    case N.Floor:
      return (o) => Math.floor(a[0](o));
    case N.Ceil:
      return (o) => Math.ceil(a[0](o));
    case N.Round:
      return (o) => Math.round(a[0](o));
    case N.Sin:
      return (o) => Math.sin(a[0](o));
    case N.Cos:
      return (o) => Math.cos(a[0](o));
    case N.Atan:
      return i === 2 ? (o) => Math.atan2(a[0](o), a[1](o)) : (o) => Math.atan(a[0](o));
    case N.Sqrt:
      return (o) => Math.sqrt(a[0](o));
    default:
      throw new Error(`Unsupported numeric operator ${n}`);
  }
}
function Rb(t, e) {
  const n = t.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = mn(t.args[a]);
  return (a) => {
    for (let o = 0; o < n - 1; o += 2)
      if (i[o](a))
        return i[o + 1](a);
    return i[n - 1](a);
  };
}
function Ib(t, e) {
  const n = t.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = mn(t.args[a]);
  return (a) => {
    const o = i[0](a);
    for (let r = 1; r < n; r += 2)
      if (o === i[r](a))
        return i[r + 1](a);
    return i[n - 1](a);
  };
}
function zb(t, e) {
  const n = t.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = mn(t.args[a]);
  return (a) => {
    const o = i[0](a), r = i[1](a);
    let l, s;
    for (let u = 2; u < n; u += 2) {
      const c = i[u](a);
      let d = i[u + 1](a);
      const h = Array.isArray(d);
      if (h && (d = DS(d)), c >= r)
        return u === 2 ? d : h ? Vb(
          o,
          r,
          l,
          s,
          c,
          d
        ) : ja(
          o,
          r,
          l,
          s,
          c,
          d
        );
      l = c, s = d;
    }
    return s;
  };
}
function Lb(t, e) {
  const n = t.operator, i = t.args.length, a = new Array(i);
  for (let o = 0; o < i; ++o)
    a[o] = mn(t.args[o]);
  switch (n) {
    case N.ToString:
      return (o) => {
        const r = a[0](o);
        return t.args[0].type === rt ? wu(r) : r.toString();
      };
    default:
      throw new Error(`Unsupported convert operator ${n}`);
  }
}
function ja(t, e, n, i, a, o) {
  const r = a - n;
  if (r === 0)
    return i;
  const l = e - n, s = t === 1 ? l / r : (Math.pow(t, l) - 1) / (Math.pow(t, r) - 1);
  return i + s * (o - i);
}
function Vb(t, e, n, i, a, o) {
  if (a - n === 0)
    return i;
  const l = yd(i), s = yd(o);
  let u = s[2] - l[2];
  u > 180 ? u -= 360 : u < -180 && (u += 360);
  const c = [
    ja(t, e, n, l[0], a, s[0]),
    ja(t, e, n, l[1], a, s[1]),
    l[2] + ja(t, e, n, 0, a, u),
    ja(t, e, n, i[3], a, o[3])
  ];
  return Rg(GS(c));
}
function Bb(t) {
  return !0;
}
function Fb(t) {
  const e = Wg(), n = kb(t, e), i = Xg();
  return function(a, o) {
    if (i.properties = a.getPropertiesInternal(), i.resolution = o, e.featureId) {
      const r = a.getId();
      r !== void 0 ? i.featureId = r : i.featureId = null;
    }
    return e.geometryType && (i.geometryType = $g(
      a.getGeometry()
    )), n(i);
  };
}
function Pd(t) {
  const e = Wg(), n = t.length, i = new Array(n);
  for (let r = 0; r < n; ++r)
    i[r] = ds(t[r], e);
  const a = Xg(), o = new Array(n);
  return function(r, l) {
    if (a.properties = r.getPropertiesInternal(), a.resolution = l, e.featureId) {
      const u = r.getId();
      u !== void 0 ? a.featureId = u : a.featureId = null;
    }
    let s = 0;
    for (let u = 0; u < n; ++u) {
      const c = i[u](a);
      c && (o[s] = c, s += 1);
    }
    return o.length = s, o;
  };
}
function kb(t, e) {
  const n = t.length, i = new Array(n);
  for (let a = 0; a < n; ++a) {
    const o = t[a], r = "filter" in o ? si(o.filter, qe, e) : Bb;
    let l;
    if (Array.isArray(o.style)) {
      const s = o.style.length;
      l = new Array(s);
      for (let u = 0; u < s; ++u)
        l[u] = ds(o.style[u], e);
    } else
      l = [ds(o.style, e)];
    i[a] = { filter: r, styles: l };
  }
  return function(a) {
    const o = [];
    let r = !1;
    for (let l = 0; l < n; ++l) {
      const s = i[l].filter;
      if (s(a) && !(t[l].else && r)) {
        r = !0;
        for (const u of i[l].styles) {
          const c = u(a);
          c && o.push(c);
        }
      }
    }
    return o;
  };
}
function ds(t, e) {
  const n = vo(t, "", e), i = yo(t, "", e), a = Ob(t, e), o = Db(t, e), r = Lt(t, "z-index", e);
  if (!n && !i && !a && !o && !ba(t))
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(t)
    );
  const l = new _i();
  return function(s) {
    let u = !0;
    if (n) {
      const c = n(s);
      c && (u = !1), l.setFill(c);
    }
    if (i) {
      const c = i(s);
      c && (u = !1), l.setStroke(c);
    }
    if (a) {
      const c = a(s);
      c && (u = !1), l.setText(c);
    }
    if (o) {
      const c = o(s);
      c && (u = !1), l.setImage(c);
    }
    return r && l.setZIndex(r(s)), u ? null : l;
  };
}
function vo(t, e, n) {
  let i;
  if (e + "fill-pattern-src" in t ? i = $b(t, e + "fill-", n) : i = Iu(
    t,
    e + "fill-color",
    n
  ), !i)
    return null;
  const a = new Fo();
  return function(o) {
    const r = i(o);
    return r === "none" ? null : (a.setColor(r), a);
  };
}
function yo(t, e, n) {
  const i = Lt(
    t,
    e + "stroke-width",
    n
  ), a = Iu(
    t,
    e + "stroke-color",
    n
  );
  if (!i && !a)
    return null;
  const o = Kn(
    t,
    e + "stroke-line-cap",
    n
  ), r = Kn(
    t,
    e + "stroke-line-join",
    n
  ), l = Ug(
    t,
    e + "stroke-line-dash",
    n
  ), s = Lt(
    t,
    e + "stroke-line-dash-offset",
    n
  ), u = Lt(
    t,
    e + "stroke-miter-limit",
    n
  ), c = new tl();
  return function(d) {
    if (a) {
      const h = a(d);
      if (h === "none")
        return null;
      c.setColor(h);
    }
    if (i && c.setWidth(i(d)), o) {
      const h = o(d);
      if (h !== "butt" && h !== "round" && h !== "square")
        throw new Error("Expected butt, round, or square line cap");
      c.setLineCap(h);
    }
    if (r) {
      const h = r(d);
      if (h !== "bevel" && h !== "round" && h !== "miter")
        throw new Error("Expected bevel, round, or miter line join");
      c.setLineJoin(h);
    }
    return l && c.setLineDash(l(d)), s && c.setLineDashOffset(s(d)), u && c.setMiterLimit(u(d)), c;
  };
}
function Ob(t, e) {
  const n = "text-", i = Kn(t, n + "value", e);
  if (!i)
    return null;
  const a = vo(t, n, e), o = vo(
    t,
    n + "background-",
    e
  ), r = yo(t, n, e), l = yo(
    t,
    n + "background-",
    e
  ), s = Kn(t, n + "font", e), u = Lt(
    t,
    n + "max-angle",
    e
  ), c = Lt(
    t,
    n + "offset-x",
    e
  ), d = Lt(
    t,
    n + "offset-y",
    e
  ), h = Co(
    t,
    n + "overflow",
    e
  ), f = Kn(
    t,
    n + "placement",
    e
  ), g = Lt(t, n + "repeat", e), m = il(t, n + "scale", e), v = Co(
    t,
    n + "rotate-with-view",
    e
  ), y = Lt(
    t,
    n + "rotation",
    e
  ), C = Kn(t, n + "align", e), M = Kn(
    t,
    n + "justify",
    e
  ), p = Kn(
    t,
    n + "baseline",
    e
  ), b = Ug(
    t,
    n + "padding",
    e
  ), P = al(
    t,
    n + "declutter-mode"
  ), x = new Ru({ declutterMode: P });
  return function(_) {
    if (x.setText(i(_)), a && x.setFill(a(_)), o && x.setBackgroundFill(o(_)), r && x.setStroke(r(_)), l && x.setBackgroundStroke(l(_)), s && x.setFont(s(_)), u && x.setMaxAngle(u(_)), c && x.setOffsetX(c(_)), d && x.setOffsetY(d(_)), h && x.setOverflow(h(_)), f) {
      const T = f(_);
      if (T !== "point" && T !== "line")
        throw new Error("Expected point or line for text-placement");
      x.setPlacement(T);
    }
    if (g && x.setRepeat(g(_)), m && x.setScale(m(_)), v && x.setRotateWithView(v(_)), y && x.setRotation(y(_)), C) {
      const T = C(_);
      if (T !== "left" && T !== "center" && T !== "right" && T !== "end" && T !== "start")
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      x.setTextAlign(T);
    }
    if (M) {
      const T = M(_);
      if (T !== "left" && T !== "right" && T !== "center")
        throw new Error("Expected left, right, or center for text-justify");
      x.setJustify(T);
    }
    if (p) {
      const T = p(_);
      if (T !== "bottom" && T !== "top" && T !== "middle" && T !== "alphabetic" && T !== "hanging")
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      x.setTextBaseline(T);
    }
    return b && x.setPadding(b(_)), x;
  };
}
function Db(t, e) {
  return "icon-src" in t ? Gb(t, e) : "shape-points" in t ? Nb(t, e) : "circle-radius" in t ? Wb(t, e) : null;
}
function Gb(t, e) {
  const n = "icon-", i = n + "src", a = Yg(t[i], i), o = Pr(
    t,
    n + "anchor",
    e
  ), r = il(t, n + "scale", e), l = Lt(
    t,
    n + "opacity",
    e
  ), s = Pr(
    t,
    n + "displacement",
    e
  ), u = Lt(
    t,
    n + "rotation",
    e
  ), c = Co(
    t,
    n + "rotate-with-view",
    e
  ), d = wd(t, n + "anchor-origin"), h = Ed(
    t,
    n + "anchor-x-units"
  ), f = Ed(
    t,
    n + "anchor-y-units"
  ), g = jb(t, n + "color"), m = Ub(t, n + "cross-origin"), v = Yb(t, n + "offset"), y = wd(t, n + "offset-origin"), C = Tr(t, n + "width"), M = Tr(t, n + "height"), p = Xb(t, n + "size"), b = al(
    t,
    n + "declutter-mode"
  ), P = new ko({
    src: a,
    anchorOrigin: d,
    anchorXUnits: h,
    anchorYUnits: f,
    color: g,
    crossOrigin: m,
    offset: v,
    offsetOrigin: y,
    height: M,
    width: C,
    size: p,
    declutterMode: b
  });
  return function(x) {
    return l && P.setOpacity(l(x)), s && P.setDisplacement(s(x)), u && P.setRotation(u(x)), c && P.setRotateWithView(c(x)), r && P.setScale(r(x)), o && P.setAnchor(o(x)), P;
  };
}
function Nb(t, e) {
  const n = "shape-", i = n + "points", a = n + "radius", o = hs(t[i], i), r = hs(t[a], a), l = vo(t, n, e), s = yo(t, n, e), u = il(t, n + "scale", e), c = Pr(
    t,
    n + "displacement",
    e
  ), d = Lt(
    t,
    n + "rotation",
    e
  ), h = Co(
    t,
    n + "rotate-with-view",
    e
  ), f = Tr(t, n + "radius2"), g = Tr(t, n + "angle"), m = al(
    t,
    n + "declutter-mode"
  ), v = new Qr({
    points: o,
    radius: r,
    radius2: f,
    angle: g,
    declutterMode: m
  });
  return function(y) {
    return l && v.setFill(l(y)), s && v.setStroke(s(y)), c && v.setDisplacement(c(y)), d && v.setRotation(d(y)), h && v.setRotateWithView(h(y)), u && v.setScale(u(y)), v;
  };
}
function Wb(t, e) {
  const n = "circle-", i = vo(t, n, e), a = yo(t, n, e), o = Lt(t, n + "radius", e), r = il(t, n + "scale", e), l = Pr(
    t,
    n + "displacement",
    e
  ), s = Lt(
    t,
    n + "rotation",
    e
  ), u = Co(
    t,
    n + "rotate-with-view",
    e
  ), c = al(
    t,
    n + "declutter-mode"
  ), d = new el({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode: c
  });
  return function(h) {
    return o && d.setRadius(o(h)), i && d.setFill(i(h)), a && d.setStroke(a(h)), l && d.setDisplacement(l(h)), s && d.setRotation(s(h)), u && d.setRotateWithView(u(h)), r && d.setScale(r(h)), d;
  };
}
function Lt(t, e, n) {
  if (!(e in t))
    return;
  const i = si(t[e], ue, n);
  return function(a) {
    return hs(i(a), e);
  };
}
function Kn(t, e, n) {
  if (!(e in t))
    return null;
  const i = si(t[e], kt, n);
  return function(a) {
    return Yg(i(a), e);
  };
}
function $b(t, e, n) {
  const i = Kn(
    t,
    e + "pattern-src",
    n
  ), a = Td(
    t,
    e + "pattern-offset",
    n
  ), o = Td(
    t,
    e + "pattern-size",
    n
  ), r = Iu(
    t,
    e + "color",
    n
  );
  return function(l) {
    return {
      src: i(l),
      offset: a && a(l),
      size: o && o(l),
      color: r && r(l)
    };
  };
}
function Co(t, e, n) {
  if (!(e in t))
    return null;
  const i = si(t[e], qe, n);
  return function(a) {
    const o = i(a);
    if (typeof o != "boolean")
      throw new Error(`Expected a boolean for ${e}`);
    return o;
  };
}
function Iu(t, e, n) {
  if (!(e in t))
    return null;
  const i = si(
    t[e],
    rt | kt,
    n
  );
  return function(a) {
    return jg(i(a), e);
  };
}
function Ug(t, e, n) {
  if (!(e in t))
    return null;
  const i = si(t[e], zn, n);
  return function(a) {
    return Oo(i(a), e);
  };
}
function Pr(t, e, n) {
  if (!(e in t))
    return null;
  const i = si(t[e], zn, n);
  return function(a) {
    const o = Oo(i(a), e);
    if (o.length !== 2)
      throw new Error(`Expected two numbers for ${e}`);
    return o;
  };
}
function Td(t, e, n) {
  if (!(e in t))
    return null;
  const i = si(t[e], zn, n);
  return function(a) {
    return Hg(i(a), e);
  };
}
function il(t, e, n) {
  if (!(e in t))
    return null;
  const i = si(
    t[e],
    zn | ue,
    n
  );
  return function(a) {
    return Hb(i(a), e);
  };
}
function Tr(t, e) {
  const n = t[e];
  if (n !== void 0) {
    if (typeof n != "number")
      throw new Error(`Expected a number for ${e}`);
    return n;
  }
}
function Xb(t, e) {
  const n = t[e];
  if (n !== void 0) {
    if (typeof n == "number")
      return Dt(n);
    if (!Array.isArray(n))
      throw new Error(`Expected a number or size array for ${e}`);
    if (n.length !== 2 || typeof n[0] != "number" || typeof n[1] != "number")
      throw new Error(`Expected a number or size array for ${e}`);
    return n;
  }
}
function Ub(t, e) {
  const n = t[e];
  if (n !== void 0) {
    if (typeof n != "string")
      throw new Error(`Expected a string for ${e}`);
    return n;
  }
}
function wd(t, e) {
  const n = t[e];
  if (n !== void 0) {
    if (n !== "bottom-left" && n !== "bottom-right" && n !== "top-left" && n !== "top-right")
      throw new Error(
        `Expected bottom-left, bottom-right, top-left, or top-right for ${e}`
      );
    return n;
  }
}
function Ed(t, e) {
  const n = t[e];
  if (n !== void 0) {
    if (n !== "pixels" && n !== "fraction")
      throw new Error(`Expected pixels or fraction for ${e}`);
    return n;
  }
}
function Yb(t, e) {
  const n = t[e];
  if (n !== void 0)
    return Oo(n, e);
}
function al(t, e) {
  const n = t[e];
  if (n !== void 0) {
    if (typeof n != "string")
      throw new Error(`Expected a string for ${e}`);
    if (n !== "declutter" && n !== "obstacle" && n !== "none")
      throw new Error(`Expected declutter, obstacle, or none for ${e}`);
    return n;
  }
}
function jb(t, e) {
  const n = t[e];
  if (n !== void 0)
    return jg(n, e);
}
function Oo(t, e) {
  if (!Array.isArray(t))
    throw new Error(`Expected an array for ${e}`);
  const n = t.length;
  for (let i = 0; i < n; ++i)
    if (typeof t[i] != "number")
      throw new Error(`Expected an array of numbers for ${e}`);
  return t;
}
function Yg(t, e) {
  if (typeof t != "string")
    throw new Error(`Expected a string for ${e}`);
  return t;
}
function hs(t, e) {
  if (typeof t != "number")
    throw new Error(`Expected a number for ${e}`);
  return t;
}
function jg(t, e) {
  if (typeof t == "string")
    return t;
  const n = Oo(t, e), i = n.length;
  if (i < 3 || i > 4)
    throw new Error(`Expected a color with 3 or 4 values for ${e}`);
  return n;
}
function Hg(t, e) {
  const n = Oo(t, e);
  if (n.length !== 2)
    throw new Error(`Expected an array of two numbers for ${e}`);
  return n;
}
function Hb(t, e) {
  return typeof t == "number" ? t : Hg(t, e);
}
const Ad = {
  RENDER_ORDER: "renderOrder"
};
class Zg extends Zr {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const n = Object.assign({}, e);
    delete n.style, delete n.renderBuffer, delete n.updateWhileAnimating, delete n.updateWhileInteracting, super(n), this.declutter_ = e.declutter ? String(e.declutter) : void 0, this.renderBuffer_ = e.renderBuffer !== void 0 ? e.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(e.style), this.updateWhileAnimating_ = e.updateWhileAnimating !== void 0 ? e.updateWhileAnimating : !1, this.updateWhileInteracting_ = e.updateWhileInteracting !== void 0 ? e.updateWhileInteracting : !1;
  }
  /**
   * @return {string} Declutter group.
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(Ad.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, n) {
    const i = this.getDeclutter();
    i in e.declutter || (e.declutter[i] = new Eg(9)), this.getRenderer().renderDeclutter(e, n);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(e) {
    this.set(Ad.RENDER_ORDER, e);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(e) {
    this.style_ = e === void 0 ? Gg : e;
    const n = Zb(e);
    this.styleFunction_ = e === null ? void 0 : lb(n), this.changed();
  }
}
function Zb(t) {
  if (t === void 0)
    return Gg;
  if (!t)
    return null;
  if (typeof t == "function" || t instanceof _i)
    return t;
  if (!Array.isArray(t))
    return Pd([t]);
  if (t.length === 0)
    return [];
  const e = t.length, n = t[0];
  if (n instanceof _i) {
    const a = new Array(e);
    for (let o = 0; o < e; ++o) {
      const r = t[o];
      if (!(r instanceof _i))
        throw new Error("Expected a list of style instances");
      a[o] = r;
    }
    return a;
  }
  if ("style" in n) {
    const a = new Array(e);
    for (let o = 0; o < e; ++o) {
      const r = t[o];
      if (!("style" in r))
        throw new Error("Expected a list of rules with a style property");
      a[o] = r;
    }
    return Fb(a);
  }
  return Pd(
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    t
  );
}
class Kb extends ou {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(), this.map_ = e;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, n) {
    Re();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(e) {
    const n = e.viewState, i = e.coordinateToPixelTransform, a = e.pixelToCoordinateTransform;
    ii(
      i,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / n.resolution,
      -1 / n.resolution,
      -n.rotation,
      -n.center[0],
      -n.center[1]
    ), yg(a, i);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(e, n, i, a, o, r, l, s) {
    let u;
    const c = n.viewState;
    function d(p, b, P, x) {
      return o.call(r, b, p ? P : null, x);
    }
    const h = c.projection, f = cg(e.slice(), h), g = [[0, 0]];
    if (h.canWrapX() && a) {
      const p = h.getExtent(), b = ke(p);
      g.push([-b, 0], [b, 0]);
    }
    const m = n.layerStatesArray, v = m.length, y = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), C = [];
    for (let p = 0; p < g.length; p++)
      for (let b = v - 1; b >= 0; --b) {
        const P = m[b], x = P.layer;
        if (x.hasRenderer() && xu(P, c) && l.call(s, x)) {
          const _ = x.getRenderer(), T = x.getSource();
          if (_ && T) {
            const B = T.getWrapX() ? f : e, L = d.bind(
              null,
              P.managed
            );
            C[0] = B[0] + g[p][0], C[1] = B[1] + g[p][1], u = _.forEachFeatureAtCoordinate(
              C,
              n,
              i,
              L,
              y
            );
          }
          if (u)
            return u;
        }
      }
    if (y.length === 0)
      return;
    const M = 1 / y.length;
    return y.forEach((p, b) => p.distanceSq += b * M), y.sort((p, b) => p.distanceSq - b.distanceSq), y.some((p) => u = p.callback(p.feature, p.layer, p.geometry)), u;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(e, n, i, a, o, r) {
    return this.forEachFeatureAtCoordinate(
      e,
      n,
      i,
      a,
      oo,
      this,
      o,
      r
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    Re();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(e) {
    En.canExpireCache() && e.postRenderFunctions.push(qb);
  }
}
function qb(t, e) {
  En.expire();
}
class Kg extends li {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(e, n, i, a) {
    super(e), this.inversePixelTransform = n, this.frameState = i, this.context = a;
  }
}
class Jb extends Kb {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(e), this.fontChangeListenerKey_ = we(
      Hn,
      _a.PROPERTYCHANGE,
      e.redrawText.bind(e)
    ), this.element_ = document.createElement("div");
    const n = this.element_.style;
    n.position = "absolute", n.width = "100%", n.height = "100%", n.zIndex = "0", this.element_.className = Jr + " ol-layers";
    const i = e.getViewport();
    i.insertBefore(this.element_, i.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, n) {
    const i = this.getMap();
    if (i.hasListener(e)) {
      const a = new Kg(e, void 0, n);
      i.dispatchEvent(a);
    }
  }
  disposeInternal() {
    $e(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    if (!e) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(e), this.dispatchRenderEvent(Qt.PRECOMPOSE, e);
    const n = e.layerStatesArray.sort(function(l, s) {
      return l.zIndex - s.zIndex;
    });
    n.some(
      (l) => l.layer instanceof Zg && l.layer.getDeclutter()
    ) && (e.declutter = {});
    const a = e.viewState;
    this.children_.length = 0;
    const o = [];
    let r = null;
    for (let l = 0, s = n.length; l < s; ++l) {
      const u = n[l];
      e.layerIndex = l;
      const c = u.layer, d = c.getSourceState();
      if (!xu(u, a) || d != "ready" && d != "undefined") {
        c.unrender();
        continue;
      }
      const h = c.render(e, r);
      h && (h !== r && (this.children_.push(h), r = h), o.push(u));
    }
    this.declutter(e, o), jS(this.element_, this.children_), this.dispatchRenderEvent(Qt.POSTCOMPOSE, e), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(e);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(e, n) {
    if (e.declutter) {
      for (let i = n.length - 1; i >= 0; --i) {
        const a = n[i], o = a.layer;
        o.getDeclutter() && o.renderDeclutter(e, a);
      }
      n.forEach(
        (i) => i.layer.renderDeferred(e)
      );
    }
  }
}
class vi extends li {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(e, n) {
    super(e), this.layer = n;
  }
}
const Ll = {
  LAYERS: "layers"
};
class Va extends eg {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(e) {
    e = e || {};
    const n = (
      /** @type {Options} */
      Object.assign({}, e)
    );
    delete n.layers;
    let i = e.layers;
    super(n), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(Ll.LAYERS, this.handleLayersChanged_), i ? Array.isArray(i) ? i = new wn(i.slice(), { unique: !0 }) : Ee(
      typeof /** @type {?} */
      i.getArray == "function",
      "Expected `layers` to be an array or a `Collection`"
    ) : i = new wn(void 0, { unique: !0 }), this.setLayers(i);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach($e), this.layersListenerKeys_.length = 0;
    const e = this.getLayers();
    this.layersListenerKeys_.push(
      we(e, Rt.ADD, this.handleLayersAdd_, this),
      we(
        e,
        Rt.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const i in this.listenerKeys_)
      this.listenerKeys_[i].forEach($e);
    Lo(this.listenerKeys_);
    const n = e.getArray();
    for (let i = 0, a = n.length; i < a; i++) {
      const o = n[i];
      this.registerLayerListeners_(o), this.dispatchEvent(new vi("addlayer", o));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(e) {
    const n = [
      we(
        e,
        _a.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      we(e, Se.CHANGE, this.handleLayerChange_, this)
    ];
    e instanceof Va && n.push(
      we(e, "addlayer", this.handleLayerGroupAdd_, this),
      we(e, "removelayer", this.handleLayerGroupRemove_, this)
    ), this.listenerKeys_[Ve(e)] = n;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(e) {
    this.dispatchEvent(new vi("addlayer", e.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(e) {
    this.dispatchEvent(new vi("removelayer", e.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(e) {
    const n = e.element;
    this.registerLayerListeners_(n), this.dispatchEvent(new vi("addlayer", n)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(e) {
    const n = e.element, i = Ve(n);
    this.listenerKeys_[i].forEach($e), delete this.listenerKeys_[i], this.dispatchEvent(new vi("removelayer", n)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(Ll.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(e) {
    const n = this.getLayers();
    if (n) {
      const i = n.getArray();
      for (let a = 0, o = i.length; a < o; ++a)
        this.dispatchEvent(new vi("removelayer", i[a]));
    }
    this.set(Ll.LAYERS, e);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e !== void 0 ? e : [], this.getLayers().forEach(function(n) {
      n.getLayersArray(e);
    }), e;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    const n = e !== void 0 ? e : [], i = n.length;
    this.getLayers().forEach(function(r) {
      r.getLayerStatesArray(n);
    });
    const a = this.getLayerState();
    let o = a.zIndex;
    !e && a.zIndex === void 0 && (o = 0);
    for (let r = i, l = n.length; r < l; r++) {
      const s = n[r];
      s.opacity *= a.opacity, s.visible = s.visible && a.visible, s.maxResolution = Math.min(
        s.maxResolution,
        a.maxResolution
      ), s.minResolution = Math.max(
        s.minResolution,
        a.minResolution
      ), s.minZoom = Math.max(s.minZoom, a.minZoom), s.maxZoom = Math.min(s.maxZoom, a.maxZoom), a.extent !== void 0 && (s.extent !== void 0 ? s.extent = Ka(
        s.extent,
        a.extent
      ) : s.extent = a.extent), s.zIndex === void 0 && (s.zIndex = o);
    }
    return n;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
}
class oa extends li {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(e, n, i) {
    super(e), this.map = n, this.frameState = i !== void 0 ? i : null;
  }
}
class mi extends oa {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(e, n, i, a, o, r) {
    super(e, n, o), this.originalEvent = i, this.pixel_ = null, this.coordinate_ = null, this.dragging = a !== void 0 ? a : !1, this.activePointers = r;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(e) {
    this.pixel_ = e;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(e) {
    this.coordinate_ = e;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const Je = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: Se.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: Se.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, fs = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown"
};
class Qb extends Wr {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(e, n) {
    super(e), this.map_ = e, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = n === void 0 ? 1 : n, this.down_ = null;
    const i = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = i, this.pointerdownListenerKey_ = we(
      i,
      fs.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = we(
      i,
      fs.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      Se.TOUCHMOVE,
      this.boundHandleTouchMove_,
      Bg ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(e) {
    let n = new mi(
      Je.CLICK,
      this.map_,
      e
    );
    this.dispatchEvent(n), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, n = new mi(
      Je.DBLCLICK,
      this.map_,
      e
    ), this.dispatchEvent(n)) : this.clickTimeoutId_ = setTimeout(() => {
      this.clickTimeoutId_ = void 0;
      const i = new mi(
        Je.SINGLECLICK,
        this.map_,
        e
      );
      this.dispatchEvent(i);
    }, 250);
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(e) {
    const n = e, i = n.pointerId;
    if (n.type == Je.POINTERUP || n.type == Je.POINTERCANCEL) {
      delete this.trackedTouches_[i];
      for (const a in this.trackedTouches_)
        if (this.trackedTouches_[a].target !== n.target) {
          delete this.trackedTouches_[a];
          break;
        }
    } else (n.type == Je.POINTERDOWN || n.type == Je.POINTERMOVE) && (this.trackedTouches_[i] = n);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(e) {
    this.updateActivePointers_(e);
    const n = new mi(
      Je.POINTERUP,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(n), this.emulateClicks_ && !n.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(e) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach($e), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(e) {
    return e.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(e) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(e);
    const n = new mi(
      Je.POINTERDOWN,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    if (this.dispatchEvent(n), this.down_ = new PointerEvent(e.type, e), Object.defineProperty(this.down_, "target", {
      writable: !1,
      value: e.target
    }), this.dragListenerKeys_.length === 0) {
      const i = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        we(
          i,
          Je.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        we(i, Je.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        we(
          this.element_,
          Je.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== i && this.dragListenerKeys_.push(
        we(
          this.element_.getRootNode(),
          Je.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.isMoving_(e)) {
      this.updateActivePointers_(e), this.dragging_ = !0;
      const n = new mi(
        Je.POINTERDRAG,
        this.map_,
        e,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(n);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(e) {
    this.originalPointerMoveEvent_ = e;
    const n = !!(this.down_ && this.isMoving_(e));
    this.dispatchEvent(
      new mi(
        Je.POINTERMOVE,
        this.map_,
        e,
        n
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(e) {
    const n = this.originalPointerMoveEvent_;
    (!n || n.defaultPrevented) && (typeof e.cancelable != "boolean" || e.cancelable === !0) && e.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(e) {
    return this.dragging_ || Math.abs(e.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(e.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.relayedListenerKey_ && ($e(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      Se.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && ($e(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach($e), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const Zn = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, mt = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
}, wr = 1 / 0;
class e0 {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(e, n) {
    this.priorityFunction_ = e, this.keyFunction_ = n, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, Lo(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const e = this.elements_, n = this.priorities_, i = e[0];
    e.length == 1 ? (e.length = 0, n.length = 0) : (e[0] = /** @type {T} */
    e.pop(), n[0] = /** @type {number} */
    n.pop(), this.siftUp_(0));
    const a = this.keyFunction_(i);
    return delete this.queuedElements_[a], i;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    Ee(
      !(this.keyFunction_(e) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const n = this.priorityFunction_(e);
    return n != wr ? (this.elements_.push(e), this.priorities_.push(n), this.queuedElements_[this.keyFunction_(e)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(e) {
    return e * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(e) {
    return e * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(e) {
    return e - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let e;
    for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
      this.siftUp_(e);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(e) {
    return e in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(e) {
    return this.isKeyQueued(this.keyFunction_(e));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(e) {
    const n = this.elements_, i = this.priorities_, a = n.length, o = n[e], r = i[e], l = e;
    for (; e < a >> 1; ) {
      const s = this.getLeftChildIndex_(e), u = this.getRightChildIndex_(e), c = u < a && i[u] < i[s] ? u : s;
      n[e] = n[c], i[e] = i[c], e = c;
    }
    n[e] = o, i[e] = r, this.siftDown_(l, e);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(e, n) {
    const i = this.elements_, a = this.priorities_, o = i[n], r = a[n];
    for (; n > e; ) {
      const l = this.getParentIndex_(n);
      if (a[l] > r)
        i[n] = i[l], a[n] = a[l], n = l;
      else
        break;
    }
    i[n] = o, a[n] = r;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const e = this.priorityFunction_, n = this.elements_, i = this.priorities_;
    let a = 0;
    const o = n.length;
    let r, l, s;
    for (l = 0; l < o; ++l)
      r = n[l], s = e(r), s == wr ? delete this.queuedElements_[this.keyFunction_(r)] : (i[a] = s, n[a++] = r);
    n.length = a, i.length = a, this.heapify_();
  }
}
const fe = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
class t0 extends e0 {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(e, n) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(i) {
        return e.apply(null, i);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(i) {
        return (
          /** @type {import("./Tile.js").default} */
          i[0].getKey()
        );
      }
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = n, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    const n = super.enqueue(e);
    return n && e[0].addEventListener(Se.CHANGE, this.boundHandleTileChange_), n;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const n = (
      /** @type {import("./Tile.js").default} */
      e.target
    ), i = n.getState();
    if (i === fe.LOADED || i === fe.ERROR || i === fe.EMPTY) {
      i !== fe.ERROR && n.removeEventListener(Se.CHANGE, this.boundHandleTileChange_);
      const a = n.getKey();
      a in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[a], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(e, n) {
    let i = 0, a, o, r;
    for (; this.tilesLoading_ < e && i < n && this.getCount() > 0; )
      o = /** @type {import("./Tile.js").default} */
      this.dequeue()[0], r = o.getKey(), a = o.getState(), a === fe.IDLE && !(r in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[r] = !0, ++this.tilesLoading_, ++i, o.load());
  }
}
function n0(t, e, n, i, a) {
  if (!t || !(n in t.wantedTiles) || !t.wantedTiles[n][e.getKey()])
    return wr;
  const o = t.viewState.center, r = i[0] - o[0], l = i[1] - o[1];
  return 65536 * Math.log(a) + Math.sqrt(r * r + l * l) / a;
}
class zu extends _n {
  /**
   * @param {Options} options Control options.
   */
  constructor(e) {
    super();
    const n = e.element;
    n && !e.target && !n.style.pointerEvents && (n.style.pointerEvents = "auto"), this.element = n || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], e.render && (this.render = e.render), e.target && this.setTarget(e.target);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    br(this.element), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.map_ && br(this.element);
    for (let n = 0, i = this.listenerKeys.length; n < i; ++n)
      $e(this.listenerKeys[n]);
    this.listenerKeys.length = 0, this.map_ = e, e && ((this.target_ ? this.target_ : e.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== Sa && this.listenerKeys.push(
      we(e, Zn.POSTRENDER, this.render, this)
    ), e.render());
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(e) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(e) {
    this.target_ = typeof e == "string" ? document.getElementById(e) : e;
  }
}
class i0 extends zu {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = e.collapsible !== void 0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1);
    const n = e.className !== void 0 ? e.className : "ol-attribution", i = e.tipLabel !== void 0 ? e.tipLabel : "Attributions", a = e.expandClassName !== void 0 ? e.expandClassName : n + "-expand", o = e.collapseLabel !== void 0 ? e.collapseLabel : "", r = e.collapseClassName !== void 0 ? e.collapseClassName : n + "-collapse";
    typeof o == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = o, this.collapseLabel_.className = r) : this.collapseLabel_ = o;
    const l = e.label !== void 0 ? e.label : "i";
    typeof l == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = l, this.label_.className = a) : this.label_ = l;
    const s = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = i, this.toggleButton_.appendChild(s), this.toggleButton_.addEventListener(
      Se.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const u = n + " " + Jr + " " + Au + (this.collapsed_ && this.collapsible_ ? " " + pd : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element;
    c.className = u, c.appendChild(this.toggleButton_), c.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(e) {
    const n = Array.from(
      new Set(
        this.getMap().getAllLayers().flatMap((a) => a.getAttributions(e))
      )
    ), i = !this.getMap().getAllLayers().some(
      (a) => a.getSource() && a.getSource().getAttributionsCollapsible() === !1
    );
    return this.overrideCollapsible_ || this.setCollapsible(i), n;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(e) {
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const n = await Promise.all(
      this.collectSourceAttributions_(e).map(
        (a) => __(() => a)
      )
    ), i = n.length > 0;
    if (this.renderedVisible_ != i && (this.element.style.display = i ? "" : "none", this.renderedVisible_ = i), !Ei(n, this.renderedAttributions_)) {
      Fg(this.ulElement_);
      for (let a = 0, o = n.length; a < o; ++a) {
        const r = document.createElement("li");
        r.innerHTML = n[a], this.ulElement_.appendChild(r);
      }
      this.renderedAttributions_ = n;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(pd), this.collapsed_ ? Cd(this.collapseLabel_, this.label_) : Cd(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    this.userCollapsed_ = e, !(!this.collapsible_ || this.collapsed_ === e) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.updateElement_(e.frameState);
  }
}
class a0 extends zu {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    });
    const n = e.className !== void 0 ? e.className : "ol-rotate", i = e.label !== void 0 ? e.label : "", a = e.compassClassName !== void 0 ? e.compassClassName : "ol-compass";
    this.label_ = null, typeof i == "string" ? (this.label_ = document.createElement("span"), this.label_.className = a, this.label_.textContent = i) : (this.label_ = i, this.label_.classList.add(a));
    const o = e.tipLabel ? e.tipLabel : "Reset rotation", r = document.createElement("button");
    r.className = n + "-reset", r.setAttribute("type", "button"), r.title = o, r.appendChild(this.label_), r.addEventListener(
      Se.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const l = n + " " + Jr + " " + Au, s = this.element;
    s.className = l, s.appendChild(r), this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.autoHide_ = e.autoHide !== void 0 ? e.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(Jo);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const n = this.getMap().getView();
    if (!n)
      return;
    const i = n.getRotation();
    i !== void 0 && (this.duration_ > 0 && i % (2 * Math.PI) !== 0 ? n.animate({
      rotation: 0,
      duration: this.duration_,
      easing: za
    }) : n.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const n = e.frameState;
    if (!n)
      return;
    const i = n.viewState.rotation;
    if (i != this.rotation_) {
      const a = "rotate(" + i + "rad)";
      if (this.autoHide_) {
        const o = this.element.classList.contains(Jo);
        !o && i === 0 ? this.element.classList.add(Jo) : o && i !== 0 && this.element.classList.remove(Jo);
      }
      this.label_.style.transform = a;
    }
    this.rotation_ = i;
  }
}
class o0 extends zu {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    });
    const n = e.className !== void 0 ? e.className : "ol-zoom", i = e.delta !== void 0 ? e.delta : 1, a = e.zoomInClassName !== void 0 ? e.zoomInClassName : n + "-in", o = e.zoomOutClassName !== void 0 ? e.zoomOutClassName : n + "-out", r = e.zoomInLabel !== void 0 ? e.zoomInLabel : "+", l = e.zoomOutLabel !== void 0 ? e.zoomOutLabel : "", s = e.zoomInTipLabel !== void 0 ? e.zoomInTipLabel : "Zoom in", u = e.zoomOutTipLabel !== void 0 ? e.zoomOutTipLabel : "Zoom out", c = document.createElement("button");
    c.className = a, c.setAttribute("type", "button"), c.title = s, c.appendChild(
      typeof r == "string" ? document.createTextNode(r) : r
    ), c.addEventListener(
      Se.CLICK,
      this.handleClick_.bind(this, i),
      !1
    );
    const d = document.createElement("button");
    d.className = o, d.setAttribute("type", "button"), d.title = u, d.appendChild(
      typeof l == "string" ? document.createTextNode(l) : l
    ), d.addEventListener(
      Se.CLICK,
      this.handleClick_.bind(this, -i),
      !1
    );
    const h = n + " " + Jr + " " + Au, f = this.element;
    f.className = h, f.appendChild(c), f.appendChild(d), this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e, n) {
    n.preventDefault(), this.zoomByDelta_(e);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(e) {
    const i = this.getMap().getView();
    if (!i)
      return;
    const a = i.getZoom();
    if (a !== void 0) {
      const o = i.getConstrainedZoom(a + e);
      this.duration_ > 0 ? (i.getAnimating() && i.cancelAnimations(), i.animate({
        zoom: o,
        duration: this.duration_,
        easing: za
      })) : i.setZoom(o);
    }
  }
}
function r0(t) {
  t = t || {};
  const e = new wn();
  return (t.zoom !== void 0 ? t.zoom : !0) && e.push(new o0(t.zoomOptions)), (t.rotate !== void 0 ? t.rotate : !0) && e.push(new a0(t.rotateOptions)), (t.attribution !== void 0 ? t.attribution : !0) && e.push(new i0(t.attributionOptions)), e;
}
const Rd = {
  ACTIVE: "active"
};
class Do extends _n {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e && e.handleEvent && (this.handleEvent = e.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(Rd.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.set(Rd.ACTIVE, e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    this.map_ = e;
  }
}
function l0(t, e, n) {
  const i = t.getCenterInternal();
  if (i) {
    const a = [i[0] + e[0], i[1] + e[1]];
    t.animateInternal({
      duration: n !== void 0 ? n : 250,
      easing: eS,
      center: t.getConstrainedCenter(a)
    });
  }
}
function Lu(t, e, n, i) {
  const a = t.getZoom();
  if (a === void 0)
    return;
  const o = t.getConstrainedZoom(a + e), r = t.getResolutionForZoom(o);
  t.getAnimating() && t.cancelAnimations(), t.animate({
    resolution: r,
    anchor: n,
    duration: i !== void 0 ? i : 250,
    easing: za
  });
}
class s0 extends Do {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let n = !1;
    if (e.type == Je.DBLCLICK) {
      const i = (
        /** @type {MouseEvent} */
        e.originalEvent
      ), a = e.map, o = e.coordinate, r = i.shiftKey ? -this.delta_ : this.delta_, l = a.getView();
      Lu(l, r, o, this.duration_), i.preventDefault(), n = !0;
    }
    return !n;
  }
}
class Go extends Do {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), e.handleDownEvent && (this.handleDownEvent = e.handleDownEvent), e.handleDragEvent && (this.handleDragEvent = e.handleDragEvent), e.handleMoveEvent && (this.handleMoveEvent = e.handleMoveEvent), e.handleUpEvent && (this.handleUpEvent = e.handleUpEvent), e.stopDown && (this.stopDown = e.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(e) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(e) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    let n = !1;
    if (this.updateTrackedPointers_(e), this.handlingDownUpSequence) {
      if (e.type == Je.POINTERDRAG)
        this.handleDragEvent(e), e.originalEvent.preventDefault();
      else if (e.type == Je.POINTERUP) {
        const i = this.handleUpEvent(e);
        this.handlingDownUpSequence = i && this.targetPointers.length > 0;
      }
    } else if (e.type == Je.POINTERDOWN) {
      const i = this.handleDownEvent(e);
      this.handlingDownUpSequence = i, n = this.stopDown(i);
    } else e.type == Je.POINTERMOVE && this.handleMoveEvent(e);
    return !n;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(e) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(e) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(e) {
    return e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(e) {
    e.activePointers && (this.targetPointers = e.activePointers);
  }
}
function Vu(t) {
  const e = t.length;
  let n = 0, i = 0;
  for (let a = 0; a < e; a++)
    n += t[a].clientX, i += t[a].clientY;
  return { clientX: n / e, clientY: i / e };
}
function gs(t) {
  const e = arguments;
  return function(n) {
    let i = !0;
    for (let a = 0, o = e.length; a < o && (i = i && e[a](n), !!i); ++a)
      ;
    return i;
  };
}
const u0 = function(t) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    t.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, c0 = function(t) {
  const e = t.map.getTargetElement(), n = t.map.getOwnerDocument().activeElement;
  return e.contains(n);
}, qg = function(t) {
  return t.map.getTargetElement().hasAttribute("tabindex") ? c0(t) : !0;
}, d0 = oo, Jg = function(t) {
  const e = (
    /** @type {MouseEvent} */
    t.originalEvent
  );
  return e.button == 0 && !(XS && Ig && e.ctrlKey);
}, Qg = function(t) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    t.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, h0 = function(t) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    t.originalEvent
  );
  return Ig ? e.metaKey : e.ctrlKey;
}, f0 = function(t) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    t.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, em = function(t) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    t.originalEvent
  ), n = (
    /** @type {Element} */
    e.target.tagName
  );
  return n !== "INPUT" && n !== "SELECT" && n !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !e.target.isContentEditable;
}, Vl = function(t) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    t.originalEvent
  );
  return Ee(
    e !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  ), e.pointerType == "mouse";
}, g0 = function(t) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    t.originalEvent
  );
  return Ee(
    e !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  ), e.isPrimary && e.button === 0;
};
class m0 extends Go {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super({
      stopDown: Nr
    }), e = e || {}, this.kinetic_ = e.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const n = e.condition ? e.condition : gs(Qg, g0);
    this.condition_ = e.onFocusOnly ? gs(qg, n) : n, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    const n = e.map;
    this.panning_ || (this.panning_ = !0, n.getView().beginInteraction());
    const i = this.targetPointers, a = n.getEventPixel(Vu(i));
    if (i.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(a[0], a[1]), this.lastCentroid) {
        const o = [
          this.lastCentroid[0] - a[0],
          a[1] - this.lastCentroid[1]
        ], l = e.map.getView();
        N_(o, l.getResolution()), fu(o, l.getRotation()), l.adjustCenterInternal(o);
      }
    } else this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = a, this.lastPointersCount_ = i.length, e.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    const n = e.map, i = n.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const a = this.kinetic_.getDistance(), o = this.kinetic_.getAngle(), r = i.getCenterInternal(), l = n.getPixelFromCoordinateInternal(r), s = n.getCoordinateFromPixelInternal([
          l[0] - a * Math.cos(o),
          l[1] - a * Math.sin(o)
        ]);
        i.animateInternal({
          center: i.getConstrainedCenter(s),
          duration: 500,
          easing: za
        });
      }
      return this.panning_ && (this.panning_ = !1, i.endInteraction()), !1;
    }
    return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length > 0 && this.condition_(e)) {
      const i = e.map.getView();
      return this.lastCentroid = null, i.getAnimating() && i.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    }
    return !1;
  }
}
class v0 extends Go {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      stopDown: Nr
    }), this.condition_ = e.condition ? e.condition : u0, this.lastAngle_ = void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    if (!Vl(e))
      return;
    const n = e.map, i = n.getView();
    if (i.getConstraints().rotation === pu)
      return;
    const a = n.getSize(), o = e.pixel, r = Math.atan2(a[1] / 2 - o[1], o[0] - a[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const l = r - this.lastAngle_;
      i.adjustRotationInternal(-l);
    }
    this.lastAngle_ = r;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return Vl(e) ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return Vl(e) && Jg(e) && this.condition_(e) ? (e.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
}
class y0 extends ou {
  /**
   * @param {string} className CSS class name.
   */
  constructor(e) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + e, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const e = this.startPixel_, n = this.endPixel_, i = "px", a = this.element_.style;
    a.left = Math.min(e[0], n[0]) + i, a.top = Math.min(e[1], n[1]) + i, a.width = Math.abs(n[0] - e[0]) + i, a.height = Math.abs(n[1] - e[1]) + i;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const n = this.element_.style;
      n.left = "inherit", n.top = "inherit", n.width = "inherit", n.height = "inherit";
    }
    this.map_ = e, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(e, n) {
    this.startPixel_ = e, this.endPixel_ = n, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_)
      return;
    const e = this.startPixel_, n = this.endPixel_, a = [
      e,
      [e[0], n[1]],
      n,
      [n[0], e[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    a[4] = a[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([a]) : this.geometry_ = new so([a]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const $a = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class Qo extends li {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(e, n, i) {
    super(e), this.coordinate = n, this.mapBrowserEvent = i;
  }
}
class C0 extends Go {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.box_ = new y0(e.className || "ol-dragbox"), this.minArea_ = e.minArea !== void 0 ? e.minArea : 64, e.onBoxEnd && (this.onBoxEnd = e.onBoxEnd), this.startPixel_ = null, this.condition_ = e.condition ? e.condition : Jg, this.boxEndCondition_ = e.boxEndCondition ? e.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(e, n, i) {
    const a = i[0] - n[0], o = i[1] - n[1];
    return a * a + o * o >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    this.startPixel_ && (this.box_.setPixels(this.startPixel_, e.pixel), this.dispatchEvent(
      new Qo(
        $a.BOXDRAG,
        e.coordinate,
        e
      )
    ));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (!this.startPixel_)
      return !1;
    this.box_.setMap(null);
    const n = this.boxEndCondition_(
      e,
      this.startPixel_,
      e.pixel
    );
    return n && this.onBoxEnd(e), this.dispatchEvent(
      new Qo(
        n ? $a.BOXEND : $a.BOXCANCEL,
        e.coordinate,
        e
      )
    ), !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.condition_(e) ? (this.startPixel_ = e.pixel, this.box_.setMap(e.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new Qo(
        $a.BOXSTART,
        e.coordinate,
        e
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    e || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
      new Qo($a.BOXCANCEL, this.startPixel_, null)
    ), this.startPixel_ = null)), super.setActive(e);
  }
}
class p0 extends C0 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const n = e.condition ? e.condition : f0;
    super({
      condition: n,
      className: e.className || "ol-dragzoom",
      minArea: e.minArea
    }), this.duration_ = e.duration !== void 0 ? e.duration : 200, this.out_ = e.out !== void 0 ? e.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
    const i = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let a = this.getGeometry();
    if (this.out_) {
      const o = i.rotatedExtentForGeometry(a), r = i.getResolutionForExtentInternal(o), l = i.getResolution() / r;
      a = a.clone(), a.scale(l * l);
    }
    i.fitInternal(a, {
      duration: this.duration_,
      easing: za
    });
  }
}
const Li = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};
class _0 extends Do {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.defaultCondition_ = function(n) {
      return Qg(n) && em(n);
    }, this.condition_ = e.condition !== void 0 ? e.condition : this.defaultCondition_, this.duration_ = e.duration !== void 0 ? e.duration : 100, this.pixelDelta_ = e.pixelDelta !== void 0 ? e.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let n = !1;
    if (e.type == Se.KEYDOWN) {
      const i = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), a = i.key;
      if (this.condition_(e) && (a == Li.DOWN || a == Li.LEFT || a == Li.RIGHT || a == Li.UP)) {
        const r = e.map.getView(), l = r.getResolution() * this.pixelDelta_;
        let s = 0, u = 0;
        a == Li.DOWN ? u = -l : a == Li.LEFT ? s = -l : a == Li.RIGHT ? s = l : u = l;
        const c = [s, u];
        fu(c, r.getRotation()), l0(r, c, this.duration_), i.preventDefault(), n = !0;
      }
    }
    return !n;
  }
}
class S0 extends Do {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.condition_ = e.condition ? e.condition : function(n) {
      return !h0(n) && em(n);
    }, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let n = !1;
    if (e.type == Se.KEYDOWN || e.type == Se.KEYPRESS) {
      const i = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), a = i.key;
      if (this.condition_(e) && (a === "+" || a === "-")) {
        const o = e.map, r = a === "+" ? this.delta_ : -this.delta_, l = o.getView();
        Lu(l, r, void 0, this.duration_), i.preventDefault(), n = !0;
      }
    }
    return !n;
  }
}
class b0 {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(e, n, i) {
    this.decay_ = e, this.minVelocity_ = n, this.delay_ = i, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(e, n) {
    this.points_.push(e, n, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const e = Date.now() - this.delay_, n = this.points_.length - 3;
    if (this.points_[n + 2] < e)
      return !1;
    let i = n - 3;
    for (; i > 0 && this.points_[i + 2] > e; )
      i -= 3;
    const a = this.points_[n + 2] - this.points_[i + 2];
    if (a < 1e3 / 60)
      return !1;
    const o = this.points_[n] - this.points_[i], r = this.points_[n + 1] - this.points_[i + 1];
    return this.angle_ = Math.atan2(r, o), this.initialVelocity_ = Math.sqrt(o * o + r * r) / a, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
class M0 extends Do {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = e.maxDelta !== void 0 ? e.maxDelta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.timeout_ = e.timeout !== void 0 ? e.timeout : 80, this.useAnchor_ = e.useAnchor !== void 0 ? e.useAnchor : !0, this.constrainResolution_ = e.constrainResolution !== void 0 ? e.constrainResolution : !1;
    const n = e.condition ? e.condition : d0;
    this.condition_ = e.onFocusOnly ? gs(qg, n) : n, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const e = this.getMap();
    if (!e)
      return;
    e.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!this.condition_(e) || e.type !== Se.WHEEL)
      return !0;
    const i = e.map, a = (
      /** @type {WheelEvent} */
      e.originalEvent
    );
    a.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = e.coordinate);
    let o;
    if (e.type == Se.WHEEL && (o = a.deltaY, WS && a.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (o /= zg), a.deltaMode === WheelEvent.DOM_DELTA_LINE && (o *= 40)), o === 0)
      return !1;
    this.lastDelta_ = o;
    const r = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = r), (!this.mode_ || r - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(o) < 4 ? "trackpad" : "wheel");
    const l = i.getView();
    if (this.mode_ === "trackpad" && !(l.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (l.getAnimating() && l.cancelAnimations(), l.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), l.adjustZoom(-o / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = r, !1;
    this.totalDelta_ += o;
    const s = Math.max(this.timeout_ - (r - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, i),
      s
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(e) {
    const n = e.getView();
    n.getAnimating() && n.cancelAnimations();
    let i = -tt(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (n.getConstrainResolution() || this.constrainResolution_) && (i = i ? i > 0 ? 1 : -1 : 0), Lu(n, i, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(e) {
    this.useAnchor_ = e, e || (this.lastAnchor_ = null);
  }
}
class x0 extends Go {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const n = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    n.stopDown || (n.stopDown = Nr), super(n), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = e.threshold !== void 0 ? e.threshold : 0.3, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let n = 0;
    const i = this.targetPointers[0], a = this.targetPointers[1], o = Math.atan2(
      a.clientY - i.clientY,
      a.clientX - i.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const s = o - this.lastAngle_;
      this.rotationDelta_ += s, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), n = s;
    }
    this.lastAngle_ = o;
    const r = e.map, l = r.getView();
    l.getConstraints().rotation !== pu && (this.anchor_ = r.getCoordinateFromPixelInternal(
      r.getEventPixel(Vu(this.targetPointers))
    ), this.rotating_ && (r.render(), l.adjustRotationInternal(n, this.anchor_)));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return this.targetPointers.length < 2 ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const n = e.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || n.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
class P0 extends Go {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const n = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    n.stopDown || (n.stopDown = Nr), super(n), this.anchor_ = null, this.duration_ = e.duration !== void 0 ? e.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let n = 1;
    const i = this.targetPointers[0], a = this.targetPointers[1], o = i.clientX - a.clientX, r = i.clientY - a.clientY, l = Math.sqrt(o * o + r * r);
    this.lastDistance_ !== void 0 && (n = this.lastDistance_ / l), this.lastDistance_ = l;
    const s = e.map, u = s.getView();
    n != 1 && (this.lastScaleDelta_ = n), this.anchor_ = s.getCoordinateFromPixelInternal(
      s.getEventPixel(Vu(this.targetPointers))
    ), s.render(), u.adjustResolutionInternal(n, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (this.targetPointers.length < 2) {
      const i = e.map.getView(), a = this.lastScaleDelta_ > 1 ? 1 : -1;
      return i.endInteraction(this.duration_, a), !1;
    }
    return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const n = e.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || n.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
function T0(t) {
  t = t || {};
  const e = new wn(), n = new b0(-5e-3, 0.05, 100);
  return (t.altShiftDragRotate !== void 0 ? t.altShiftDragRotate : !0) && e.push(new v0()), (t.doubleClickZoom !== void 0 ? t.doubleClickZoom : !0) && e.push(
    new s0({
      delta: t.zoomDelta,
      duration: t.zoomDuration
    })
  ), (t.dragPan !== void 0 ? t.dragPan : !0) && e.push(
    new m0({
      onFocusOnly: t.onFocusOnly,
      kinetic: n
    })
  ), (t.pinchRotate !== void 0 ? t.pinchRotate : !0) && e.push(new x0()), (t.pinchZoom !== void 0 ? t.pinchZoom : !0) && e.push(
    new P0({
      duration: t.zoomDuration
    })
  ), (t.keyboard !== void 0 ? t.keyboard : !0) && (e.push(new _0()), e.push(
    new S0({
      delta: t.zoomDelta,
      duration: t.zoomDuration
    })
  )), (t.mouseWheelZoom !== void 0 ? t.mouseWheelZoom : !0) && e.push(
    new M0({
      onFocusOnly: t.onFocusOnly,
      duration: t.zoomDuration
    })
  ), (t.shiftDragZoom !== void 0 ? t.shiftDragZoom : !0) && e.push(
    new p0({
      duration: t.zoomDuration
    })
  ), e;
}
function tm(t) {
  if (t instanceof Zr) {
    t.setMapInternal(null);
    return;
  }
  t instanceof Va && t.getLayers().forEach(tm);
}
function nm(t, e) {
  if (t instanceof Zr) {
    t.setMapInternal(e);
    return;
  }
  if (t instanceof Va) {
    const n = t.getLayers().getArray();
    for (let i = 0, a = n.length; i < a; ++i)
      nm(n[i], e);
  }
}
let w0 = class extends _n {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(e) {
    super(), e = e || {}, this.on, this.once, this.un;
    const n = E0(e);
    this.renderComplete_, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = e.maxTilesLoading !== void 0 ? e.maxTilesLoading : 16, this.pixelRatio_ = e.pixelRatio !== void 0 ? e.pixelRatio : zg, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = hn(), this.pixelToCoordinateTransform_ = hn(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = e.moveTolerance, this.keyboardEventTarget_ = n.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = n.controls || r0(), this.interactions = n.interactions || T0({
      onFocusOnly: !0
    }), this.overlays_ = n.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new t0(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      mt.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(mt.VIEW, this.handleViewChanged_), this.addChangeListener(mt.SIZE, this.handleSizeChanged_), this.addChangeListener(mt.TARGET, this.handleTargetChanged_), this.setProperties(n.values);
    const i = this;
    e.view && !(e.view instanceof Pn) && e.view.then(function(a) {
      i.setView(new Pn(a));
    }), this.controls.addEventListener(
      Rt.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (a) => {
        a.element.setMap(this);
      }
    ), this.controls.addEventListener(
      Rt.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (a) => {
        a.element.setMap(null);
      }
    ), this.interactions.addEventListener(
      Rt.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (a) => {
        a.element.setMap(this);
      }
    ), this.interactions.addEventListener(
      Rt.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (a) => {
        a.element.setMap(null);
      }
    ), this.overlays_.addEventListener(
      Rt.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (a) => {
        this.addOverlayInternal_(a.element);
      }
    ), this.overlays_.addEventListener(
      Rt.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (a) => {
        const o = a.element.getId();
        o !== void 0 && delete this.overlayIdIndex_[o.toString()], a.element.setMap(null);
      }
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (a) => {
        a.setMap(this);
      }
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (a) => {
        a.setMap(this);
      }
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(e) {
    this.getControls().push(e);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(e) {
    this.getInteractions().push(e);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(e) {
    this.getLayerGroup().getLayers().push(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(e) {
    nm(e.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(e) {
    this.getOverlays().push(e);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(e) {
    const n = e.getId();
    n !== void 0 && (this.overlayIdIndex_[n.toString()] = e), e.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(e, n, i) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const a = this.getCoordinateFromPixelInternal(e);
    i = i !== void 0 ? i : {};
    const o = i.hitTolerance !== void 0 ? i.hitTolerance : 0, r = i.layerFilter !== void 0 ? i.layerFilter : oo, l = i.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      a,
      this.frameState_,
      o,
      l,
      n,
      null,
      r,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(e, n) {
    const i = [];
    return this.forEachFeatureAtPixel(
      e,
      function(a) {
        i.push(a);
      },
      n
    ), i;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const e = [];
    function n(i) {
      i.forEach(function(a) {
        a instanceof Va ? n(a.getLayers()) : e.push(a);
      });
    }
    return n(this.getLayers()), e;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(e, n) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const i = this.getCoordinateFromPixelInternal(e);
    n = n !== void 0 ? n : {};
    const a = n.layerFilter !== void 0 ? n.layerFilter : oo, o = n.hitTolerance !== void 0 ? n.hitTolerance : 0, r = n.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      i,
      this.frameState_,
      o,
      r,
      a,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(e) {
    return this.getCoordinateFromPixel(this.getEventPixel(e));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(e) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(e));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(e) {
    const i = this.viewport_.getBoundingClientRect(), a = this.getSize(), o = i.width / a[0], r = i.height / a[1], l = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in e ? (
        /** @type {TouchEvent} */
        e.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        e
      )
    );
    return [
      (l.clientX - i.left) / o,
      (l.clientY - i.top) / r
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(mt.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(e) {
    return ss(
      this.getCoordinateFromPixelInternal(e),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(e) {
    const n = this.frameState_;
    return n ? ut(n.pixelToCoordinateTransform, e.slice()) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(e) {
    const n = this.overlayIdIndex_[e.toString()];
    return n !== void 0 ? n : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(mt.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(e) {
    const n = this.getLayerGroup();
    if (e instanceof wn) {
      n.setLayers(e);
      return;
    }
    const i = n.getLayers();
    i.clear(), i.extend(e);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let n = 0, i = e.length; n < i; ++n) {
      const a = e[n];
      if (!a.visible)
        continue;
      const o = a.layer.getRenderer();
      if (o && !o.ready)
        return !0;
      const r = a.layer.getSource();
      if (r && r.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(e) {
    const n = jn(
      e,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(n);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(e) {
    const n = this.frameState_;
    return n ? ut(
      n.coordinateToPixelTransform,
      e.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(mt.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(mt.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const e = this.getTargetElement();
    return e ? e.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(e, n, i, a) {
    return n0(
      this.frameState_,
      e,
      n,
      i,
      a
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(e, n) {
    n = n || e.type;
    const i = new mi(n, this, e);
    this.handleMapBrowserEvent(i);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(e) {
    if (!this.frameState_)
      return;
    const n = (
      /** @type {PointerEvent} */
      e.originalEvent
    ), i = n.type;
    if (i === fs.POINTERDOWN || i === Se.WHEEL || i === Se.KEYDOWN) {
      const a = this.getOwnerDocument(), o = this.viewport_.getRootNode ? this.viewport_.getRootNode() : a, r = (
        /** @type {Node} */
        n.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(r) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(o === a ? a.documentElement : o).contains(r)
      )
        return;
    }
    if (e.frameState = this.frameState_, this.dispatchEvent(e) !== !1) {
      const a = this.getInteractions().getArray().slice();
      for (let o = a.length - 1; o >= 0; o--) {
        const r = a[o];
        if (r.getMap() !== this || !r.getActive() || !this.getTargetElement())
          continue;
        if (!r.handleEvent(e) || e.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const e = this.frameState_, n = this.tileQueue_;
    if (!n.isEmpty()) {
      let a = this.maxTilesLoading_, o = a;
      if (e) {
        const r = e.viewHints;
        if (r[vt.ANIMATING] || r[vt.INTERACTING]) {
          const l = Date.now() - e.time > 8;
          a = l ? 0 : 8, o = l ? 0 : 2;
        }
      }
      n.getTilesLoading() < a && (n.reprioritize(), n.loadMoreTiles(a, o));
    }
    e && this.renderer_ && !e.animate && (this.renderComplete_ === !0 ? (this.hasListener(Qt.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      Qt.RENDERCOMPLETE,
      e
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new oa(Zn.LOADEND, this, e)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new oa(Zn.LOADSTART, this, e)
    )));
    const i = this.postRenderFunctions_;
    for (let a = 0, o = i.length; a < o; ++a)
      i[a](this, e);
    i.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, a = this.targetChangeHandlerKeys_.length; i < a; ++i)
        $e(this.targetChangeHandlerKeys_[i]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        Se.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        Se.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, br(this.viewport_);
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const i = this.targetElement_.getRootNode();
      i instanceof ShadowRoot && this.resizeObserver_.unobserve(i.host), this.setSize(void 0);
    }
    const e = this.getTarget(), n = typeof e == "string" ? document.getElementById(e) : e;
    if (this.targetElement_ = n, !n)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      n.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new Jb(this)), this.mapBrowserEventHandler_ = new Qb(
        this,
        this.moveTolerance_
      );
      for (const o in Je)
        this.mapBrowserEventHandler_.addEventListener(
          Je[o],
          this.handleMapBrowserEvent.bind(this)
        );
      this.viewport_.addEventListener(
        Se.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        !1
      ), this.viewport_.addEventListener(
        Se.WHEEL,
        this.boundHandleBrowserEvent_,
        Bg ? { passive: !1 } : !1
      );
      const i = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : n;
      this.targetChangeHandlerKeys_ = [
        we(
          i,
          Se.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        we(
          i,
          Se.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const a = n.getRootNode();
      a instanceof ShadowRoot && this.resizeObserver_.observe(a.host), this.resizeObserver_.observe(n);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && ($e(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && ($e(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const e = this.getView();
    e && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = we(
      e,
      _a.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = we(
      e,
      Se.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), e.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach($e), this.layerGroupPropertyListenerKeys_ = null);
    const e = this.getLayerGroup();
    e && (this.handleLayerAdd_(new vi("addlayer", e)), this.layerGroupPropertyListenerKeys_ = [
      we(e, _a.PROPERTYCHANGE, this.render, this),
      we(e, Se.CHANGE, this.render, this),
      we(e, "addlayer", this.handleLayerAdd_, this),
      we(e, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let n = 0, i = e.length; n < i; ++n) {
      const a = e[n].layer;
      a.hasRenderer() && a.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(e) {
    return this.getControls().remove(e);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(e) {
    return this.getInteractions().remove(e);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(e) {
    return this.getLayerGroup().getLayers().remove(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(e) {
    tm(e.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(e) {
    return this.getOverlays().remove(e);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(e) {
    const n = this.getSize(), i = this.getView(), a = this.frameState_;
    let o = null;
    if (n !== void 0 && gd(n) && i && i.isDef()) {
      const r = i.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), l = i.getState();
      if (o = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: os(
          l.center,
          l.resolution,
          l.rotation,
          n
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: n,
        tileQueue: this.tileQueue_,
        time: e,
        usedTiles: {},
        viewState: l,
        viewHints: r,
        wantedTiles: {},
        mapId: Ve(this),
        renderTargets: {}
      }, l.nextCenter && l.nextResolution) {
        const s = isNaN(l.nextRotation) ? l.rotation : l.nextRotation;
        o.nextExtent = os(
          l.nextCenter,
          l.nextResolution,
          s,
          n
        );
      }
    }
    this.frameState_ = o, this.renderer_.renderFrame(o), o && (o.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      o.postRenderFunctions
    ), a && (!this.previousExtent_ || !jr(this.previousExtent_) && !ro(o.extent, this.previousExtent_)) && (this.dispatchEvent(
      new oa(Zn.MOVESTART, this, a)
    ), this.previousExtent_ = $r(this.previousExtent_)), this.previousExtent_ && !o.viewHints[vt.ANIMATING] && !o.viewHints[vt.INTERACTING] && !ro(o.extent, this.previousExtent_) && (this.dispatchEvent(
      new oa(Zn.MOVEEND, this, o)
    ), ng(o.extent, this.previousExtent_))), this.dispatchEvent(new oa(Zn.POSTRENDER, this, o)), this.renderComplete_ = this.hasListener(Zn.LOADSTART) || this.hasListener(Zn.LOADEND) || this.hasListener(Qt.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(e) {
    const n = this.getLayerGroup();
    n && this.handleLayerRemove_(new vi("removelayer", n)), this.set(mt.LAYERGROUP, e);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(e) {
    this.set(mt.SIZE, e);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(e) {
    this.set(mt.TARGET, e);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(e) {
    if (!e || e instanceof Pn) {
      this.set(mt.VIEW, e);
      return;
    }
    this.set(mt.VIEW, new Pn());
    const n = this;
    e.then(function(i) {
      n.setView(new Pn(i));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const e = this.getTargetElement();
    let n;
    if (e) {
      const a = getComputedStyle(e), o = e.offsetWidth - parseFloat(a.borderLeftWidth) - parseFloat(a.paddingLeft) - parseFloat(a.paddingRight) - parseFloat(a.borderRightWidth), r = e.offsetHeight - parseFloat(a.borderTopWidth) - parseFloat(a.paddingTop) - parseFloat(a.paddingBottom) - parseFloat(a.borderBottomWidth);
      !isNaN(o) && !isNaN(r) && (n = [o, r], !gd(n) && (e.offsetWidth || e.offsetHeight || e.getClientRects().length) && dg(
        "No map visible because the map container's width or height are 0."
      ));
    }
    const i = this.getSize();
    n && (!i || !Ei(n, i)) && (this.setSize(n), this.updateViewportSize_(n));
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(e) {
    const n = this.getView();
    n && n.setViewportSize(e);
  }
};
function E0(t) {
  let e = null;
  t.keyboardEventTarget !== void 0 && (e = typeof t.keyboardEventTarget == "string" ? document.getElementById(t.keyboardEventTarget) : t.keyboardEventTarget);
  const n = {}, i = t.layers && typeof /** @type {?} */
  t.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    t.layers
  ) : new Va({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      t.layers
    )
  });
  n[mt.LAYERGROUP] = i, n[mt.TARGET] = t.target, n[mt.VIEW] = t.view instanceof Pn ? t.view : new Pn();
  let a;
  t.controls !== void 0 && (Array.isArray(t.controls) ? a = new wn(t.controls.slice()) : (Ee(
    typeof /** @type {?} */
    t.controls.getArray == "function",
    "Expected `controls` to be an array or an `ol/Collection.js`"
  ), a = t.controls));
  let o;
  t.interactions !== void 0 && (Array.isArray(t.interactions) ? o = new wn(t.interactions.slice()) : (Ee(
    typeof /** @type {?} */
    t.interactions.getArray == "function",
    "Expected `interactions` to be an array or an `ol/Collection.js`"
  ), o = t.interactions));
  let r;
  return t.overlays !== void 0 ? Array.isArray(t.overlays) ? r = new wn(t.overlays.slice()) : (Ee(
    typeof /** @type {?} */
    t.overlays.getArray == "function",
    "Expected `overlays` to be an array or an `ol/Collection.js`"
  ), r = t.overlays) : r = new wn(), {
    controls: a,
    interactions: o,
    keyboardEventTarget: e,
    overlays: r,
    values: n
  };
}
class im extends Wr {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(e, n, i) {
    super(), i = i || {}, this.tileCoord = e, this.state = n, this.interimTile = null, this.key = "", this.transition_ = i.transition === void 0 ? 250 : i.transition, this.transitionStarts_ = {}, this.interpolate = !!i.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(Se.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.state === fe.ERROR && this.setState(fe.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    let e = this.interimTile;
    if (!e)
      return this;
    do {
      if (e.getState() == fe.LOADED)
        return this.transition_ = 0, e;
      e = e.interimTile;
    } while (e);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    let e = this.interimTile;
    if (!e)
      return;
    let n = this;
    do {
      if (e.getState() == fe.LOADED) {
        e.interimTile = null;
        break;
      }
      e.getState() == fe.LOADING ? n = e : e.getState() == fe.IDLE ? n.interimTile = e.interimTile : n = e, e = n.interimTile;
    } while (e);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(e) {
    if (this.state !== fe.ERROR && this.state > e)
      throw new Error("Tile load sequence violation");
    this.state = e, this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    Re();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(e, n) {
    if (!this.transition_)
      return 1;
    let i = this.transitionStarts_[e];
    if (!i)
      i = n, this.transitionStarts_[e] = i;
    else if (i === -1)
      return 1;
    const a = n - i + 1e3 / 60;
    return a >= this.transition_ ? 1 : vg(a / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(e) {
    return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(e) {
    this.transition_ && (this.transitionStarts_[e] = -1);
  }
}
class am extends im {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, n, i, a, o, r) {
    super(e, n, r), this.crossOrigin_ = a, this.src_ = i, this.key = i, this.image_ = new Image(), a !== null && (this.image_.crossOrigin = a), this.unlisten_ = null, this.tileLoadFunction_ = o;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(e) {
    this.image_ = e, this.state = fe.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = fe.ERROR, this.unlistenImage_(), this.image_ = A0(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const e = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    e.naturalWidth && e.naturalHeight ? this.state = fe.LOADED : this.state = fe.EMPTY, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    this.state == fe.ERROR && (this.state = fe.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == fe.IDLE && (this.state = fe.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = HS(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function A0() {
  const t = dt(1, 1);
  return t.fillStyle = "rgba(0,0,0,0)", t.fillRect(0, 0, 1, 1), t.canvas;
}
const R0 = 0.5, I0 = 10, Id = 0.25;
class z0 {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(e, n, i, a, o, r) {
    this.sourceProj_ = e, this.targetProj_ = n;
    let l = {};
    const s = pr(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(C) {
      const M = C[0] + "/" + C[1];
      return l[M] || (l[M] = s(C)), l[M];
    }, this.maxSourceExtent_ = a, this.errorThresholdSquared_ = o * o, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!a && !!this.sourceProj_.getExtent() && ke(a) >= ke(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? ke(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? ke(this.targetProj_.getExtent()) : null;
    const u = Ui(i), c = Yr(i), d = Ur(i), h = Xr(i), f = this.transformInv_(u), g = this.transformInv_(c), m = this.transformInv_(d), v = this.transformInv_(h), y = I0 + (r ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          as(i) / (r * r * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      u,
      c,
      d,
      h,
      f,
      g,
      m,
      v,
      y
    ), this.wrapsXInSource_) {
      let C = 1 / 0;
      this.triangles_.forEach(function(M, p, b) {
        C = Math.min(
          C,
          M.source[0][0],
          M.source[1][0],
          M.source[2][0]
        );
      }), this.triangles_.forEach((M) => {
        if (Math.max(
          M.source[0][0],
          M.source[1][0],
          M.source[2][0]
        ) - C > this.sourceWorldWidth_ / 2) {
          const p = [
            [M.source[0][0], M.source[0][1]],
            [M.source[1][0], M.source[1][1]],
            [M.source[2][0], M.source[2][1]]
          ];
          p[0][0] - C > this.sourceWorldWidth_ / 2 && (p[0][0] -= this.sourceWorldWidth_), p[1][0] - C > this.sourceWorldWidth_ / 2 && (p[1][0] -= this.sourceWorldWidth_), p[2][0] - C > this.sourceWorldWidth_ / 2 && (p[2][0] -= this.sourceWorldWidth_);
          const b = Math.min(
            p[0][0],
            p[1][0],
            p[2][0]
          );
          Math.max(
            p[0][0],
            p[1][0],
            p[2][0]
          ) - b < this.sourceWorldWidth_ / 2 && (M.source = p);
        }
      });
    }
    l = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(e, n, i, a, o, r) {
    this.triangles_.push({
      source: [a, o, r],
      target: [e, n, i]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(e, n, i, a, o, r, l, s, u) {
    const c = Jc([o, r, l, s]), d = this.sourceWorldWidth_ ? ke(c) / this.sourceWorldWidth_ : null, h = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), f = this.sourceProj_.canWrapX() && d > 0.5 && d < 1;
    let g = !1;
    if (u > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const v = Jc([e, n, i, a]);
        g = ke(v) / this.targetWorldWidth_ > Id || g;
      }
      !f && this.sourceProj_.isGlobal() && d && (g = d > Id || g);
    }
    if (!g && this.maxSourceExtent_ && isFinite(c[0]) && isFinite(c[1]) && isFinite(c[2]) && isFinite(c[3]) && !zt(c, this.maxSourceExtent_))
      return;
    let m = 0;
    if (!g && (!isFinite(o[0]) || !isFinite(o[1]) || !isFinite(r[0]) || !isFinite(r[1]) || !isFinite(l[0]) || !isFinite(l[1]) || !isFinite(s[0]) || !isFinite(s[1]))) {
      if (u > 0)
        g = !0;
      else if (m = (!isFinite(o[0]) || !isFinite(o[1]) ? 8 : 0) + (!isFinite(r[0]) || !isFinite(r[1]) ? 4 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 2 : 0) + (!isFinite(s[0]) || !isFinite(s[1]) ? 1 : 0), m != 1 && m != 2 && m != 4 && m != 8)
        return;
    }
    if (u > 0) {
      if (!g) {
        const v = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2], y = this.transformInv_(v);
        let C;
        f ? C = (ga(o[0], h) + ga(l[0], h)) / 2 - ga(y[0], h) : C = (o[0] + l[0]) / 2 - y[0];
        const M = (o[1] + l[1]) / 2 - y[1];
        g = C * C + M * M > this.errorThresholdSquared_;
      }
      if (g) {
        if (Math.abs(e[0] - i[0]) <= Math.abs(e[1] - i[1])) {
          const v = [(n[0] + i[0]) / 2, (n[1] + i[1]) / 2], y = this.transformInv_(v), C = [(a[0] + e[0]) / 2, (a[1] + e[1]) / 2], M = this.transformInv_(C);
          this.addQuad_(
            e,
            n,
            v,
            C,
            o,
            r,
            y,
            M,
            u - 1
          ), this.addQuad_(
            C,
            v,
            i,
            a,
            M,
            y,
            l,
            s,
            u - 1
          );
        } else {
          const v = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2], y = this.transformInv_(v), C = [(i[0] + a[0]) / 2, (i[1] + a[1]) / 2], M = this.transformInv_(C);
          this.addQuad_(
            e,
            v,
            C,
            a,
            o,
            y,
            M,
            s,
            u - 1
          ), this.addQuad_(
            v,
            n,
            i,
            C,
            y,
            r,
            l,
            M,
            u - 1
          );
        }
        return;
      }
    }
    if (f) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    (m & 11) == 0 && this.addTriangle_(e, i, a, o, l, s), (m & 14) == 0 && this.addTriangle_(e, i, n, o, l, r), m && ((m & 13) == 0 && this.addTriangle_(n, a, e, r, s, o), (m & 7) == 0 && this.addTriangle_(n, a, i, r, s, l));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const e = an();
    return this.triangles_.forEach(function(n, i, a) {
      const o = n.source;
      Za(e, o[0]), Za(e, o[1]), Za(e, o[2]);
    }), e;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
let Bl;
const va = [];
function zd(t, e, n, i, a) {
  t.beginPath(), t.moveTo(0, 0), t.lineTo(e, n), t.lineTo(i, a), t.closePath(), t.save(), t.clip(), t.fillRect(0, 0, Math.max(e, i) + 1, Math.max(n, a)), t.restore();
}
function Fl(t, e) {
  return Math.abs(t[e * 4] - 210) > 2 || Math.abs(t[e * 4 + 3] - 0.75 * 255) > 2;
}
function L0() {
  if (Bl === void 0) {
    const t = dt(6, 6, va);
    t.globalCompositeOperation = "lighter", t.fillStyle = "rgba(210, 0, 0, 0.75)", zd(t, 4, 5, 4, 0), zd(t, 4, 5, 0, 5);
    const e = t.getImageData(0, 0, 3, 3).data;
    Bl = Fl(e, 0) || Fl(e, 4) || Fl(e, 8), qr(t), va.push(t.canvas);
  }
  return Bl;
}
function Ld(t, e, n, i) {
  const a = gg(n, e, t);
  let o = ed(
    e,
    i,
    n
  );
  const r = e.getMetersPerUnit();
  r !== void 0 && (o *= r);
  const l = t.getMetersPerUnit();
  l !== void 0 && (o /= l);
  const s = t.getExtent();
  if (!s || Ma(s, a)) {
    const u = ed(t, o, a) / o;
    isFinite(u) && u > 0 && (o /= u);
  }
  return o;
}
function V0(t, e, n, i) {
  const a = $i(n);
  let o = Ld(
    t,
    e,
    a,
    i
  );
  return (!isFinite(o) || o <= 0) && lg(n, function(r) {
    return o = Ld(
      t,
      e,
      r,
      i
    ), isFinite(o) && o > 0;
  }), o;
}
function B0(t, e, n, i, a, o, r, l, s, u, c, d, h, f) {
  const g = dt(
    Math.round(n * t),
    Math.round(n * e),
    va
  );
  if (d || (g.imageSmoothingEnabled = !1), s.length === 0)
    return g.canvas;
  g.scale(n, n);
  function m(b) {
    return Math.round(b * n) / n;
  }
  g.globalCompositeOperation = "lighter";
  const v = an();
  s.forEach(function(b, P, x) {
    B_(v, b.extent);
  });
  let y;
  const C = n / i, M = (d ? 1 : 1 + Math.pow(2, -24)) / C;
  y = dt(
    Math.round(ke(v) * C),
    Math.round(Mt(v) * C),
    va
  ), d || (y.imageSmoothingEnabled = !1), s.forEach(function(b, P, x) {
    if (b.image.width > 0 && b.image.height > 0) {
      if (b.clipExtent) {
        y.save();
        const z = (b.clipExtent[0] - v[0]) * C, I = -(b.clipExtent[3] - v[3]) * C, k = ke(b.clipExtent) * C, G = Mt(b.clipExtent) * C;
        y.rect(
          d ? z : Math.round(z),
          d ? I : Math.round(I),
          d ? k : Math.round(z + k) - Math.round(z),
          d ? G : Math.round(I + G) - Math.round(I)
        ), y.clip();
      }
      const _ = (b.extent[0] - v[0]) * C, T = -(b.extent[3] - v[3]) * C, B = ke(b.extent) * C, L = Mt(b.extent) * C;
      y.drawImage(
        b.image,
        u,
        u,
        b.image.width - 2 * u,
        b.image.height - 2 * u,
        d ? _ : Math.round(_),
        d ? T : Math.round(T),
        d ? B : Math.round(_ + B) - Math.round(_),
        d ? L : Math.round(T + L) - Math.round(T)
      ), b.clipExtent && y.restore();
    }
  });
  const p = Ui(r);
  return l.getTriangles().forEach(function(b, P, x) {
    const _ = b.source, T = b.target;
    let B = _[0][0], L = _[0][1], z = _[1][0], I = _[1][1], k = _[2][0], G = _[2][1];
    const F = m((T[0][0] - p[0]) / o), q = m(
      -(T[0][1] - p[1]) / o
    ), j = m((T[1][0] - p[0]) / o), ne = m(
      -(T[1][1] - p[1]) / o
    ), A = m((T[2][0] - p[0]) / o), R = m(
      -(T[2][1] - p[1]) / o
    ), V = B, X = L;
    B = 0, L = 0, z -= V, I -= X, k -= V, G -= X;
    const D = [
      [z, I, 0, 0, j - F],
      [k, G, 0, 0, A - F],
      [0, 0, z, I, ne - q],
      [0, 0, k, G, R - q]
    ], Y = x_(D);
    if (!Y)
      return;
    if (g.save(), g.beginPath(), L0() || !d) {
      g.moveTo(j, ne);
      const K = 4, se = F - j, ge = q - ne;
      for (let $ = 0; $ < K; $++)
        g.lineTo(
          j + m(($ + 1) * se / K),
          ne + m($ * ge / (K - 1))
        ), $ != K - 1 && g.lineTo(
          j + m(($ + 1) * se / K),
          ne + m(($ + 1) * ge / (K - 1))
        );
      g.lineTo(A, R);
    } else
      g.moveTo(j, ne), g.lineTo(F, q), g.lineTo(A, R);
    g.clip(), g.transform(
      Y[0],
      Y[2],
      Y[1],
      Y[3],
      F,
      q
    ), g.translate(
      v[0] - V,
      v[3] - X
    );
    let ce;
    if (y)
      ce = y.canvas, g.scale(M, -M);
    else {
      const K = s[0], se = K.extent;
      ce = K.image, g.scale(
        ke(se) / ce.width,
        -Mt(se) / ce.height
      );
    }
    g.drawImage(ce, 0, 0), g.restore();
  }), y && (qr(y), va.push(y.canvas)), c && (g.save(), g.globalCompositeOperation = "source-over", g.strokeStyle = "black", g.lineWidth = 1, l.getTriangles().forEach(function(b, P, x) {
    const _ = b.target, T = (_[0][0] - p[0]) / o, B = -(_[0][1] - p[1]) / o, L = (_[1][0] - p[0]) / o, z = -(_[1][1] - p[1]) / o, I = (_[2][0] - p[0]) / o, k = -(_[2][1] - p[1]) / o;
    g.beginPath(), g.moveTo(L, z), g.lineTo(T, B), g.lineTo(I, k), g.closePath(), g.stroke();
  }), g.restore()), g.canvas;
}
class ms extends im {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(e, n, i, a, o, r, l, s, u, c, d, h) {
    super(o, fe.IDLE, h), this.renderEdges_ = d !== void 0 ? d : !1, this.pixelRatio_ = l, this.gutter_ = s, this.canvas_ = null, this.sourceTileGrid_ = n, this.targetTileGrid_ = a, this.wrappedTileCoord_ = r || o, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = e.canWrapX() ? e.getExtent() : void 0;
    const f = a.getTileCoordExtent(
      this.wrappedTileCoord_
    ), g = this.targetTileGrid_.getExtent();
    let m = this.sourceTileGrid_.getExtent();
    const v = g ? Ka(f, g) : f;
    if (as(v) === 0) {
      this.state = fe.EMPTY;
      return;
    }
    const y = e.getExtent();
    y && (m ? m = Ka(m, y) : m = y);
    const C = a.getResolution(
      this.wrappedTileCoord_[0]
    ), M = V0(
      e,
      i,
      v,
      C
    );
    if (!isFinite(M) || M <= 0) {
      this.state = fe.EMPTY;
      return;
    }
    const p = c !== void 0 ? c : R0;
    if (this.triangulation_ = new z0(
      e,
      i,
      v,
      m,
      M * p,
      C
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = fe.EMPTY;
      return;
    }
    this.sourceZ_ = n.getZForResolution(M);
    let b = this.triangulation_.calculateSourceExtent();
    if (m && (e.canWrapX() ? (b[1] = tt(
      b[1],
      m[1],
      m[3]
    ), b[3] = tt(
      b[3],
      m[1],
      m[3]
    )) : b = Ka(b, m)), !as(b))
      this.state = fe.EMPTY;
    else {
      let P = 0, x = 0;
      e.canWrapX() && (P = ke(y), x = Math.floor(
        (b[0] - y[0]) / P
      )), ug(
        b.slice(),
        e,
        !0
      ).forEach((T) => {
        const B = n.getTileRangeForExtentAndZ(
          T,
          this.sourceZ_
        );
        for (let L = B.minX; L <= B.maxX; L++)
          for (let z = B.minY; z <= B.maxY; z++) {
            const I = u(this.sourceZ_, L, z, l);
            if (I) {
              const k = x * P;
              this.sourceTiles_.push({ tile: I, offset: k });
            }
          }
        ++x;
      }), this.sourceTiles_.length === 0 && (this.state = fe.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = [];
    if (this.sourceTiles_.forEach((n) => {
      var a;
      const i = n.tile;
      if (i && i.getState() == fe.LOADED) {
        const o = this.sourceTileGrid_.getTileCoordExtent(i.tileCoord);
        o[0] += n.offset, o[2] += n.offset;
        const r = (a = this.clipExtent_) == null ? void 0 : a.slice();
        r && (r[0] += n.offset, r[2] += n.offset), e.push({
          extent: o,
          clipExtent: r,
          image: i.getImage()
        });
      }
    }), this.sourceTiles_.length = 0, e.length === 0)
      this.state = fe.ERROR;
    else {
      const n = this.wrappedTileCoord_[0], i = this.targetTileGrid_.getTileSize(n), a = typeof i == "number" ? i : i[0], o = typeof i == "number" ? i : i[1], r = this.targetTileGrid_.getResolution(n), l = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), s = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = B0(
        a,
        o,
        this.pixelRatio_,
        l,
        this.sourceTileGrid_.getExtent(),
        r,
        s,
        this.triangulation_,
        e,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = fe.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == fe.IDLE) {
      this.state = fe.LOADING, this.changed();
      let e = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: n }) => {
        const i = n.getState();
        if (i == fe.IDLE || i == fe.LOADING) {
          e++;
          const a = we(
            n,
            Se.CHANGE,
            function(o) {
              const r = n.getState();
              (r == fe.LOADED || r == fe.ERROR || r == fe.EMPTY) && ($e(a), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
            },
            this
          );
          this.sourcesListenerKeys_.push(a);
        }
      }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: n }, i, a) {
        n.getState() == fe.IDLE && n.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach($e), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    this.canvas_ && (qr(this.canvas_.getContext("2d")), va.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
class F0 {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(e) {
    this.highWaterMark = e !== void 0 ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(e) {
    for (; this.canExpireCache(); )
      this.pop();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(e) {
    return this.entries_.hasOwnProperty(e);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(e) {
    let n = this.oldest_;
    for (; n; )
      e(n.value_, n.key_, this), n = n.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(e, n) {
    const i = this.entries_[e];
    return Ee(
      i !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), i === this.newest_ || (i === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (i.newer.older = i.older, i.older.newer = i.newer), i.newer = null, i.older = this.newest_, this.newest_.newer = i, this.newest_ = i), i.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(e) {
    const n = this.entries_[e];
    return Ee(
      n !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), n === this.newest_ ? (this.newest_ = /** @type {Entry} */
    n.older, this.newest_ && (this.newest_.newer = null)) : n === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    n.newer, this.oldest_ && (this.oldest_.older = null)) : (n.newer.older = n.older, n.older.newer = n.newer), delete this.entries_[e], --this.count_, n.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const e = new Array(this.count_);
    let n = 0, i;
    for (i = this.newest_; i; i = i.older)
      e[n++] = i.key_;
    return e;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const e = new Array(this.count_);
    let n = 0, i;
    for (i = this.newest_; i; i = i.older)
      e[n++] = i.value_;
    return e;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(e) {
    var n;
    return (n = this.entries_[e]) == null ? void 0 : n.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const e = this.oldest_;
    return delete this.entries_[e.key_], e.newer && (e.newer.older = null), this.oldest_ = /** @type {Entry} */
    e.newer, this.oldest_ || (this.newest_ = null), --this.count_, e.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(e, n) {
    this.get(e), this.entries_[e].value_ = n;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(e, n) {
    Ee(
      !(e in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const i = {
      key_: e,
      newer: null,
      older: this.newest_,
      value_: n
    };
    this.newest_ ? this.newest_.newer = i : this.oldest_ = i, this.newest_ = i, this.entries_[e] = i, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(e) {
    this.highWaterMark = e;
  }
}
function Vd(t, e, n, i) {
  return i !== void 0 ? (i[0] = t, i[1] = e, i[2] = n, i) : [t, e, n];
}
function ol(t, e, n) {
  return t + "/" + e + "/" + n;
}
function om(t) {
  return ol(t[0], t[1], t[2]);
}
function k0(t) {
  return t.split("/").map(Number);
}
function O0(t) {
  return (t[1] << t[0]) + t[2];
}
function D0(t, e) {
  const n = t[0], i = t[1], a = t[2];
  if (e.getMinZoom() > n || n > e.getMaxZoom())
    return !1;
  const o = e.getFullTileRange(n);
  return o ? o.containsXY(i, a) : !0;
}
class rm extends F0 {
  clear() {
    for (; this.getCount() > 0; )
      this.pop().release();
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e) {
    for (; this.canExpireCache() && !(this.peekLast().getKey() in e); )
      this.pop().release();
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0)
      return;
    const e = this.peekFirstKey(), i = k0(e)[0];
    this.forEach((a) => {
      a.tileCoord[0] !== i && (this.remove(om(a.tileCoord)), a.release());
    });
  }
}
const kl = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};
class lm extends _n {
  /**
   * @param {Options} options Source options.
   */
  constructor(e) {
    super(), this.projection = on(e.projection), this.attributions_ = Bd(e.attributions), this.attributionsCollapsible_ = e.attributionsCollapsible !== void 0 ? e.attributionsCollapsible : !0, this.loading = !1, this.state_ = e.state !== void 0 ? e.state : "ready", this.wrapX_ = e.wrapX !== void 0 ? e.wrapX : !1, this.interpolate_ = !!e.interpolate, this.viewResolver = null, this.viewRejector = null;
    const n = this;
    this.viewPromise_ = new Promise(function(i, a) {
      n.viewResolver = i, n.viewRejector = a;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(e) {
    this.attributions_ = Bd(e), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(e) {
    this.state_ = e, this.changed();
  }
}
function Bd(t) {
  return t ? Array.isArray(t) ? function(e) {
    return t;
  } : typeof t == "function" ? t : function(e) {
    return [t];
  } : null;
}
class Bu {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(e, n, i, a) {
    this.minX = e, this.maxX = n, this.minY = i, this.maxY = a;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(e) {
    return this.containsXY(e[1], e[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(e) {
    return this.minX <= e.minX && e.maxX <= this.maxX && this.minY <= e.minY && e.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(e, n) {
    return this.minX <= e && e <= this.maxX && this.minY <= n && n <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(e) {
    return this.minX == e.minX && this.minY == e.minY && this.maxX == e.maxX && this.maxY == e.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(e) {
    e.minX < this.minX && (this.minX = e.minX), e.maxX > this.maxX && (this.maxX = e.maxX), e.minY < this.minY && (this.minY = e.minY), e.maxY > this.maxY && (this.maxY = e.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(e) {
    return this.minX <= e.maxX && this.maxX >= e.minX && this.minY <= e.maxY && this.maxY >= e.minY;
  }
}
function Qi(t, e, n, i, a) {
  return a !== void 0 ? (a.minX = t, a.maxX = e, a.minY = n, a.maxY = i, a) : new Bu(t, e, n, i);
}
const ea = [0, 0, 0], di = 5;
class sm {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(e) {
    this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0, this.resolutions_ = e.resolutions, Ee(
      p_(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (a, o) => o - a
      ),
      "`resolutions` must be sorted in descending order"
    );
    let n;
    if (!e.origins) {
      for (let a = 0, o = this.resolutions_.length - 1; a < o; ++a)
        if (!n)
          n = this.resolutions_[a] / this.resolutions_[a + 1];
        else if (this.resolutions_[a] / this.resolutions_[a + 1] !== n) {
          n = void 0;
          break;
        }
    }
    this.zoomFactor_ = n, this.maxZoom = this.resolutions_.length - 1, this.origin_ = e.origin !== void 0 ? e.origin : null, this.origins_ = null, e.origins !== void 0 && (this.origins_ = e.origins, Ee(
      this.origins_.length == this.resolutions_.length,
      "Number of `origins` and `resolutions` must be equal"
    ));
    const i = e.extent;
    i !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = Ui(i)), Ee(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    ), this.tileSizes_ = null, e.tileSizes !== void 0 && (this.tileSizes_ = e.tileSizes, Ee(
      this.tileSizes_.length == this.resolutions_.length,
      "Number of `tileSizes` and `resolutions` must be equal"
    )), this.tileSize_ = e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : uu, Ee(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    ), this.extent_ = i !== void 0 ? i : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], e.sizes !== void 0 ? this.fullTileRanges_ = e.sizes.map((a, o) => {
      const r = new Bu(
        Math.min(0, a[0]),
        Math.max(a[0] - 1, -1),
        Math.min(0, a[1]),
        Math.max(a[1] - 1, -1)
      );
      if (i) {
        const l = this.getTileRangeForExtentAndZ(i, o);
        r.minX = Math.max(l.minX, r.minX), r.maxX = Math.min(l.maxX, r.maxX), r.minY = Math.max(l.minY, r.minY), r.maxY = Math.min(l.maxY, r.maxY);
      }
      return r;
    }) : i && this.calculateTileRanges_(i);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(e, n, i) {
    const a = this.getTileRangeForExtentAndZ(e, n);
    for (let o = a.minX, r = a.maxX; o <= r; ++o)
      for (let l = a.minY, s = a.maxY; l <= s; ++l)
        i([n, o, l]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(e, n, i, a) {
    let o, r, l, s = null, u = e[0] - 1;
    for (this.zoomFactor_ === 2 ? (r = e[1], l = e[2]) : s = this.getTileCoordExtent(e, a); u >= this.minZoom; ) {
      if (r !== void 0 && l !== void 0 ? (r = Math.floor(r / 2), l = Math.floor(l / 2), o = Qi(r, r, l, l, i)) : o = this.getTileRangeForExtentAndZ(
        s,
        u,
        i
      ), n(u, o))
        return !0;
      --u;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(e) {
    return this.origin_ ? this.origin_ : this.origins_[e];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(e) {
    return this.resolutions_[e];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(e, n, i) {
    if (e[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const o = e[1] * 2, r = e[2] * 2;
        return Qi(
          o,
          o + 1,
          r,
          r + 1,
          n
        );
      }
      const a = this.getTileCoordExtent(
        e,
        i || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        a,
        e[0] + 1,
        n
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(e, n, i) {
    if (n > this.maxZoom || n < this.minZoom)
      return null;
    const a = e[0], o = e[1], r = e[2];
    if (n === a)
      return Qi(
        o,
        r,
        o,
        r,
        i
      );
    if (this.zoomFactor_) {
      const s = Math.pow(this.zoomFactor_, n - a), u = Math.floor(o * s), c = Math.floor(r * s);
      if (n < a)
        return Qi(u, u, c, c, i);
      const d = Math.floor(s * (o + 1)) - 1, h = Math.floor(s * (r + 1)) - 1;
      return Qi(u, d, c, h, i);
    }
    const l = this.getTileCoordExtent(e, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(l, n, i);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(e, n, i) {
    this.getTileCoordForXYAndZ_(e[0], e[3], n, !1, ea);
    const a = ea[1], o = ea[2];
    this.getTileCoordForXYAndZ_(e[2], e[1], n, !0, ea);
    const r = ea[1], l = ea[2];
    return Qi(a, r, o, l, i);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(e) {
    const n = this.getOrigin(e[0]), i = this.getResolution(e[0]), a = Dt(this.getTileSize(e[0]), this.tmpSize_);
    return [
      n[0] + (e[1] + 0.5) * a[0] * i,
      n[1] - (e[2] + 0.5) * a[1] * i
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(e, n) {
    const i = this.getOrigin(e[0]), a = this.getResolution(e[0]), o = Dt(this.getTileSize(e[0]), this.tmpSize_), r = i[0] + e[1] * o[0] * a, l = i[1] - (e[2] + 1) * o[1] * a, s = r + o[0] * a, u = l + o[1] * a;
    return Mi(r, l, s, u, n);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(e, n, i) {
    return this.getTileCoordForXYAndResolution_(
      e[0],
      e[1],
      n,
      !1,
      i
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(e, n, i, a, o) {
    const r = this.getZForResolution(i), l = i / this.getResolution(r), s = this.getOrigin(r), u = Dt(this.getTileSize(r), this.tmpSize_);
    let c = l * (e - s[0]) / i / u[0], d = l * (s[1] - n) / i / u[1];
    return a ? (c = jo(c, di) - 1, d = jo(d, di) - 1) : (c = Yo(c, di), d = Yo(d, di)), Vd(r, c, d, o);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(e, n, i, a, o) {
    const r = this.getOrigin(i), l = this.getResolution(i), s = Dt(this.getTileSize(i), this.tmpSize_);
    let u = (e - r[0]) / l / s[0], c = (r[1] - n) / l / s[1];
    return a ? (u = jo(u, di) - 1, c = jo(c, di) - 1) : (u = Yo(u, di), c = Yo(c, di)), Vd(i, u, c, o);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(e, n, i) {
    return this.getTileCoordForXYAndZ_(
      e[0],
      e[1],
      n,
      !1,
      i
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(e) {
    return this.resolutions_[e[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(e) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(e) {
    return this.fullTileRanges_ ? this.fullTileRanges_[e] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, e) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(e, n) {
    const i = ru(
      this.resolutions_,
      e,
      n || 0
    );
    return tt(i, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(e, n) {
    return Tg(
      n,
      0,
      n.length,
      2,
      this.getTileCoordExtent(e)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(e) {
    const n = this.resolutions_.length, i = new Array(n);
    for (let a = this.minZoom; a < n; ++a)
      i[a] = this.getTileRangeForExtentAndZ(e, a);
    this.fullTileRanges_ = i;
  }
}
function um(t) {
  let e = t.getDefaultTileGrid();
  return e || (e = $0(t), t.setDefaultTileGrid(e)), e;
}
function G0(t, e, n) {
  const i = e[0], a = t.getTileCoordCenter(e), o = Fu(n);
  if (!Ma(o, a)) {
    const r = ke(o), l = Math.ceil(
      (o[0] - a[0]) / r
    );
    return a[0] += r * l, t.getTileCoordForCoordAndZ(a, i);
  }
  return e;
}
function N0(t, e, n, i) {
  i = i !== void 0 ? i : "top-left";
  const a = cm(t, e, n);
  return new sm({
    extent: t,
    origin: k_(t, i),
    resolutions: a,
    tileSize: n
  });
}
function W0(t) {
  const e = t || {}, n = e.extent || on("EPSG:3857").getExtent(), i = {
    extent: n,
    minZoom: e.minZoom,
    tileSize: e.tileSize,
    resolutions: cm(
      n,
      e.maxZoom,
      e.tileSize,
      e.maxResolution
    )
  };
  return new sm(i);
}
function cm(t, e, n, i) {
  e = e !== void 0 ? e : P_, n = Dt(n !== void 0 ? n : uu);
  const a = Mt(t), o = ke(t);
  i = i > 0 ? i : Math.max(o / n[0], a / n[1]);
  const r = e + 1, l = new Array(r);
  for (let s = 0; s < r; ++s)
    l[s] = i / Math.pow(2, s);
  return l;
}
function $0(t, e, n, i) {
  const a = Fu(t);
  return N0(a, e, n, i);
}
function Fu(t) {
  t = on(t);
  let e = t.getExtent();
  if (!e) {
    const n = 180 * cu.degrees / t.getMetersPerUnit();
    e = Mi(-n, -n, n, n);
  }
  return e;
}
class X0 extends lm {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      projection: e.projection,
      state: e.state,
      wrapX: e.wrapX,
      interpolate: e.interpolate
    }), this.on, this.once, this.un, this.opaque_ = e.opaque !== void 0 ? e.opaque : !1, this.tilePixelRatio_ = e.tilePixelRatio !== void 0 ? e.tilePixelRatio : 1, this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : null;
    const n = [256, 256];
    this.tileGrid && Dt(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), n), this.tileCache = new rm(e.cacheSize || 0), this.tmpSize = [0, 0], this.key_ = e.key || "", this.tileOptions = {
      transition: e.transition,
      interpolate: e.interpolate
    }, this.zDirection = e.zDirection ? e.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, n) {
    const i = this.getTileCacheForProjection(e);
    i && i.expireCache(n);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(e, n, i, a) {
    const o = this.getTileCacheForProjection(e);
    if (!o)
      return !1;
    let r = !0, l, s, u;
    for (let c = i.minX; c <= i.maxX; ++c)
      for (let d = i.minY; d <= i.maxY; ++d)
        s = ol(n, c, d), u = !1, o.containsKey(s) && (l = /** @type {!import("../Tile.js").default} */
        o.get(s), u = l.getState() === fe.LOADED, u && (u = a(l) !== !1)), u || (r = !1);
    return r;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(e) {
    this.key_ !== e && (this.key_ = e, this.changed());
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.opaque_;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    const n = e ? this.getTileGridForProjection(e) : this.tileGrid;
    return n ? n.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(e, n, i, a, o) {
    return Re();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    return this.tileGrid ? this.tileGrid : um(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(e) {
    const n = this.getProjection();
    return Ee(
      n === null || na(n, e),
      "A VectorTile source can only be rendered if it has a projection compatible with the view projection."
    ), this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, n, i) {
    const a = this.getTileGridForProjection(i), o = this.getTilePixelRatio(n), r = Dt(a.getTileSize(e), this.tmpSize);
    return o == 1 ? r : VS(r, o, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(e, n) {
    n = n !== void 0 ? n : this.getProjection();
    const i = this.getTileGridForProjection(n);
    return this.getWrapX() && n.isGlobal() && (e = G0(i, e, n)), D0(e, i) ? e : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear(), super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(e, n) {
    const i = this.getTileCacheForProjection(n);
    e > i.highWaterMark && (i.highWaterMark = e);
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(e, n, i, a) {
  }
}
class U0 extends li {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(e, n) {
    super(e), this.tile = n;
  }
}
function Y0(t, e) {
  const n = /\{z\}/g, i = /\{x\}/g, a = /\{y\}/g, o = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(r, l, s) {
      if (r)
        return t.replace(n, r[0].toString()).replace(i, r[1].toString()).replace(a, r[2].toString()).replace(o, function() {
          const u = r[0], c = e.getFullTileRange(u);
          if (!c)
            throw new Error(
              "The {-y} placeholder requires a tile grid with extent"
            );
          return (c.getHeight() - r[2] - 1).toString();
        });
    }
  );
}
function j0(t, e) {
  const n = t.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = Y0(t[a], e);
  return H0(i);
}
function H0(t) {
  return t.length === 1 ? t[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(e, n, i) {
      if (!e)
        return;
      const a = O0(e), o = ga(a, t.length);
      return t[o](e, n, i);
    }
  );
}
function Z0(t) {
  const e = [];
  let n = /\{([a-z])-([a-z])\}/.exec(t);
  if (n) {
    const i = n[1].charCodeAt(0), a = n[2].charCodeAt(0);
    let o;
    for (o = i; o <= a; ++o)
      e.push(t.replace(n[0], String.fromCharCode(o)));
    return e;
  }
  if (n = /\{(\d+)-(\d+)\}/.exec(t), n) {
    const i = parseInt(n[2], 10);
    for (let a = parseInt(n[1], 10); a <= i; a++)
      e.push(t.replace(n[0], a.toString()));
    return e;
  }
  return e.push(t), e;
}
class ku extends X0 {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tilePixelRatio: e.tilePixelRatio,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === ku.prototype.tileUrlFunction, this.tileLoadFunction = e.tileLoadFunction, e.tileUrlFunction && (this.tileUrlFunction = e.tileUrlFunction), this.urls = null, e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const n = (
      /** @type {import("../Tile.js").default} */
      e.target
    ), i = Ve(n), a = n.getState();
    let o;
    a == fe.LOADING ? (this.tileLoadingKeys_[i] = !0, o = kl.TILELOADSTART) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], o = a == fe.ERROR ? kl.TILELOADERROR : a == fe.LOADED ? kl.TILELOADEND : void 0), o != null && this.dispatchEvent(new U0(o, n));
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(e) {
    this.tileCache.clear(), this.tileLoadFunction = e, this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(e, n) {
    this.tileUrlFunction = e, this.tileCache.pruneExceptNewestZ(), typeof n < "u" ? this.setKey(n) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(e) {
    const n = Z0(e);
    this.urls = n, this.setUrls(n);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(e) {
    this.urls = e;
    const n = e.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(j0(e, this.tileGrid), n) : this.setKey(n);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(e, n, i) {
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(e, n, i) {
    const a = ol(e, n, i);
    this.tileCache.containsKey(a) && this.tileCache.get(a);
  }
}
class K0 extends ku {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : q0,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.crossOrigin = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.tileClass = e.tileClass !== void 0 ? e.tileClass : am, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache())
      return !0;
    for (const e in this.tileCacheForProjection)
      if (this.tileCacheForProjection[e].canExpireCache())
        return !0;
    return !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, n) {
    const i = this.getTileCacheForProjection(e);
    this.tileCache.expireCache(
      this.tileCache == i ? n : {}
    );
    for (const a in this.tileCacheForProjection) {
      const o = this.tileCacheForProjection[a];
      o.expireCache(o == i ? n : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return this.getProjection() && e && !na(this.getProjection(), e) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let e = super.getKey();
    return this.getInterpolate() || (e += ":disable-interpolation"), e;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.getProjection() && e && !na(this.getProjection(), e) ? !1 : super.getOpaque(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    const n = this.getProjection();
    if (this.tileGrid && (!n || na(n, e)))
      return this.tileGrid;
    const i = Ve(e);
    return i in this.tileGridForProjection || (this.tileGridForProjection[i] = um(e)), this.tileGridForProjection[i];
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(e) {
    const n = this.getProjection();
    if (!n || na(n, e))
      return this.tileCache;
    const i = Ve(e);
    return i in this.tileCacheForProjection || (this.tileCacheForProjection[i] = new rm(
      this.tileCache.highWaterMark
    )), this.tileCacheForProjection[i];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(e, n, i, a, o, r) {
    const l = [e, n, i], s = this.getTileCoordForTileUrlFunction(
      l,
      o
    ), u = s ? this.tileUrlFunction(s, a, o) : void 0, c = new this.tileClass(
      l,
      u !== void 0 ? fe.IDLE : fe.EMPTY,
      u !== void 0 ? u : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return c.key = r, c.addEventListener(Se.CHANGE, this.handleTileChange.bind(this)), c;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(e, n, i, a, o) {
    const r = this.getProjection();
    if (!r || !o || na(r, o))
      return this.getTileInternal(
        e,
        n,
        i,
        a,
        r || o
      );
    const l = this.getTileCacheForProjection(o), s = [e, n, i];
    let u;
    const c = om(s);
    l.containsKey(c) && (u = l.get(c));
    const d = this.getKey();
    if (u && u.key == d)
      return u;
    const h = this.getTileGridForProjection(r), f = this.getTileGridForProjection(o), g = this.getTileCoordForTileUrlFunction(
      s,
      o
    ), m = new ms(
      r,
      h,
      o,
      f,
      s,
      g,
      this.getTilePixelRatio(a),
      this.getGutter(),
      (v, y, C, M) => this.getTileInternal(v, y, C, M, r),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    return m.key = d, u ? (m.interimTile = u, m.refreshInterimChain(), l.replace(c, m)) : l.set(c, m), m;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(e, n, i, a, o) {
    let r = null;
    const l = ol(e, n, i), s = this.getKey();
    if (!this.tileCache.containsKey(l))
      r = this.createTile_(e, n, i, a, o, s), this.tileCache.set(l, r);
    else if (r = this.tileCache.get(l), r.key != s) {
      const u = r;
      r = this.createTile_(e, n, i, a, o, s), u.getState() == fe.IDLE ? r.interimTile = u.interimTile : r.interimTile = u, r.refreshInterimChain(), this.tileCache.replace(l, r);
    }
    return r;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(e) {
    if (this.renderReprojectionEdges_ != e) {
      this.renderReprojectionEdges_ = e;
      for (const n in this.tileCacheForProjection)
        this.tileCacheForProjection[n].clear();
      this.changed();
    }
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(e, n) {
    const i = on(e);
    if (i) {
      const a = Ve(i);
      a in this.tileGridForProjection || (this.tileGridForProjection[a] = n);
    }
  }
  clear() {
    super.clear();
    for (const e in this.tileCacheForProjection)
      this.tileCacheForProjection[e].clear();
  }
}
function q0(t, e) {
  t.getImage().src = e;
}
class J0 extends K0 {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(e) {
    e = e || {};
    const n = e.projection !== void 0 ? e.projection : "EPSG:3857", i = e.tileGrid !== void 0 ? e.tileGrid : W0({
      extent: Fu(n),
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom,
      minZoom: e.minZoom,
      tileSize: e.tileSize
    });
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      opaque: e.opaque,
      projection: n,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileGrid: i,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
}
const Q0 = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
class eM extends J0 {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(e) {
    e = e || {};
    let n;
    e.attributions !== void 0 ? n = e.attributions : n = [Q0];
    const i = e.crossOrigin !== void 0 ? e.crossOrigin : "anonymous", a = e.url !== void 0 ? e.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions: n,
      attributionsCollapsible: !1,
      cacheSize: e.cacheSize,
      crossOrigin: i,
      interpolate: e.interpolate,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 19,
      opaque: e.opaque !== void 0 ? e.opaque : !0,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileLoadFunction: e.tileLoadFunction,
      transition: e.transition,
      url: a,
      wrapX: e.wrapX,
      zDirection: e.zDirection
    });
  }
}
class Ou extends _n {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(e) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), e)
      if (typeof /** @type {?} */
      e.getSimplifiedGeometry == "function") {
        const n = (
          /** @type {Geometry} */
          e
        );
        this.setGeometry(n);
      } else {
        const n = e;
        this.setProperties(n);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const e = (
      /** @type {Feature<Geometry>} */
      new Ou(this.hasProperties() ? this.getProperties() : null)
    );
    e.setGeometryName(this.getGeometryName());
    const n = this.getGeometry();
    n && e.setGeometry(
      /** @type {Geometry} */
      n.clone()
    );
    const i = this.getStyle();
    return i && e.setStyle(i), e;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && ($e(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const e = this.getGeometry();
    e && (this.geometryChangeKey_ = we(
      e,
      Se.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(e) {
    this.set(this.geometryName_, e);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(e) {
    this.style_ = e, this.styleFunction_ = e ? tM(e) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(e) {
    this.id_ = e, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(e) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = e, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
}
function tM(t) {
  if (typeof t == "function")
    return t;
  let e;
  return Array.isArray(t) ? e = t : (Ee(
    typeof /** @type {?} */
    t.getZIndex == "function",
    "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
  ), e = [
    /** @type {import("./style/Style.js").default} */
    t
  ]), function() {
    return e;
  };
}
const er = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class nM extends Zr {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    e = e || {};
    const n = Object.assign({}, e);
    delete n.preload, delete n.useInterimTilesOnError, super(n), this.on, this.once, this.un, this.setPreload(e.preload !== void 0 ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(er.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(er.PRELOAD, e);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(er.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(er.USE_INTERIM_TILES_ON_ERROR, e);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
}
class iM extends Vo {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = e;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return Re();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return Re();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(e, n) {
    return Re();
  }
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, n, i) {
    e[n] || (e[n] = {}), e[n][i.tileCoord.toString()] = i;
  }
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(e, n, i) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      (a, o) => {
        const r = this.loadedTileCallback.bind(this, i, a);
        return e.forEachLoadedTile(n, a, o, r);
      }
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, n, i, a, o) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(e) {
    const n = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    (n.getState() === Me.LOADED || n.getState() === Me.ERROR) && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(e) {
    let n = e.getState();
    return n != Me.LOADED && n != Me.ERROR && e.addEventListener(Se.CHANGE, this.boundHandleImageChange_), n == Me.IDLE && (e.load(), n = e.getState()), n == Me.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const e = this.getLayer();
    e && e.getVisible() && e.getSourceState() === "ready" && e.changed();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(e) {
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
class dm {
  constructor() {
    /**
     * @private
     * @param {...*} args Args.
     * @return {ZIndexContext} This.
     */
    Yu(this, "pushMethodArgs_", (...e) => (this.instructions_[this.zIndex + this.offset_].push(e), this));
    this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(Sr(), {
      get: (e, n) => {
        if (typeof /** @type {*} */
        Sr()[n] == "function")
          return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(n), this.pushMethodArgs_;
      },
      set: (e, n, i) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(n, i), !0)
    });
  }
  /**
   * Push a function that renders to the context directly.
   * @param {function(CanvasRenderingContext2D): void} render Function.
   */
  pushFunction(e) {
    this.instructions_[this.zIndex + this.offset_].push(e);
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(e) {
    this.instructions_.forEach((n) => {
      for (let i = 0, a = n.length; i < a; ++i) {
        const o = n[i];
        if (typeof o == "function") {
          o(e);
          continue;
        }
        const r = n[++i];
        if (typeof /** @type {*} */
        e[o] == "function")
          e[o](...r);
        else {
          if (typeof r == "function") {
            e[o] = r(e);
            continue;
          }
          e[o] = r;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length, this.zIndex = 0;
  }
}
const Fd = [];
let ra = null;
function aM() {
  ra = dt(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class hm extends iM {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(e), this.container = null, this.renderedResolution, this.tempTransform = hn(), this.pixelTransform = hn(), this.inversePixelTransform = hn(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(e, n, i) {
    ra || aM(), ra.clearRect(0, 0, 1, 1);
    let a;
    try {
      ra.drawImage(e, n, i, 1, 1, 0, 0, 1, 1), a = ra.getImageData(0, 0, 1, 1).data;
    } catch {
      return ra = null, null;
    }
    return a;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(e) {
    let i = this.getLayer().getBackground();
    return typeof i == "function" && (i = i(e.viewState.resolution)), i || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(e, n, i) {
    const a = this.getLayer().getClassName();
    let o, r;
    if (e && e.className === a && (!i || e && e.style.backgroundColor && Ei(
      co(e.style.backgroundColor),
      co(i)
    ))) {
      const l = e.firstElementChild;
      l instanceof HTMLCanvasElement && (r = l.getContext("2d"));
    }
    if (r && r.canvas.style.transform === n ? (this.container = e, this.context = r, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
      o = document.createElement("div"), o.className = a;
      let l = o.style;
      l.position = "absolute", l.width = "100%", l.height = "100%", r = dt();
      const s = r.canvas;
      o.appendChild(s), l = s.style, l.position = "absolute", l.left = "0", l.transformOrigin = "top left", this.container = o, this.context = r;
    }
    !this.containerReused && i && !this.container.style.backgroundColor && (this.container.style.backgroundColor = i);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(e, n, i) {
    const a = Ui(i), o = Yr(i), r = Ur(i), l = Xr(i);
    ut(n.coordinateToPixelTransform, a), ut(n.coordinateToPixelTransform, o), ut(n.coordinateToPixelTransform, r), ut(n.coordinateToPixelTransform, l);
    const s = this.inversePixelTransform;
    ut(s, a), ut(s, o), ut(s, r), ut(s, l), e.save(), e.beginPath(), e.moveTo(Math.round(a[0]), Math.round(a[1])), e.lineTo(Math.round(o[0]), Math.round(o[1])), e.lineTo(Math.round(r[0]), Math.round(r[1])), e.lineTo(Math.round(l[0]), Math.round(l[1])), e.clip();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */
  prepareContainer(e, n) {
    const i = e.extent, a = e.viewState.resolution, o = e.viewState.rotation, r = e.pixelRatio, l = Math.round(ke(i) / a * r), s = Math.round(Mt(i) / a * r);
    ii(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / r,
      1 / r,
      o,
      -l / 2,
      -s / 2
    ), yg(this.inversePixelTransform, this.pixelTransform);
    const u = iS(this.pixelTransform);
    if (this.useContainer(n, u, this.getBackground(e)), !this.containerReused) {
      const c = this.context.canvas;
      c.width != l || c.height != s ? (c.width = l, c.height = s) : this.context.clearRect(0, 0, l, s), u !== c.style.transform && (c.style.transform = u);
    }
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, n, i) {
    const a = this.getLayer();
    if (a.hasListener(e)) {
      const o = new Kg(
        e,
        this.inversePixelTransform,
        i,
        n
      );
      a.dispatchEvent(o);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, n) {
    this.frameState = n, !n.declutter && this.dispatchRenderEvent_(Qt.PRERENDER, e, n);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, n) {
    n.declutter || this.dispatchRenderEvent_(Qt.POSTRENDER, e, n);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(e) {
    return e.declutter && !this.deferredContext_ && (this.deferredContext_ = new dm()), e.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(e) {
    e.declutter && (this.dispatchRenderEvent_(
      Qt.PRERENDER,
      this.context,
      e
    ), e.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(e), this.dispatchRenderEvent_(
      Qt.POSTRENDER,
      this.context,
      e
    ));
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(e, n, i, a, o, r, l) {
    const s = o / 2, u = r / 2, c = a / n, d = -c, h = -e[0] + l, f = -e[1];
    return ii(
      this.tempTransform,
      s,
      u,
      c,
      d,
      -i,
      h,
      f
    );
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
class oM extends hm {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(e) {
    super(e), this.extentChanged = !0, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = !1, this.tmpExtent = an(), this.tmpTileRange_ = new Bu(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(e) {
    const n = this.getLayer(), i = e.getState(), a = n.getUseInterimTilesOnError();
    return i == fe.LOADED || i == fe.EMPTY || i == fe.ERROR && !a;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(e, n, i, a) {
    const o = a.pixelRatio, r = a.viewState.projection, l = this.getLayer();
    let u = l.getSource().getTile(e, n, i, o, r);
    return u.getState() == fe.ERROR && l.getUseInterimTilesOnError() && l.getPreload() > 0 && (this.newTiles_ = !0), this.isDrawableTile(u) || (u = u.getInterimTile()), u;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const n = this.frameState;
    if (!n)
      return null;
    const i = this.getLayer(), a = ut(
      n.pixelToCoordinateTransform,
      e.slice()
    ), o = i.getExtent();
    if (o && !Ma(o, a))
      return null;
    const r = n.pixelRatio, l = n.viewState.projection, s = n.viewState, u = i.getRenderSource(), c = u.getTileGridForProjection(s.projection), d = u.getTilePixelRatio(n.pixelRatio);
    for (let h = c.getZForResolution(s.resolution); h >= c.getMinZoom(); --h) {
      const f = c.getTileCoordForCoordAndZ(a, h), g = u.getTile(
        h,
        f[1],
        f[2],
        r,
        l
      );
      if (!(g instanceof am || g instanceof ms) || g instanceof ms && g.getState() === fe.EMPTY)
        return null;
      if (g.getState() !== fe.LOADED)
        continue;
      const m = c.getOrigin(h), v = Dt(c.getTileSize(h)), y = c.getResolution(h), C = Math.floor(
        d * ((a[0] - m[0]) / y - f[1] * v[0])
      ), M = Math.floor(
        d * ((m[1] - a[1]) / y - f[2] * v[1])
      ), p = Math.round(
        d * u.getGutterForProjection(s.projection)
      );
      return this.getImageData(g.getImage(), C + p, M + p);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, n, i) {
    return this.isDrawableTile(i) ? super.loadedTileCallback(e, n, i) : !1;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, n) {
    const i = e.layerStatesArray[e.layerIndex], a = e.viewState, o = a.projection, r = a.resolution, l = a.center, s = a.rotation, u = e.pixelRatio, c = this.getLayer(), d = c.getSource(), h = d.getRevision(), f = d.getTileGridForProjection(o), g = f.getZForResolution(r, d.zDirection), m = f.getResolution(g);
    let v = e.extent;
    const y = e.viewState.resolution, C = d.getTilePixelRatio(u);
    this.prepareContainer(e, n);
    const M = this.context.canvas.width, p = this.context.canvas.height, b = i.extent && Fi(i.extent);
    b && (v = Ka(
      v,
      Fi(i.extent)
    ));
    const P = m * M / 2 / C, x = m * p / 2 / C, _ = [
      l[0] - P,
      l[1] - x,
      l[0] + P,
      l[1] + x
    ], T = f.getTileRangeForExtentAndZ(v, g), B = {};
    B[g] = {};
    const L = this.createLoadedTileFinder(
      d,
      o,
      B
    ), z = this.tmpExtent, I = this.tmpTileRange_;
    this.newTiles_ = !1;
    const k = s ? rs(
      a.center,
      y,
      s,
      e.size
    ) : void 0;
    for (let R = T.minX; R <= T.maxX; ++R)
      for (let V = T.minY; V <= T.maxY; ++V) {
        if (s && !f.tileCoordIntersectsViewport([g, R, V], k))
          continue;
        const X = this.getTile(g, R, V, e);
        if (this.isDrawableTile(X)) {
          const ce = Ve(this);
          if (X.getState() == fe.LOADED) {
            B[g][X.tileCoord.toString()] = X;
            let K = X.inTransition(ce);
            K && i.opacity !== 1 && (X.endTransition(ce), K = !1), !this.newTiles_ && (K || !this.renderedTiles.includes(X)) && (this.newTiles_ = !0);
          }
          if (X.getAlpha(ce, e.time) === 1)
            continue;
        }
        const D = f.getTileCoordChildTileRange(
          X.tileCoord,
          I,
          z
        );
        let Y = !1;
        D && (Y = L(g + 1, D)), Y || f.forEachTileCoordParentTileRange(
          X.tileCoord,
          L,
          I,
          z
        );
      }
    const G = m / r * u / C, F = this.getRenderContext(e);
    ii(
      this.tempTransform,
      M / 2,
      p / 2,
      G,
      G,
      0,
      -M / 2,
      -p / 2
    ), b && this.clipUnrotated(F, e, b), d.getInterpolate() || (F.imageSmoothingEnabled = !1), this.preRender(F, e), this.renderedTiles.length = 0;
    let q = Object.keys(B).map(Number);
    q.sort(ei);
    let j, ne, A;
    i.opacity === 1 && (!this.containerReused || d.getOpaque(e.viewState.projection)) ? q = q.reverse() : (j = [], ne = []);
    for (let R = q.length - 1; R >= 0; --R) {
      const V = q[R], X = d.getTilePixelSize(
        V,
        u,
        o
      ), Y = f.getResolution(V) / m, ce = X[0] * Y * G, K = X[1] * Y * G, se = f.getTileCoordForCoordAndZ(
        Ui(_),
        V
      ), ge = f.getTileCoordExtent(se), $ = ut(this.tempTransform, [
        C * (ge[0] - _[0]) / m,
        C * (_[3] - ge[3]) / m
      ]), ae = C * d.getGutterForProjection(o), ye = B[V];
      for (const me in ye) {
        const ze = (
          /** @type {import("../../ImageTile.js").default} */
          ye[me]
        ), je = ze.tileCoord, He = se[1] - je[1], xe = Math.round($[0] - (He - 1) * ce), De = se[2] - je[2], Ze = Math.round($[1] - (De - 1) * K), Et = Math.round($[0] - He * ce), St = Math.round($[1] - De * K), Xt = xe - Et, Sn = Ze - St, Ut = g === V, bn = Ut && ze.getAlpha(Ve(this), e.time) !== 1;
        let Ai = !1;
        if (!bn)
          if (j) {
            A = [Et, St, Et + Xt, St, Et + Xt, St + Sn, Et, St + Sn];
            for (let ui = 0, ji = j.length; ui < ji; ++ui)
              if (g !== V && V < ne[ui]) {
                const st = j[ui];
                zt(
                  [Et, St, Et + Xt, St + Sn],
                  [st[0], st[3], st[4], st[7]]
                ) && (Ai || (F.save(), Ai = !0), F.beginPath(), F.moveTo(A[0], A[1]), F.lineTo(A[2], A[3]), F.lineTo(A[4], A[5]), F.lineTo(A[6], A[7]), F.moveTo(st[6], st[7]), F.lineTo(st[4], st[5]), F.lineTo(st[2], st[3]), F.lineTo(st[0], st[1]), F.clip());
              }
            j.push(A), ne.push(V);
          } else
            F.clearRect(Et, St, Xt, Sn);
        this.drawTileImage(
          ze,
          e,
          Et,
          St,
          Xt,
          Sn,
          ae,
          Ut
        ), j && !bn ? (Ai && F.restore(), this.renderedTiles.unshift(ze)) : this.renderedTiles.push(ze), this.updateUsedTiles(e.usedTiles, d, ze);
      }
    }
    return this.renderedRevision = h, this.renderedResolution = m, this.extentChanged = !this.renderedExtent_ || !ro(this.renderedExtent_, _), this.renderedExtent_ = _, this.renderedPixelRatio = u, this.renderedProjection = o, this.manageTilePyramid(
      e,
      d,
      f,
      u,
      o,
      v,
      g,
      c.getPreload()
    ), this.scheduleExpireCache(e, d), this.postRender(this.context, e), i.extent && F.restore(), F.imageSmoothingEnabled = !0, this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(e, n, i, a, o, r, l, s) {
    const u = this.getTileImage(e);
    if (!u)
      return;
    const c = this.getRenderContext(n), d = Ve(this), h = n.layerStatesArray[n.layerIndex], f = h.opacity * (s ? e.getAlpha(d, n.time) : 1), g = f !== c.globalAlpha;
    g && (c.save(), c.globalAlpha = f), c.drawImage(
      u,
      l,
      l,
      u.width - 2 * l,
      u.height - 2 * l,
      i,
      a,
      o,
      r
    ), g && c.restore(), f !== h.opacity ? n.animate = !0 : s && e.endTransition(d);
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const e = this.context;
    return e ? e.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(e) {
    return e.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(e, n) {
    if (n.canExpireCache()) {
      const i = (function(a, o, r) {
        const l = Ve(a);
        l in r.usedTiles && a.expireCache(
          r.viewState.projection,
          r.usedTiles[l]
        );
      }).bind(null, n);
      e.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        i
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(e, n, i) {
    const a = Ve(n);
    a in e || (e[a] = {}), e[a][i.getKey()] = !0;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(e, n, i, a, o, r, l, s, u) {
    const c = Ve(n);
    c in e.wantedTiles || (e.wantedTiles[c] = {});
    const d = e.wantedTiles[c], h = e.tileQueue, f = i.getMinZoom(), g = e.viewState.rotation, m = g ? rs(
      e.viewState.center,
      e.viewState.resolution,
      g,
      e.size
    ) : void 0;
    let v = 0, y, C, M, p, b, P;
    for (P = f; P <= l; ++P)
      for (C = i.getTileRangeForExtentAndZ(r, P, C), M = i.getResolution(P), p = C.minX; p <= C.maxX; ++p)
        for (b = C.minY; b <= C.maxY; ++b)
          g && !i.tileCoordIntersectsViewport([P, p, b], m) || (l - P <= s ? (++v, y = n.getTile(P, p, b, a, o), y.getState() == fe.IDLE && (d[y.getKey()] = !0, h.isKeyQueued(y.getKey()) || h.enqueue([
            y,
            c,
            i.getTileCoordCenter(y.tileCoord),
            M
          ])), u !== void 0 && u(y)) : n.useTile(P, p, b, o));
    n.updateCacheSize(v, o);
  }
}
class rM extends nM {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new oM(this);
  }
}
const de = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, tr = [de.FILL], Ci = [de.STROKE], Di = [de.BEGIN_PATH], kd = [de.CLOSE_PATH];
class fm {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(e, n, i, a, o) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(e) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(e) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(e, n, i) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} [index] Render order index.
   */
  drawFeature(e, n, i) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawGeometryCollection(e, n, i) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(e, n, i) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(e, n, i) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(e, n, i) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(e, n, i) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(e, n, i) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(e, n, i) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(e, n, i) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, n) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(e, n) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(e, n) {
  }
}
class No extends fm {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, n, i, a) {
    super(), this.tolerance = e, this.maxExtent = n, this.pixelRatio = a, this.maxLineWidth = 0, this.resolution = i, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(e) {
    const n = this.pixelRatio;
    return n == 1 ? e : e.map(function(i) {
      return i * n;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(e, n) {
    const i = this.getBufferedMaxExtent(), a = this.tmpCoordinate_, o = this.coordinates;
    let r = o.length;
    for (let l = 0, s = e.length; l < s; l += n)
      a[0] = e[l], a[1] = e[l + 1], Ma(i, a) && (o[r++] = a[0], o[r++] = a[1]);
    return r;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(e, n, i, a, o, r) {
    const l = this.coordinates;
    let s = l.length;
    const u = this.getBufferedMaxExtent();
    r && (n += a);
    let c = e[n], d = e[n + 1];
    const h = this.tmpCoordinate_;
    let f = !0, g, m, v;
    for (g = n + a; g < i; g += a)
      h[0] = e[g], h[1] = e[g + 1], v = is(u, h), v !== m ? (f && (l[s++] = c, l[s++] = d, f = !1), l[s++] = h[0], l[s++] = h[1]) : v === ot.INTERSECTING ? (l[s++] = h[0], l[s++] = h[1], f = !1) : f = !0, c = h[0], d = h[1], m = v;
    return (o && f || g === n + a) && (l[s++] = c, l[s++] = d), s;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(e, n, i, a, o) {
    for (let r = 0, l = i.length; r < l; ++r) {
      const s = i[r], u = this.appendFlatLineCoordinates(
        e,
        n,
        s,
        a,
        !1,
        !1
      );
      o.push(u), n = s;
    }
    return n;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(e, n, i, a, o) {
    this.beginGeometry(e, n, o);
    const r = e.getType(), l = e.getStride(), s = this.coordinates.length;
    let u, c, d, h, f;
    switch (r) {
      case "MultiPolygon":
        u = /** @type {import("../../geom/MultiPolygon.js").default} */
        e.getOrientedFlatCoordinates(), h = [];
        const g = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        f = 0;
        for (let m = 0, v = g.length; m < v; ++m) {
          const y = [];
          f = this.drawCustomCoordinates_(
            u,
            f,
            g[m],
            l,
            y
          ), h.push(y);
        }
        this.instructions.push([
          de.CUSTOM,
          s,
          h,
          e,
          i,
          cd,
          o
        ]), this.hitDetectionInstructions.push([
          de.CUSTOM,
          s,
          h,
          e,
          a || i,
          cd,
          o
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        d = [], u = r == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          e.getOrientedFlatCoordinates()
        ) : e.getFlatCoordinates(), f = this.drawCustomCoordinates_(
          u,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          e.getEnds(),
          l,
          d
        ), this.instructions.push([
          de.CUSTOM,
          s,
          d,
          e,
          i,
          _r,
          o
        ]), this.hitDetectionInstructions.push([
          de.CUSTOM,
          s,
          d,
          e,
          a || i,
          _r,
          o
        ]);
        break;
      case "LineString":
      case "Circle":
        u = e.getFlatCoordinates(), c = this.appendFlatLineCoordinates(
          u,
          0,
          u.length,
          l,
          !1,
          !1
        ), this.instructions.push([
          de.CUSTOM,
          s,
          c,
          e,
          i,
          ca,
          o
        ]), this.hitDetectionInstructions.push([
          de.CUSTOM,
          s,
          c,
          e,
          a || i,
          ca,
          o
        ]);
        break;
      case "MultiPoint":
        u = e.getFlatCoordinates(), c = this.appendFlatPointCoordinates(u, l), c > s && (this.instructions.push([
          de.CUSTOM,
          s,
          c,
          e,
          i,
          ca,
          o
        ]), this.hitDetectionInstructions.push([
          de.CUSTOM,
          s,
          c,
          e,
          a || i,
          ca,
          o
        ]));
        break;
      case "Point":
        u = e.getFlatCoordinates(), this.coordinates.push(u[0], u[1]), c = this.coordinates.length, this.instructions.push([
          de.CUSTOM,
          s,
          c,
          e,
          i,
          void 0,
          o
        ]), this.hitDetectionInstructions.push([
          de.CUSTOM,
          s,
          c,
          e,
          a || i,
          void 0,
          o
        ]);
        break;
    }
    this.endGeometry(n);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} index Render order index
   */
  beginGeometry(e, n, i) {
    this.beginGeometryInstruction1_ = [
      de.BEGIN_GEOMETRY,
      n,
      0,
      e,
      i
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      de.BEGIN_GEOMETRY,
      n,
      0,
      e,
      i
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const e = this.hitDetectionInstructions;
    e.reverse();
    let n;
    const i = e.length;
    let a, o, r = -1;
    for (n = 0; n < i; ++n)
      a = e[n], o = /** @type {import("./Instruction.js").default} */
      a[0], o == de.END_GEOMETRY ? r = n : o == de.BEGIN_GEOMETRY && (a[2] = n, C_(this.hitDetectionInstructions, r, n), r = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, n) {
    const i = this.state;
    if (e) {
      const a = e.getColor();
      i.fillPatternScale = a && typeof a == "object" && "src" in a ? this.pixelRatio : 1, i.fillStyle = An(
        a || It
      );
    } else
      i.fillStyle = void 0;
    if (n) {
      const a = n.getColor();
      i.strokeStyle = An(
        a || fo
      );
      const o = n.getLineCap();
      i.lineCap = o !== void 0 ? o : xa;
      const r = n.getLineDash();
      i.lineDash = r ? r.slice() : ti;
      const l = n.getLineDashOffset();
      i.lineDashOffset = l || ni;
      const s = n.getLineJoin();
      i.lineJoin = s !== void 0 ? s : Pa;
      const u = n.getWidth();
      i.lineWidth = u !== void 0 ? u : mo;
      const c = n.getMiterLimit();
      i.miterLimit = c !== void 0 ? c : ho, i.lineWidth > this.maxLineWidth && (this.maxLineWidth = i.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      i.strokeStyle = void 0, i.lineCap = void 0, i.lineDash = null, i.lineDashOffset = void 0, i.lineJoin = void 0, i.lineWidth = void 0, i.miterLimit = void 0;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(e) {
    const n = e.fillStyle, i = [de.SET_FILL_STYLE, n];
    return typeof n != "string" && i.push(e.fillPatternScale), i;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    this.instructions.push(this.createStroke(e));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(e) {
    return [
      de.SET_STROKE_STYLE,
      e.strokeStyle,
      e.lineWidth * this.pixelRatio,
      e.lineCap,
      e.lineJoin,
      e.miterLimit,
      this.applyPixelRatio(e.lineDash),
      e.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(e, n) {
    const i = e.fillStyle;
    (typeof i != "string" || e.currentFillStyle != i) && (i !== void 0 && this.instructions.push(n.call(this, e)), e.currentFillStyle = i);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(e, n) {
    const i = e.strokeStyle, a = e.lineCap, o = e.lineDash, r = e.lineDashOffset, l = e.lineJoin, s = e.lineWidth, u = e.miterLimit;
    (e.currentStrokeStyle != i || e.currentLineCap != a || o != e.currentLineDash && !Ei(e.currentLineDash, o) || e.currentLineDashOffset != r || e.currentLineJoin != l || e.currentLineWidth != s || e.currentMiterLimit != u) && (i !== void 0 && n.call(this, e), e.currentStrokeStyle = i, e.currentLineCap = a, e.currentLineDash = o, e.currentLineDashOffset = r, e.currentLineJoin = l, e.currentLineWidth = s, e.currentMiterLimit = u);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(e) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const n = [de.END_GEOMETRY, e];
    this.instructions.push(n), this.hitDetectionInstructions.push(n);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = ng(this.maxExtent), this.maxLineWidth > 0)) {
      const e = this.resolution * (this.maxLineWidth + 1) / 2;
      du(this.bufferedMaxExtent_, e, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
class lM extends No {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, n, i, a) {
    super(e, n, i, a), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(e, n, i) {
    if (!this.image_ || this.maxExtent && !Ma(this.maxExtent, e.getFlatCoordinates()))
      return;
    this.beginGeometry(e, n, i);
    const a = e.getFlatCoordinates(), o = e.getStride(), r = this.coordinates.length, l = this.appendFlatPointCoordinates(a, o);
    this.instructions.push([
      de.DRAW_IMAGE,
      r,
      l,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      de.DRAW_IMAGE,
      r,
      l,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(e, n, i) {
    if (!this.image_)
      return;
    this.beginGeometry(e, n, i);
    const a = e.getFlatCoordinates(), o = [];
    for (let s = 0, u = a.length; s < u; s += e.getStride())
      (!this.maxExtent || Ma(this.maxExtent, a.slice(s, s + 2))) && o.push(
        a[s],
        a[s + 1]
      );
    const r = this.coordinates.length, l = this.appendFlatPointCoordinates(o, 2);
    this.instructions.push([
      de.DRAW_IMAGE,
      r,
      l,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      de.DRAW_IMAGE,
      r,
      l,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(n);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(e, n) {
    const i = e.getAnchor(), a = e.getSize(), o = e.getOrigin();
    this.imagePixelRatio_ = e.getPixelRatio(this.pixelRatio), this.anchorX_ = i[0], this.anchorY_ = i[1], this.hitDetectionImage_ = e.getHitDetectionImage(), this.image_ = e.getImage(this.pixelRatio), this.height_ = a[1], this.opacity_ = e.getOpacity(), this.originX_ = o[0], this.originY_ = o[1], this.rotateWithView_ = e.getRotateWithView(), this.rotation_ = e.getRotation(), this.scale_ = e.getScaleArray(), this.width_ = a[0], this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = n;
  }
}
class sM extends No {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, n, i, a) {
    super(e, n, i, a);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(e, n, i, a) {
    const o = this.coordinates.length, r = this.appendFlatLineCoordinates(
      e,
      n,
      i,
      a,
      !1,
      !1
    ), l = [
      de.MOVE_TO_LINE_TO,
      o,
      r
    ];
    return this.instructions.push(l), this.hitDetectionInstructions.push(l), i;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(e, n, i) {
    const a = this.state, o = a.strokeStyle, r = a.lineWidth;
    if (o === void 0 || r === void 0)
      return;
    this.updateStrokeStyle(a, this.applyStroke), this.beginGeometry(e, n, i), this.hitDetectionInstructions.push(
      [
        de.SET_STROKE_STYLE,
        a.strokeStyle,
        a.lineWidth,
        a.lineCap,
        a.lineJoin,
        a.miterLimit,
        ti,
        ni
      ],
      Di
    );
    const l = e.getFlatCoordinates(), s = e.getStride();
    this.drawFlatCoordinates_(
      l,
      0,
      l.length,
      s
    ), this.hitDetectionInstructions.push(Ci), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(e, n, i) {
    const a = this.state, o = a.strokeStyle, r = a.lineWidth;
    if (o === void 0 || r === void 0)
      return;
    this.updateStrokeStyle(a, this.applyStroke), this.beginGeometry(e, n, i), this.hitDetectionInstructions.push(
      [
        de.SET_STROKE_STYLE,
        a.strokeStyle,
        a.lineWidth,
        a.lineCap,
        a.lineJoin,
        a.miterLimit,
        ti,
        ni
      ],
      Di
    );
    const l = e.getEnds(), s = e.getFlatCoordinates(), u = e.getStride();
    let c = 0;
    for (let d = 0, h = l.length; d < h; ++d)
      c = this.drawFlatCoordinates_(
        s,
        c,
        /** @type {number} */
        l[d],
        u
      );
    this.hitDetectionInstructions.push(Ci), this.endGeometry(n);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = this.state;
    return e.lastStroke != null && e.lastStroke != this.coordinates.length && this.instructions.push(Ci), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    e.lastStroke != null && e.lastStroke != this.coordinates.length && (this.instructions.push(Ci), e.lastStroke = this.coordinates.length), e.lastStroke = 0, super.applyStroke(e), this.instructions.push(Di);
  }
}
class Od extends No {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, n, i, a) {
    super(e, n, i, a);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(e, n, i, a) {
    const o = this.state, r = o.fillStyle !== void 0, l = o.strokeStyle !== void 0, s = i.length;
    this.instructions.push(Di), this.hitDetectionInstructions.push(Di);
    for (let u = 0; u < s; ++u) {
      const c = i[u], d = this.coordinates.length, h = this.appendFlatLineCoordinates(
        e,
        n,
        c,
        a,
        !0,
        !l
      ), f = [
        de.MOVE_TO_LINE_TO,
        d,
        h
      ];
      this.instructions.push(f), this.hitDetectionInstructions.push(f), l && (this.instructions.push(kd), this.hitDetectionInstructions.push(kd)), n = c;
    }
    return r && (this.instructions.push(tr), this.hitDetectionInstructions.push(tr)), l && (this.instructions.push(Ci), this.hitDetectionInstructions.push(Ci)), n;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(e, n, i) {
    const a = this.state, o = a.fillStyle, r = a.strokeStyle;
    if (o === void 0 && r === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, n, i), a.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      de.SET_FILL_STYLE,
      It
    ]), a.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      de.SET_STROKE_STYLE,
      a.strokeStyle,
      a.lineWidth,
      a.lineCap,
      a.lineJoin,
      a.miterLimit,
      ti,
      ni
    ]);
    const l = e.getFlatCoordinates(), s = e.getStride(), u = this.coordinates.length;
    this.appendFlatLineCoordinates(
      l,
      0,
      l.length,
      s,
      !1,
      !1
    );
    const c = [de.CIRCLE, u];
    this.instructions.push(Di, c), this.hitDetectionInstructions.push(Di, c), a.fillStyle !== void 0 && (this.instructions.push(tr), this.hitDetectionInstructions.push(tr)), a.strokeStyle !== void 0 && (this.instructions.push(Ci), this.hitDetectionInstructions.push(Ci)), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(e, n, i) {
    const a = this.state, o = a.fillStyle, r = a.strokeStyle;
    if (o === void 0 && r === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, n, i), a.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      de.SET_FILL_STYLE,
      It
    ]), a.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      de.SET_STROKE_STYLE,
      a.strokeStyle,
      a.lineWidth,
      a.lineCap,
      a.lineJoin,
      a.miterLimit,
      ti,
      ni
    ]);
    const l = e.getEnds(), s = e.getOrientedFlatCoordinates(), u = e.getStride();
    this.drawFlatCoordinatess_(
      s,
      0,
      /** @type {Array<number>} */
      l,
      u
    ), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(e, n, i) {
    const a = this.state, o = a.fillStyle, r = a.strokeStyle;
    if (o === void 0 && r === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, n, i), a.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      de.SET_FILL_STYLE,
      It
    ]), a.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      de.SET_STROKE_STYLE,
      a.strokeStyle,
      a.lineWidth,
      a.lineCap,
      a.lineJoin,
      a.miterLimit,
      ti,
      ni
    ]);
    const l = e.getEndss(), s = e.getOrientedFlatCoordinates(), u = e.getStride();
    let c = 0;
    for (let d = 0, h = l.length; d < h; ++d)
      c = this.drawFlatCoordinatess_(
        s,
        c,
        l[d],
        u
      );
    this.endGeometry(n);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const e = this.tolerance;
    if (e !== 0) {
      const n = this.coordinates;
      for (let i = 0, a = n.length; i < a; ++i)
        n[i] = Vi(n[i], e);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const e = this.state;
    e.fillStyle !== void 0 && this.updateFillStyle(e, this.createFill), e.strokeStyle !== void 0 && this.updateStrokeStyle(e, this.applyStroke);
  }
}
function uM(t, e, n, i, a) {
  const o = [];
  let r = n, l = 0, s = e.slice(n, 2);
  for (; l < t && r + a < i; ) {
    const [u, c] = s.slice(-2), d = e[r + a], h = e[r + a + 1], f = Math.sqrt(
      (d - u) * (d - u) + (h - c) * (h - c)
    );
    if (l += f, l >= t) {
      const g = (t - l + f) / f, m = qt(u, d, g), v = qt(c, h, g);
      s.push(m, v), o.push(s), s = [m, v], l == t && (r += a), l = 0;
    } else if (l < t)
      s.push(
        e[r + a],
        e[r + a + 1]
      ), r += a;
    else {
      const g = f - l, m = qt(u, d, g / f), v = qt(c, h, g / f);
      s.push(m, v), o.push(s), s = [m, v], l = 0, r += a;
    }
  }
  return l > 0 && o.push(s), o;
}
function cM(t, e, n, i, a) {
  let o = n, r = n, l = 0, s = 0, u = n, c, d, h, f, g, m, v, y, C, M;
  for (d = n; d < i; d += a) {
    const p = e[d], b = e[d + 1];
    g !== void 0 && (C = p - g, M = b - m, f = Math.sqrt(C * C + M * M), v !== void 0 && (s += h, c = Math.acos((v * C + y * M) / (h * f)), c > t && (s > l && (l = s, o = u, r = d), s = 0, u = d - a)), h = f, v = C, y = M), g = p, m = b;
  }
  return s += f, s > l ? [u, d] : [o, r];
}
const Er = {
  left: 0,
  center: 0.5,
  right: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class dM extends No {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, n, i, a) {
    super(e, n, i, a), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[It] = { fillStyle: It }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = super.finish();
    return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(e, n, i) {
    const a = this.textFillState_, o = this.textStrokeState_, r = this.textState_;
    if (this.text_ === "" || !r || !a && !o)
      return;
    const l = this.coordinates;
    let s = l.length;
    const u = e.getType();
    let c = null, d = e.getStride();
    if (r.placement === "line" && (u == "LineString" || u == "MultiLineString" || u == "Polygon" || u == "MultiPolygon")) {
      if (!zt(this.maxExtent, e.getExtent()))
        return;
      let h;
      if (c = e.getFlatCoordinates(), u == "LineString")
        h = [c.length];
      else if (u == "MultiLineString")
        h = /** @type {import("../../geom/MultiLineString.js").default} */
        e.getEnds();
      else if (u == "Polygon")
        h = /** @type {import("../../geom/Polygon.js").default} */
        e.getEnds().slice(0, 1);
      else if (u == "MultiPolygon") {
        const v = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        h = [];
        for (let y = 0, C = v.length; y < C; ++y)
          h.push(v[y][0]);
      }
      this.beginGeometry(e, n, i);
      const f = r.repeat, g = f ? void 0 : r.textAlign;
      let m = 0;
      for (let v = 0, y = h.length; v < y; ++v) {
        let C;
        f ? C = uM(
          f * this.resolution,
          c,
          m,
          h[v],
          d
        ) : C = [c.slice(m, h[v])];
        for (let M = 0, p = C.length; M < p; ++M) {
          const b = C[M];
          let P = 0, x = b.length;
          if (g == null) {
            const T = cM(
              r.maxAngle,
              b,
              0,
              b.length,
              2
            );
            P = T[0], x = T[1];
          }
          for (let T = P; T < x; T += d)
            l.push(b[T], b[T + 1]);
          const _ = l.length;
          m = h[v], this.drawChars_(s, _), s = _;
        }
      }
      this.endGeometry(n);
    } else {
      let h = r.overflow ? null : [];
      switch (u) {
        case "Point":
        case "MultiPoint":
          c = /** @type {import("../../geom/MultiPoint.js").default} */
          e.getFlatCoordinates();
          break;
        case "LineString":
          c = /** @type {import("../../geom/LineString.js").default} */
          e.getFlatMidpoint();
          break;
        case "Circle":
          c = /** @type {import("../../geom/Circle.js").default} */
          e.getCenter();
          break;
        case "MultiLineString":
          c = /** @type {import("../../geom/MultiLineString.js").default} */
          e.getFlatMidpoints(), d = 2;
          break;
        case "Polygon":
          c = /** @type {import("../../geom/Polygon.js").default} */
          e.getFlatInteriorPoint(), r.overflow || h.push(c[2] / this.resolution), d = 3;
          break;
        case "MultiPolygon":
          const C = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e.getFlatInteriorPoints()
          );
          c = [];
          for (let M = 0, p = C.length; M < p; M += 3)
            r.overflow || h.push(C[M + 2] / this.resolution), c.push(C[M], C[M + 1]);
          if (c.length === 0)
            return;
          d = 2;
          break;
      }
      const f = this.appendFlatPointCoordinates(c, d);
      if (f === s)
        return;
      if (h && (f - s) / 2 !== c.length / d) {
        let C = s / 2;
        h = h.filter((M, p) => {
          const b = l[(C + p) * 2] === c[p * d] && l[(C + p) * 2 + 1] === c[p * d + 1];
          return b || --C, b;
        });
      }
      this.saveTextStates_(), (r.backgroundFill || r.backgroundStroke) && (this.setFillStrokeStyle(
        r.backgroundFill,
        r.backgroundStroke
      ), r.backgroundFill && this.updateFillStyle(this.state, this.createFill), r.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(e, n, i);
      let g = r.padding;
      if (g != Oi && (r.scale[0] < 0 || r.scale[1] < 0)) {
        let C = r.padding[0], M = r.padding[1], p = r.padding[2], b = r.padding[3];
        r.scale[0] < 0 && (M = -M, b = -b), r.scale[1] < 0 && (C = -C, p = -p), g = [C, M, p, b];
      }
      const m = this.pixelRatio;
      this.instructions.push([
        de.DRAW_IMAGE,
        s,
        f,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        g == Oi ? Oi : g.map(function(C) {
          return C * m;
        }),
        !!r.backgroundFill,
        !!r.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        h
      ]);
      const v = 1 / m, y = this.state.fillStyle;
      r.backgroundFill && (this.state.fillStyle = It, this.hitDetectionInstructions.push(this.createFill(this.state))), this.hitDetectionInstructions.push([
        de.DRAW_IMAGE,
        s,
        f,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [v, v],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        g,
        !!r.backgroundFill,
        !!r.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? It : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        h
      ]), r.backgroundFill && (this.state.fillStyle = y, this.hitDetectionInstructions.push(this.createFill(this.state))), this.endGeometry(n);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const e = this.textStrokeState_, n = this.textState_, i = this.textFillState_, a = this.strokeKey_;
    e && (a in this.strokeStates || (this.strokeStates[a] = {
      strokeStyle: e.strokeStyle,
      lineCap: e.lineCap,
      lineDashOffset: e.lineDashOffset,
      lineWidth: e.lineWidth,
      lineJoin: e.lineJoin,
      miterLimit: e.miterLimit,
      lineDash: e.lineDash
    }));
    const o = this.textKey_;
    o in this.textStates || (this.textStates[o] = {
      font: n.font,
      textAlign: n.textAlign || go,
      justify: n.justify,
      textBaseline: n.textBaseline || Mr,
      scale: n.scale
    });
    const r = this.fillKey_;
    i && (r in this.fillStates || (this.fillStates[r] = {
      fillStyle: i.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(e, n) {
    const i = this.textStrokeState_, a = this.textState_, o = this.strokeKey_, r = this.textKey_, l = this.fillKey_;
    this.saveTextStates_();
    const s = this.pixelRatio, u = Er[a.textBaseline], c = this.textOffsetY_ * s, d = this.text_, h = i ? i.lineWidth * Math.abs(a.scale[0]) / 2 : 0;
    this.instructions.push([
      de.DRAW_CHARS,
      e,
      n,
      u,
      a.overflow,
      l,
      a.maxAngle,
      s,
      c,
      o,
      h * s,
      d,
      r,
      1,
      this.declutterMode_
    ]), this.hitDetectionInstructions.push([
      de.DRAW_CHARS,
      e,
      n,
      u,
      a.overflow,
      l && It,
      a.maxAngle,
      s,
      c,
      o,
      h * s,
      d,
      r,
      1 / s,
      this.declutterMode_
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(e, n) {
    let i, a, o;
    if (!e)
      this.text_ = "";
    else {
      const r = e.getFill();
      r ? (a = this.textFillState_, a || (a = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = a), a.fillStyle = An(
        r.getColor() || It
      )) : (a = null, this.textFillState_ = a);
      const l = e.getStroke();
      if (!l)
        o = null, this.textStrokeState_ = o;
      else {
        o = this.textStrokeState_, o || (o = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = o);
        const g = l.getLineDash(), m = l.getLineDashOffset(), v = l.getWidth(), y = l.getMiterLimit();
        o.lineCap = l.getLineCap() || xa, o.lineDash = g ? g.slice() : ti, o.lineDashOffset = m === void 0 ? ni : m, o.lineJoin = l.getLineJoin() || Pa, o.lineWidth = v === void 0 ? mo : v, o.miterLimit = y === void 0 ? ho : y, o.strokeStyle = An(
          l.getColor() || fo
        );
      }
      i = this.textState_;
      const s = e.getFont() || Og;
      nb(s);
      const u = e.getScaleArray();
      i.overflow = e.getOverflow(), i.font = s, i.maxAngle = e.getMaxAngle(), i.placement = e.getPlacement(), i.textAlign = e.getTextAlign(), i.repeat = e.getRepeat(), i.justify = e.getJustify(), i.textBaseline = e.getTextBaseline() || Mr, i.backgroundFill = e.getBackgroundFill(), i.backgroundStroke = e.getBackgroundStroke(), i.padding = e.getPadding() || Oi, i.scale = u === void 0 ? [1, 1] : u;
      const c = e.getOffsetX(), d = e.getOffsetY(), h = e.getRotateWithView(), f = e.getRotation();
      this.text_ = e.getText() || "", this.textOffsetX_ = c === void 0 ? 0 : c, this.textOffsetY_ = d === void 0 ? 0 : d, this.textRotateWithView_ = h === void 0 ? !1 : h, this.textRotation_ = f === void 0 ? 0 : f, this.strokeKey_ = o ? (typeof o.strokeStyle == "string" ? o.strokeStyle : Ve(o.strokeStyle)) + o.lineCap + o.lineDashOffset + "|" + o.lineWidth + o.lineJoin + o.miterLimit + "[" + o.lineDash.join() + "]" : "", this.textKey_ = i.font + i.scale + (i.textAlign || "?") + (i.repeat || "?") + (i.justify || "?") + (i.textBaseline || "?"), this.fillKey_ = a && a.fillStyle ? typeof a.fillStyle == "string" ? a.fillStyle : "|" + Ve(a.fillStyle) : "";
    }
    this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = n;
  }
}
const hM = {
  Circle: Od,
  Default: No,
  Image: lM,
  LineString: sM,
  Polygon: Od,
  Text: dM
};
class fM {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, n, i, a) {
    this.tolerance_ = e, this.maxExtent_ = n, this.pixelRatio_ = a, this.resolution_ = i, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const e = {};
    for (const n in this.buildersByZIndex_) {
      e[n] = e[n] || {};
      const i = this.buildersByZIndex_[n];
      for (const a in i) {
        const o = i[a].finish();
        e[n][a] = o;
      }
    }
    return e;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(e, n) {
    const i = e !== void 0 ? e.toString() : "0";
    let a = this.buildersByZIndex_[i];
    a === void 0 && (a = {}, this.buildersByZIndex_[i] = a);
    let o = a[n];
    if (o === void 0) {
      const r = hM[n];
      o = new r(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), a[n] = o;
    }
    return o;
  }
}
function gM(t, e, n, i, a, o, r, l, s, u, c, d) {
  let h = t[e], f = t[e + 1], g = 0, m = 0, v = 0, y = 0;
  function C() {
    g = h, m = f, e += i, h = t[e], f = t[e + 1], y += v, v = Math.sqrt((h - g) * (h - g) + (f - m) * (f - m));
  }
  do
    C();
  while (e < n - i && y + v < o);
  let M = v === 0 ? 0 : (o - y) / v;
  const p = qt(g, h, M), b = qt(m, f, M), P = e - i, x = y, _ = o + l * s(u, a, c);
  for (; e < n - i && y + v < _; )
    C();
  M = v === 0 ? 0 : (_ - y) / v;
  const T = qt(g, h, M), B = qt(m, f, M);
  let L;
  if (d) {
    const F = [p, b, T, B];
    Cg(F, 0, 4, 2, d, F, F), L = F[0] > F[2];
  } else
    L = p > T;
  const z = Math.PI, I = [], k = P + i === e;
  e = P, v = 0, y = x, h = t[e], f = t[e + 1];
  let G;
  if (k) {
    C(), G = Math.atan2(f - m, h - g), L && (G += G > 0 ? -z : z);
    const F = (T + p) / 2, q = (B + b) / 2;
    return I[0] = [F, q, (_ - o) / 2, G, a], I;
  }
  a = a.replace(/\n/g, " ");
  for (let F = 0, q = a.length; F < q; ) {
    C();
    let j = Math.atan2(f - m, h - g);
    if (L && (j += j > 0 ? -z : z), G !== void 0) {
      let D = j - G;
      if (D += D > z ? -2 * z : D < -z ? 2 * z : 0, Math.abs(D) > r)
        return null;
    }
    G = j;
    const ne = F;
    let A = 0;
    for (; F < q; ++F) {
      const D = L ? q - F - 1 : F, Y = l * s(u, a[D], c);
      if (e + i < n && y + v < o + A + Y / 2)
        break;
      A += Y;
    }
    if (F === ne)
      continue;
    const R = L ? a.substring(q - ne, q - F) : a.substring(ne, F);
    M = v === 0 ? 0 : (o + A / 2 - y) / v;
    const V = qt(g, h, M), X = qt(m, f, M);
    I.push([V, X, A / 2, j, R]), o += A;
  }
  return I;
}
function mM(t, e, n, i) {
  let a = t[e], o = t[e + 1], r = 0;
  for (let l = e + i; l < n; l += i) {
    const s = t[l], u = t[l + 1];
    r += Math.sqrt((s - a) * (s - a) + (u - o) * (u - o)), a = s, o = u;
  }
  return r;
}
const ta = an(), hi = [], Xn = [], Un = [], fi = [];
function Dd(t) {
  return t[3].declutterBox;
}
const Gd = new RegExp(
  /* eslint-disable prettier/prettier */
  "[-----]"
  /* eslint-enable prettier/prettier */
);
function Ol(t, e) {
  return e === "start" ? e = Gd.test(t) ? "right" : "left" : e === "end" && (e = Gd.test(t) ? "left" : "right"), Er[e];
}
function vM(t, e, n) {
  return n > 0 && t.push(`
`, ""), t.push(e, ""), t;
}
class yM {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
   * @param {boolean} [deferredRendering] Enable deferred rendering.
   */
  constructor(e, n, i, a, o) {
    this.overlaps = i, this.pixelRatio = n, this.resolution = e, this.alignAndScaleFill_, this.instructions = a.instructions, this.coordinates = a.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = hn(), this.hitDetectionInstructions = a.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = a.fillStates || {}, this.strokeStates = a.strokeStates || {}, this.textStates = a.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = o ? new dm() : null;
  }
  /**
   * @return {ZIndexContext} ZIndex context.
   */
  getZIndexContext() {
    return this.zIndexContext_;
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(e, n, i, a) {
    const o = e + n + i + a;
    if (this.labels_[o])
      return this.labels_[o];
    const r = a ? this.strokeStates[a] : null, l = i ? this.fillStates[i] : null, s = this.textStates[n], u = this.pixelRatio, c = [
      s.scale[0] * u,
      s.scale[1] * u
    ], d = Array.isArray(e), h = s.justify ? Er[s.justify] : Ol(
      Array.isArray(e) ? e[0] : e,
      s.textAlign || go
    ), f = a && r.lineWidth ? r.lineWidth : 0, g = d ? e : e.split(`
`).reduce(vM, []), { width: m, height: v, widths: y, heights: C, lineWidths: M } = ab(
      s,
      g
    ), p = m + f, b = [], P = (p + 2) * c[0], x = (v + f) * c[1], _ = {
      width: P < 0 ? Math.floor(P) : Math.ceil(P),
      height: x < 0 ? Math.floor(x) : Math.ceil(x),
      contextInstructions: b
    };
    (c[0] != 1 || c[1] != 1) && b.push("scale", c), a && (b.push("strokeStyle", r.strokeStyle), b.push("lineWidth", f), b.push("lineCap", r.lineCap), b.push("lineJoin", r.lineJoin), b.push("miterLimit", r.miterLimit), b.push("setLineDash", [r.lineDash]), b.push("lineDashOffset", r.lineDashOffset)), i && b.push("fillStyle", l.fillStyle), b.push("textBaseline", "middle"), b.push("textAlign", "center");
    const T = 0.5 - h;
    let B = h * p + T * f;
    const L = [], z = [];
    let I = 0, k = 0, G = 0, F = 0, q;
    for (let j = 0, ne = g.length; j < ne; j += 2) {
      const A = g[j];
      if (A === `
`) {
        k += I, I = 0, B = h * p + T * f, ++F;
        continue;
      }
      const R = g[j + 1] || s.font;
      R !== q && (a && L.push("font", R), i && z.push("font", R), q = R), I = Math.max(I, C[G]);
      const V = [
        A,
        B + T * y[G] + h * (y[G] - M[F]),
        0.5 * (f + I) + k
      ];
      B += y[G], a && L.push("strokeText", V), i && z.push("fillText", V), ++G;
    }
    return Array.prototype.push.apply(b, L), Array.prototype.push.apply(b, z), this.labels_[o] = _, _;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(e, n, i, a, o, r, l) {
    e.beginPath(), e.moveTo.apply(e, n), e.lineTo.apply(e, i), e.lineTo.apply(e, a), e.lineTo.apply(e, o), e.lineTo.apply(e, n), r && (this.alignAndScaleFill_ = /** @type {number} */
    r[2], this.fill_(e)), l && (this.setStrokeStyle_(
      e,
      /** @type {Array<*>} */
      l
    ), e.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(e, n, i, a, o, r, l, s, u, c, d, h, f, g, m, v) {
    l *= h[0], s *= h[1];
    let y = i - l, C = a - s;
    const M = o + u > e ? e - u : o, p = r + c > n ? n - c : r, b = g[3] + M * h[0] + g[1], P = g[0] + p * h[1] + g[2], x = y - g[3], _ = C - g[0];
    (m || d !== 0) && (hi[0] = x, fi[0] = x, hi[1] = _, Xn[1] = _, Xn[0] = x + b, Un[0] = Xn[0], Un[1] = _ + P, fi[1] = Un[1]);
    let T;
    return d !== 0 ? (T = ii(
      hn(),
      i,
      a,
      1,
      1,
      d,
      -i,
      -a
    ), ut(T, hi), ut(T, Xn), ut(T, Un), ut(T, fi), Mi(
      Math.min(hi[0], Xn[0], Un[0], fi[0]),
      Math.min(hi[1], Xn[1], Un[1], fi[1]),
      Math.max(hi[0], Xn[0], Un[0], fi[0]),
      Math.max(hi[1], Xn[1], Un[1], fi[1]),
      ta
    )) : Mi(
      Math.min(x, x + b),
      Math.min(_, _ + P),
      Math.max(x, x + b),
      Math.max(_, _ + P),
      ta
    ), f && (y = Math.round(y), C = Math.round(C)), {
      drawImageX: y,
      drawImageY: C,
      drawImageW: M,
      drawImageH: p,
      originX: u,
      originY: c,
      declutterBox: {
        minX: ta[0],
        minY: ta[1],
        maxX: ta[2],
        maxY: ta[3],
        value: v
      },
      canvasTransform: T,
      scale: h
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(e, n, i, a, o, r, l) {
    const s = !!(r || l), u = a.declutterBox, c = l ? l[2] * a.scale[0] / 2 : 0;
    return u.minX - c <= n[0] && u.maxX + c >= 0 && u.minY - c <= n[1] && u.maxY + c >= 0 && (s && this.replayTextBackground_(
      e,
      hi,
      Xn,
      Un,
      fi,
      /** @type {Array<*>} */
      r,
      /** @type {Array<*>} */
      l
    ), ob(
      e,
      a.canvasTransform,
      o,
      i,
      a.originX,
      a.originY,
      a.drawImageW,
      a.drawImageH,
      a.drawImageX,
      a.drawImageY,
      a.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(e) {
    const n = this.alignAndScaleFill_;
    if (n) {
      const i = ut(this.renderedTransform_, [0, 0]), a = 512 * this.pixelRatio;
      e.save(), e.translate(i[0] % a, i[1] % a), n !== 1 && e.scale(n, n), e.rotate(this.viewRotation_);
    }
    e.fill(), n && e.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(e, n) {
    e.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    n[1], e.lineWidth = /** @type {number} */
    n[2], e.lineCap = /** @type {CanvasLineCap} */
    n[3], e.lineJoin = /** @type {CanvasLineJoin} */
    n[4], e.miterLimit = /** @type {number} */
    n[5], e.lineDashOffset = /** @type {number} */
    n[7], e.setLineDash(
      /** @type {Array<number>} */
      n[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(e, n, i, a) {
    const o = this.textStates[n], r = this.createLabel(e, n, a, i), l = this.strokeStates[i], s = this.pixelRatio, u = Ol(
      Array.isArray(e) ? e[0] : e,
      o.textAlign || go
    ), c = Er[o.textBaseline || Mr], d = l && l.lineWidth ? l.lineWidth : 0, h = r.width / s - 2 * o.scale[0], f = u * h + 2 * (0.5 - u) * d, g = c * r.height / s + 2 * (0.5 - c) * d;
    return {
      label: r,
      anchorX: f,
      anchorY: g
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(e, n, i, a, o, r, l, s) {
    const u = this.zIndexContext_;
    let c;
    this.pixelCoordinates_ && Ei(i, this.renderedTransform_) ? c = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), c = pi(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      i,
      this.pixelCoordinates_
    ), tS(this.renderedTransform_, i));
    let d = 0;
    const h = a.length;
    let f = 0, g, m, v, y, C, M, p, b, P, x, _, T, B, L = 0, z = 0, I = null, k = null;
    const G = this.coordinateCache_, F = this.viewRotation_, q = Math.round(Math.atan2(-i[1], i[0]) * 1e12) / 1e12, j = (
      /** @type {import("../../render.js").State} */
      {
        context: e,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: F
      }
    ), ne = this.instructions != a || this.overlaps ? 0 : 200;
    let A, R, V, X;
    for (; d < h; ) {
      const D = a[d];
      switch (
        /** @type {import("./Instruction.js").default} */
        D[0]
      ) {
        case de.BEGIN_GEOMETRY:
          A = /** @type {import("../../Feature.js").FeatureLike} */
          D[1], X = D[3], A.getGeometry() ? l !== void 0 && !zt(l, X.getExtent()) ? d = /** @type {number} */
          D[2] + 1 : ++d : d = /** @type {number} */
          D[2], u && (u.zIndex = D[4]);
          break;
        case de.BEGIN_PATH:
          L > ne && (this.fill_(e), L = 0), z > ne && (e.stroke(), z = 0), !L && !z && (e.beginPath(), C = NaN, M = NaN), ++d;
          break;
        case de.CIRCLE:
          f = /** @type {number} */
          D[1];
          const ce = c[f], K = c[f + 1], se = c[f + 2], ge = c[f + 3], $ = se - ce, ae = ge - K, ye = Math.sqrt($ * $ + ae * ae);
          e.moveTo(ce + ye, K), e.arc(ce, K, ye, 0, 2 * Math.PI, !0), ++d;
          break;
        case de.CLOSE_PATH:
          e.closePath(), ++d;
          break;
        case de.CUSTOM:
          f = /** @type {number} */
          D[1], g = D[2];
          const me = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            D[3]
          ), ze = D[4], je = D[5];
          j.geometry = me, j.feature = A, d in G || (G[d] = []);
          const He = G[d];
          je ? je(c, f, g, 2, He) : (He[0] = c[f], He[1] = c[f + 1], He.length = 2), u && (u.zIndex = D[6]), ze(He, j), ++d;
          break;
        case de.DRAW_IMAGE:
          f = /** @type {number} */
          D[1], g = /** @type {number} */
          D[2], P = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          D[3], m = /** @type {number} */
          D[4], v = /** @type {number} */
          D[5];
          let xe = (
            /** @type {number} */
            D[6]
          );
          const De = (
            /** @type {number} */
            D[7]
          ), Ze = (
            /** @type {number} */
            D[8]
          ), Et = (
            /** @type {number} */
            D[9]
          ), St = (
            /** @type {boolean} */
            D[10]
          );
          let Xt = (
            /** @type {number} */
            D[11]
          );
          const Sn = (
            /** @type {import("../../size.js").Size} */
            D[12]
          );
          let Ut = (
            /** @type {number} */
            D[13]
          );
          y = D[14] || "declutter";
          const bn = (
            /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
            D[15]
          );
          if (!P && D.length >= 20) {
            x = /** @type {string} */
            D[19], _ = /** @type {string} */
            D[20], T = /** @type {string} */
            D[21], B = /** @type {string} */
            D[22];
            const Yt = this.drawLabelWithPointPlacement_(
              x,
              _,
              T,
              B
            );
            P = Yt.label, D[3] = P;
            const Ri = (
              /** @type {number} */
              D[23]
            );
            m = (Yt.anchorX - Ri) * this.pixelRatio, D[4] = m;
            const jt = (
              /** @type {number} */
              D[24]
            );
            v = (Yt.anchorY - jt) * this.pixelRatio, D[5] = v, xe = P.height, D[6] = xe, Ut = P.width, D[13] = Ut;
          }
          let Ai;
          D.length > 25 && (Ai = /** @type {number} */
          D[25]);
          let ui, ji, st;
          D.length > 17 ? (ui = /** @type {Array<number>} */
          D[16], ji = /** @type {boolean} */
          D[17], st = /** @type {boolean} */
          D[18]) : (ui = Oi, ji = !1, st = !1), St && q ? Xt += F : !St && !q && (Xt -= F);
          let Am = 0;
          for (; f < g; f += 2) {
            if (Ai && Ai[Am++] < Ut / this.pixelRatio)
              continue;
            const Yt = this.calculateImageOrLabelDimensions_(
              P.width,
              P.height,
              c[f],
              c[f + 1],
              Ut,
              xe,
              m,
              v,
              Ze,
              Et,
              Xt,
              Sn,
              o,
              ui,
              ji || st,
              A
            ), Ri = [
              e,
              n,
              P,
              Yt,
              De,
              ji ? (
                /** @type {Array<*>} */
                I
              ) : null,
              st ? (
                /** @type {Array<*>} */
                k
              ) : null
            ];
            if (s) {
              let jt, Mn, Ht;
              if (bn) {
                const Ke = g - f;
                if (!bn[Ke]) {
                  bn[Ke] = { args: Ri, declutterMode: y };
                  continue;
                }
                const bt = bn[Ke];
                jt = bt.args, Mn = bt.declutterMode, delete bn[Ke], Ht = Dd(jt);
              }
              let Gn, Nn;
              if (jt && (Mn !== "declutter" || !s.collides(Ht)) && (Gn = !0), (y !== "declutter" || !s.collides(Yt.declutterBox)) && (Nn = !0), Mn === "declutter" && y === "declutter") {
                const Ke = Gn && Nn;
                Gn = Ke, Nn = Ke;
              }
              Gn && (Mn !== "none" && s.insert(Ht), this.replayImageOrLabel_.apply(this, jt)), Nn && (y !== "none" && s.insert(Yt.declutterBox), this.replayImageOrLabel_.apply(this, Ri));
            } else
              this.replayImageOrLabel_.apply(this, Ri);
          }
          ++d;
          break;
        case de.DRAW_CHARS:
          const Du = (
            /** @type {number} */
            D[1]
          ), Gu = (
            /** @type {number} */
            D[2]
          ), ll = (
            /** @type {number} */
            D[3]
          ), Rm = (
            /** @type {number} */
            D[4]
          );
          B = /** @type {string} */
          D[5];
          const Im = (
            /** @type {number} */
            D[6]
          ), Nu = (
            /** @type {number} */
            D[7]
          ), Wu = (
            /** @type {number} */
            D[8]
          );
          T = /** @type {string} */
          D[9];
          const sl = (
            /** @type {number} */
            D[10]
          );
          x = /** @type {string} */
          D[11], _ = /** @type {string} */
          D[12];
          const $u = [
            /** @type {number} */
            D[13],
            /** @type {number} */
            D[13]
          ];
          y = D[14] || "declutter";
          const ul = this.textStates[_], Ba = ul.font, Fa = [
            ul.scale[0] * Nu,
            ul.scale[1] * Nu
          ];
          let ka;
          Ba in this.widths_ ? ka = this.widths_[Ba] : (ka = {}, this.widths_[Ba] = ka);
          const Xu = mM(c, Du, Gu, 2), Uu = Math.abs(Fa[0]) * Sd(Ba, x, ka);
          if (Rm || Uu <= Xu) {
            const Yt = this.textStates[_].textAlign, Ri = (Xu - Uu) * Ol(x, Yt), jt = gM(
              c,
              Du,
              Gu,
              2,
              x,
              Ri,
              Im,
              Math.abs(Fa[0]),
              Sd,
              Ba,
              ka,
              q ? 0 : this.viewRotation_
            );
            e: if (jt) {
              const Mn = [];
              let Ht, Gn, Nn, Ke, bt;
              if (T)
                for (Ht = 0, Gn = jt.length; Ht < Gn; ++Ht) {
                  bt = jt[Ht], Nn = /** @type {string} */
                  bt[4], Ke = this.createLabel(Nn, _, "", T), m = /** @type {number} */
                  bt[2] + (Fa[0] < 0 ? -sl : sl), v = ll * Ke.height + (0.5 - ll) * 2 * sl * Fa[1] / Fa[0] - Wu;
                  const Wn = this.calculateImageOrLabelDimensions_(
                    Ke.width,
                    Ke.height,
                    bt[0],
                    bt[1],
                    Ke.width,
                    Ke.height,
                    m,
                    v,
                    0,
                    0,
                    bt[3],
                    $u,
                    !1,
                    Oi,
                    !1,
                    A
                  );
                  if (s && y === "declutter" && s.collides(Wn.declutterBox))
                    break e;
                  Mn.push([
                    e,
                    n,
                    Ke,
                    Wn,
                    1,
                    null,
                    null
                  ]);
                }
              if (B)
                for (Ht = 0, Gn = jt.length; Ht < Gn; ++Ht) {
                  bt = jt[Ht], Nn = /** @type {string} */
                  bt[4], Ke = this.createLabel(Nn, _, B, ""), m = /** @type {number} */
                  bt[2], v = ll * Ke.height - Wu;
                  const Wn = this.calculateImageOrLabelDimensions_(
                    Ke.width,
                    Ke.height,
                    bt[0],
                    bt[1],
                    Ke.width,
                    Ke.height,
                    m,
                    v,
                    0,
                    0,
                    bt[3],
                    $u,
                    !1,
                    Oi,
                    !1,
                    A
                  );
                  if (s && y === "declutter" && s.collides(Wn.declutterBox))
                    break e;
                  Mn.push([
                    e,
                    n,
                    Ke,
                    Wn,
                    1,
                    null,
                    null
                  ]);
                }
              s && y !== "none" && s.load(Mn.map(Dd));
              for (let Wn = 0, zm = Mn.length; Wn < zm; ++Wn)
                this.replayImageOrLabel_.apply(this, Mn[Wn]);
            }
          }
          ++d;
          break;
        case de.END_GEOMETRY:
          if (r !== void 0) {
            A = /** @type {import("../../Feature.js").FeatureLike} */
            D[1];
            const Yt = r(
              A,
              X,
              y
            );
            if (Yt)
              return Yt;
          }
          ++d;
          break;
        case de.FILL:
          ne ? L++ : this.fill_(e), ++d;
          break;
        case de.MOVE_TO_LINE_TO:
          for (f = /** @type {number} */
          D[1], g = /** @type {number} */
          D[2], R = c[f], V = c[f + 1], e.moveTo(R, V), C = R + 0.5 | 0, M = V + 0.5 | 0, f += 2; f < g; f += 2)
            R = c[f], V = c[f + 1], p = R + 0.5 | 0, b = V + 0.5 | 0, (f == g - 2 || p !== C || b !== M) && (e.lineTo(R, V), C = p, M = b);
          ++d;
          break;
        case de.SET_FILL_STYLE:
          I = D, this.alignAndScaleFill_ = D[2], L && (this.fill_(e), L = 0, z && (e.stroke(), z = 0)), e.fillStyle = D[1], ++d;
          break;
        case de.SET_STROKE_STYLE:
          k = D, z && (e.stroke(), z = 0), this.setStrokeStyle_(
            e,
            /** @type {Array<*>} */
            D
          ), ++d;
          break;
        case de.STROKE:
          ne ? z++ : e.stroke(), ++d;
          break;
        default:
          ++d;
          break;
      }
    }
    L && this.fill_(e), z && e.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(e, n, i, a, o, r) {
    this.viewRotation_ = a, this.execute_(
      e,
      n,
      i,
      this.instructions,
      o,
      void 0,
      void 0,
      r
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(e, n, i, a, o) {
    return this.viewRotation_ = i, this.execute_(
      e,
      [e.canvas.width, e.canvas.height],
      n,
      this.hitDetectionInstructions,
      !0,
      a,
      o
    );
  }
}
const da = [
  "Polygon",
  "Circle",
  "LineString",
  "Image",
  "Text",
  "Default"
], gm = ["Image", "Text"], CM = da.filter(
  (t) => !gm.includes(t)
);
class pM {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
   */
  constructor(e, n, i, a, o, r, l) {
    this.maxExtent_ = e, this.overlaps_ = a, this.pixelRatio_ = i, this.resolution_ = n, this.renderBuffer_ = r, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = hn(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(o, l);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(e, n) {
    const i = this.getClipCoords(n);
    e.beginPath(), e.moveTo(i[0], i[1]), e.lineTo(i[2], i[3]), e.lineTo(i[4], i[5]), e.lineTo(i[6], i[7]), e.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   * @param {boolean} deferredRendering Enable deferred rendering.
   */
  createExecutors_(e, n) {
    for (const i in e) {
      let a = this.executorsByZIndex_[i];
      a === void 0 && (a = {}, this.executorsByZIndex_[i] = a);
      const o = e[i];
      for (const r in o) {
        const l = o[r];
        a[r] = new yM(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          l,
          n
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(e) {
    for (const n in this.executorsByZIndex_) {
      const i = this.executorsByZIndex_[n];
      for (let a = 0, o = e.length; a < o; ++a)
        if (e[a] in i)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, n, i, a, o, r) {
    a = Math.round(a);
    const l = a * 2 + 1, s = ii(
      this.hitDetectionTransform_,
      a + 0.5,
      a + 0.5,
      1 / n,
      -1 / n,
      -i,
      -e[0],
      -e[1]
    ), u = !this.hitDetectionContext_;
    u && (this.hitDetectionContext_ = dt(
      l,
      l,
      void 0,
      { willReadFrequently: !0 }
    ));
    const c = this.hitDetectionContext_;
    c.canvas.width !== l || c.canvas.height !== l ? (c.canvas.width = l, c.canvas.height = l) : u || c.clearRect(0, 0, l, l);
    let d;
    this.renderBuffer_ !== void 0 && (d = an(), Za(d, e), du(
      d,
      n * (this.renderBuffer_ + a),
      d
    ));
    const h = _M(a);
    let f;
    function g(b, P, x) {
      const _ = c.getImageData(
        0,
        0,
        l,
        l
      ).data;
      for (let T = 0, B = h.length; T < B; T++)
        if (_[h[T]] > 0) {
          if (!r || x === "none" || f !== "Image" && f !== "Text" || r.includes(b)) {
            const L = (h[T] - 3) / 4, z = a - L % l, I = a - (L / l | 0), k = o(b, P, z * z + I * I);
            if (k)
              return k;
          }
          c.clearRect(0, 0, l, l);
          break;
        }
    }
    const m = Object.keys(this.executorsByZIndex_).map(Number);
    m.sort(ei);
    let v, y, C, M, p;
    for (v = m.length - 1; v >= 0; --v) {
      const b = m[v].toString();
      for (C = this.executorsByZIndex_[b], y = da.length - 1; y >= 0; --y)
        if (f = da[y], M = C[f], M !== void 0 && (p = M.executeHitDetection(
          c,
          s,
          i,
          g,
          d
        ), p))
          return p;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(e) {
    const n = this.maxExtent_;
    if (!n)
      return null;
    const i = n[0], a = n[1], o = n[2], r = n[3], l = [i, a, i, r, o, r, o, a];
    return pi(l, 0, 8, 2, e, l), l;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return ba(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} targetContext Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ALL}
   * @param {import("rbush").default|null} [declutterTree] Declutter tree.
   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
   */
  execute(e, n, i, a, o, r, l) {
    const s = Object.keys(this.executorsByZIndex_).map(Number);
    s.sort(ei), r = r || da;
    const u = da.length;
    let c, d, h, f, g;
    for (l && s.reverse(), c = 0, d = s.length; c < d; ++c) {
      const m = s[c].toString();
      for (g = this.executorsByZIndex_[m], h = 0, f = r.length; h < f; ++h) {
        const v = r[h], y = g[v];
        if (y !== void 0) {
          const C = l === null ? void 0 : y.getZIndexContext(), M = C ? C.getContext() : e, p = this.maxExtent_ && v !== "Image" && v !== "Text";
          if (p && (M.save(), this.clip(M, i)), !C || v === "Text" || v === "Image" ? y.execute(
            M,
            n,
            i,
            a,
            o,
            l
          ) : C.pushFunction(
            (b) => y.execute(
              b,
              n,
              i,
              a,
              o,
              l
            )
          ), p && M.restore(), C) {
            C.offset();
            const b = s[c] * u + h;
            this.deferredZIndexContexts_[b] || (this.deferredZIndexContexts_[b] = []), this.deferredZIndexContexts_[b].push(C);
          }
        }
      }
    }
    this.renderedContext_ = e;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this.renderedContext_;
  }
  renderDeferred() {
    const e = this.deferredZIndexContexts_, n = Object.keys(e).map(Number).sort(ei);
    for (let i = 0, a = n.length; i < a; ++i)
      e[n[i]].forEach((o) => {
        o.draw(this.renderedContext_), o.clear();
      }), e[n[i]].length = 0;
  }
}
const Dl = {};
function _M(t) {
  if (Dl[t] !== void 0)
    return Dl[t];
  const e = t * 2 + 1, n = t * t, i = new Array(n + 1);
  for (let o = 0; o <= t; ++o)
    for (let r = 0; r <= t; ++r) {
      const l = o * o + r * r;
      if (l > n)
        break;
      let s = i[l];
      s || (s = [], i[l] = s), s.push(((t + o) * e + (t + r)) * 4 + 3), o > 0 && s.push(((t - o) * e + (t + r)) * 4 + 3), r > 0 && (s.push(((t + o) * e + (t - r)) * 4 + 3), o > 0 && s.push(((t - o) * e + (t - r)) * 4 + 3));
    }
  const a = [];
  for (let o = 0, r = i.length; o < r; ++o)
    i[o] && a.push(...i[o]);
  return Dl[t] = a, a;
}
class SM extends fm {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(e, n, i, a, o, r, l) {
    super(), this.context_ = e, this.pixelRatio_ = n, this.extent_ = i, this.transform_ = a, this.transformRotation_ = a ? su(Math.atan2(a[1], a[0]), 10) : 0, this.viewRotation_ = o, this.squaredTolerance_ = r, this.userTransform_ = l, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = hn();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(e, n, i, a) {
    if (!this.image_)
      return;
    const o = pi(
      e,
      n,
      i,
      a,
      this.transform_,
      this.pixelCoordinates_
    ), r = this.context_, l = this.tmpLocalTransform_, s = r.globalAlpha;
    this.imageOpacity_ != 1 && (r.globalAlpha = s * this.imageOpacity_);
    let u = this.imageRotation_;
    this.transformRotation_ === 0 && (u -= this.viewRotation_), this.imageRotateWithView_ && (u += this.viewRotation_);
    for (let c = 0, d = o.length; c < d; c += 2) {
      const h = o[c] - this.imageAnchorX_, f = o[c + 1] - this.imageAnchorY_;
      if (u !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const g = h + this.imageAnchorX_, m = f + this.imageAnchorY_;
        ii(
          l,
          g,
          m,
          1,
          1,
          u,
          -g,
          -m
        ), r.save(), r.transform.apply(r, l), r.translate(g, m), r.scale(this.imageScale_[0], this.imageScale_[1]), r.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), r.restore();
      } else
        r.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          h,
          f,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (r.globalAlpha = s);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(e, n, i, a) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const o = pi(
      e,
      n,
      i,
      a,
      this.transform_,
      this.pixelCoordinates_
    ), r = this.context_;
    let l = this.textRotation_;
    for (this.transformRotation_ === 0 && (l -= this.viewRotation_), this.textRotateWithView_ && (l += this.viewRotation_); n < i; n += a) {
      const s = o[n] + this.textOffsetX_, u = o[n + 1] + this.textOffsetY_;
      l !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (r.save(), r.translate(s - this.textOffsetX_, u - this.textOffsetY_), r.rotate(l), r.translate(this.textOffsetX_, this.textOffsetY_), r.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && r.strokeText(this.text_, 0, 0), this.textFillState_ && r.fillText(this.text_, 0, 0), r.restore()) : (this.textStrokeState_ && r.strokeText(this.text_, s, u), this.textFillState_ && r.fillText(this.text_, s, u));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(e, n, i, a, o) {
    const r = this.context_, l = pi(
      e,
      n,
      i,
      a,
      this.transform_,
      this.pixelCoordinates_
    );
    r.moveTo(l[0], l[1]);
    let s = l.length;
    o && (s -= 2);
    for (let u = 2; u < s; u += 2)
      r.lineTo(l[u], l[u + 1]);
    return o && r.closePath(), i;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(e, n, i, a) {
    for (let o = 0, r = i.length; o < r; ++o)
      n = this.moveToLineTo_(
        e,
        n,
        i[o],
        a,
        !0
      );
    return n;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Circle.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!zt(this.extent_, e.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const n = sS(
          e,
          this.transform_,
          this.pixelCoordinates_
        ), i = n[2] - n[0], a = n[3] - n[1], o = Math.sqrt(i * i + a * a), r = this.context_;
        r.beginPath(), r.arc(
          n[0],
          n[1],
          o,
          0,
          2 * Math.PI
        ), this.fillState_ && r.fill(), this.strokeState_ && r.stroke();
      }
      this.text_ !== "" && this.drawText_(e.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(e) {
    this.setFillStrokeStyle(e.getFill(), e.getStroke()), this.setImageStyle(e.getImage()), this.setTextStyle(e.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(e) {
    this.transform_ = e;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(e) {
    switch (e.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          e
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          e
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          e
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          e
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          e
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          e
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          e
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(e, n) {
    const i = n.getGeometryFunction()(e);
    i && (this.setStyle(n), this.drawGeometry(i));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(e) {
    const n = e.getGeometriesArray();
    for (let i = 0, a = n.length; i < a; ++i)
      this.drawGeometry(n[i]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/Point.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const n = e.getFlatCoordinates(), i = e.getStride();
    this.image_ && this.drawImages_(n, 0, n.length, i), this.text_ !== "" && this.drawText_(n, 0, n.length, i);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPoint.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const n = e.getFlatCoordinates(), i = e.getStride();
    this.image_ && this.drawImages_(n, 0, n.length, i), this.text_ !== "" && this.drawText_(n, 0, n.length, i);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/LineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!zt(this.extent_, e.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const n = this.context_, i = e.getFlatCoordinates();
        n.beginPath(), this.moveToLineTo_(
          i,
          0,
          i.length,
          e.getStride(),
          !1
        ), n.stroke();
      }
      if (this.text_ !== "") {
        const n = e.getFlatMidpoint();
        this.drawText_(n, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiLineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const n = e.getExtent();
    if (zt(this.extent_, n)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const i = this.context_, a = e.getFlatCoordinates();
        let o = 0;
        const r = (
          /** @type {Array<number>} */
          e.getEnds()
        ), l = e.getStride();
        i.beginPath();
        for (let s = 0, u = r.length; s < u; ++s)
          o = this.moveToLineTo_(
            a,
            o,
            r[s],
            l,
            !1
          );
        i.stroke();
      }
      if (this.text_ !== "") {
        const i = e.getFlatMidpoints();
        this.drawText_(i, 0, i.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Polygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!zt(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const n = this.context_;
        n.beginPath(), this.drawRings_(
          e.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          e.getEnds(),
          e.getStride()
        ), this.fillState_ && n.fill(), this.strokeState_ && n.stroke();
      }
      if (this.text_ !== "") {
        const n = e.getFlatInteriorPoint();
        this.drawText_(n, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPolygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!zt(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const n = this.context_, i = e.getOrientedFlatCoordinates();
        let a = 0;
        const o = e.getEndss(), r = e.getStride();
        n.beginPath();
        for (let l = 0, s = o.length; l < s; ++l) {
          const u = o[l];
          a = this.drawRings_(i, a, u, r);
        }
        this.fillState_ && n.fill(), this.strokeState_ && n.stroke();
      }
      if (this.text_ !== "") {
        const n = e.getFlatInteriorPoints();
        this.drawText_(n, 0, n.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(e) {
    const n = this.context_, i = this.contextFillState_;
    i ? i.fillStyle != e.fillStyle && (i.fillStyle = e.fillStyle, n.fillStyle = e.fillStyle) : (n.fillStyle = e.fillStyle, this.contextFillState_ = {
      fillStyle: e.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(e) {
    const n = this.context_, i = this.contextStrokeState_;
    i ? (i.lineCap != e.lineCap && (i.lineCap = e.lineCap, n.lineCap = e.lineCap), Ei(i.lineDash, e.lineDash) || n.setLineDash(
      i.lineDash = e.lineDash
    ), i.lineDashOffset != e.lineDashOffset && (i.lineDashOffset = e.lineDashOffset, n.lineDashOffset = e.lineDashOffset), i.lineJoin != e.lineJoin && (i.lineJoin = e.lineJoin, n.lineJoin = e.lineJoin), i.lineWidth != e.lineWidth && (i.lineWidth = e.lineWidth, n.lineWidth = e.lineWidth), i.miterLimit != e.miterLimit && (i.miterLimit = e.miterLimit, n.miterLimit = e.miterLimit), i.strokeStyle != e.strokeStyle && (i.strokeStyle = e.strokeStyle, n.strokeStyle = e.strokeStyle)) : (n.lineCap = e.lineCap, n.setLineDash(e.lineDash), n.lineDashOffset = e.lineDashOffset, n.lineJoin = e.lineJoin, n.lineWidth = e.lineWidth, n.miterLimit = e.miterLimit, n.strokeStyle = e.strokeStyle, this.contextStrokeState_ = {
      lineCap: e.lineCap,
      lineDash: e.lineDash,
      lineDashOffset: e.lineDashOffset,
      lineJoin: e.lineJoin,
      lineWidth: e.lineWidth,
      miterLimit: e.miterLimit,
      strokeStyle: e.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(e) {
    const n = this.context_, i = this.contextTextState_, a = e.textAlign ? e.textAlign : go;
    i ? (i.font != e.font && (i.font = e.font, n.font = e.font), i.textAlign != a && (i.textAlign = a, n.textAlign = a), i.textBaseline != e.textBaseline && (i.textBaseline = e.textBaseline, n.textBaseline = e.textBaseline)) : (n.font = e.font, n.textAlign = a, n.textBaseline = e.textBaseline, this.contextTextState_ = {
      font: e.font,
      textAlign: a,
      textBaseline: e.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, n) {
    if (!e)
      this.fillState_ = null;
    else {
      const i = e.getColor();
      this.fillState_ = {
        fillStyle: An(
          i || It
        )
      };
    }
    if (!n)
      this.strokeState_ = null;
    else {
      const i = n.getColor(), a = n.getLineCap(), o = n.getLineDash(), r = n.getLineDashOffset(), l = n.getLineJoin(), s = n.getWidth(), u = n.getMiterLimit(), c = o || ti;
      this.strokeState_ = {
        lineCap: a !== void 0 ? a : xa,
        lineDash: this.pixelRatio_ === 1 ? c : c.map((d) => d * this.pixelRatio_),
        lineDashOffset: (r || ni) * this.pixelRatio_,
        lineJoin: l !== void 0 ? l : Pa,
        lineWidth: (s !== void 0 ? s : mo) * this.pixelRatio_,
        miterLimit: u !== void 0 ? u : ho,
        strokeStyle: An(
          i || fo
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(e) {
    let n;
    if (!e || !(n = e.getSize())) {
      this.image_ = null;
      return;
    }
    const i = e.getPixelRatio(this.pixelRatio_), a = e.getAnchor(), o = e.getOrigin();
    this.image_ = e.getImage(this.pixelRatio_), this.imageAnchorX_ = a[0] * i, this.imageAnchorY_ = a[1] * i, this.imageHeight_ = n[1] * i, this.imageOpacity_ = e.getOpacity(), this.imageOriginX_ = o[0], this.imageOriginY_ = o[1], this.imageRotateWithView_ = e.getRotateWithView(), this.imageRotation_ = e.getRotation();
    const r = e.getScaleArray();
    this.imageScale_ = [
      r[0] * this.pixelRatio_ / i,
      r[1] * this.pixelRatio_ / i
    ], this.imageWidth_ = n[0] * i;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(e) {
    if (!e)
      this.text_ = "";
    else {
      const n = e.getFill();
      if (!n)
        this.textFillState_ = null;
      else {
        const f = n.getColor();
        this.textFillState_ = {
          fillStyle: An(
            f || It
          )
        };
      }
      const i = e.getStroke();
      if (!i)
        this.textStrokeState_ = null;
      else {
        const f = i.getColor(), g = i.getLineCap(), m = i.getLineDash(), v = i.getLineDashOffset(), y = i.getLineJoin(), C = i.getWidth(), M = i.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: g !== void 0 ? g : xa,
          lineDash: m || ti,
          lineDashOffset: v || ni,
          lineJoin: y !== void 0 ? y : Pa,
          lineWidth: C !== void 0 ? C : mo,
          miterLimit: M !== void 0 ? M : ho,
          strokeStyle: An(
            f || fo
          )
        };
      }
      const a = e.getFont(), o = e.getOffsetX(), r = e.getOffsetY(), l = e.getRotateWithView(), s = e.getRotation(), u = e.getScaleArray(), c = e.getText(), d = e.getTextAlign(), h = e.getTextBaseline();
      this.textState_ = {
        font: a !== void 0 ? a : Og,
        textAlign: d !== void 0 ? d : go,
        textBaseline: h !== void 0 ? h : Mr
      }, this.text_ = c !== void 0 ? Array.isArray(c) ? c.reduce((f, g, m) => f += m % 2 ? " " : g, "") : c : "", this.textOffsetX_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textOffsetY_ = r !== void 0 ? this.pixelRatio_ * r : 0, this.textRotateWithView_ = l !== void 0 ? l : !1, this.textRotation_ = s !== void 0 ? s : 0, this.textScale_ = [
        this.pixelRatio_ * u[0],
        this.pixelRatio_ * u[1]
      ];
    }
  }
}
const Tn = 0.5;
function bM(t, e, n, i, a, o, r, l, s) {
  const u = a, c = t[0] * Tn, d = t[1] * Tn, h = dt(c, d);
  h.imageSmoothingEnabled = !1;
  const f = h.canvas, g = new SM(
    h,
    Tn,
    a,
    null,
    r,
    l,
    null
  ), m = n.length, v = Math.floor((256 * 256 * 256 - 1) / m), y = {};
  for (let M = 1; M <= m; ++M) {
    const p = n[M - 1], b = p.getStyleFunction() || i;
    if (!b)
      continue;
    let P = b(p, o);
    if (!P)
      continue;
    Array.isArray(P) || (P = [P]);
    const _ = (M * v).toString(16).padStart(7, "#00000");
    for (let T = 0, B = P.length; T < B; ++T) {
      const L = P[T], z = L.getGeometryFunction()(p);
      if (!z || !zt(u, z.getExtent()))
        continue;
      const I = L.clone(), k = I.getFill();
      k && k.setColor(_);
      const G = I.getStroke();
      G && (G.setColor(_), G.setLineDash(null)), I.setText(void 0);
      const F = L.getImage();
      if (F) {
        const A = F.getImageSize();
        if (!A)
          continue;
        const R = dt(
          A[0],
          A[1],
          void 0,
          { alpha: !1 }
        ), V = R.canvas;
        R.fillStyle = _, R.fillRect(0, 0, V.width, V.height), I.setImage(
          new ko({
            img: V,
            anchor: F.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: F.getOrigin(),
            opacity: 1,
            size: F.getSize(),
            scale: F.getScale(),
            rotation: F.getRotation(),
            rotateWithView: F.getRotateWithView()
          })
        );
      }
      const q = I.getZIndex() || 0;
      let j = y[q];
      j || (j = {}, y[q] = j, j.Polygon = [], j.Circle = [], j.LineString = [], j.Point = []);
      const ne = z.getType();
      if (ne === "GeometryCollection") {
        const A = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          z.getGeometriesArrayRecursive()
        );
        for (let R = 0, V = A.length; R < V; ++R) {
          const X = A[R];
          j[X.getType().replace("Multi", "")].push(
            X,
            I
          );
        }
      } else
        j[ne.replace("Multi", "")].push(z, I);
    }
  }
  const C = Object.keys(y).map(Number).sort(ei);
  for (let M = 0, p = C.length; M < p; ++M) {
    const b = y[C[M]];
    for (const P in b) {
      const x = b[P];
      for (let _ = 0, T = x.length; _ < T; _ += 2) {
        g.setStyle(x[_ + 1]);
        for (let B = 0, L = e.length; B < L; ++B)
          g.setTransform(e[B]), g.drawGeometry(x[_]);
      }
    }
  }
  return h.getImageData(0, 0, f.width, f.height);
}
function MM(t, e, n) {
  const i = [];
  if (n) {
    const a = Math.floor(Math.round(t[0]) * Tn), o = Math.floor(Math.round(t[1]) * Tn), r = (tt(a, 0, n.width - 1) + tt(o, 0, n.height - 1) * n.width) * 4, l = n.data[r], s = n.data[r + 1], c = n.data[r + 2] + 256 * (s + 256 * l), d = Math.floor((256 * 256 * 256 - 1) / e.length);
    c && c % d === 0 && i.push(e[c / d - 1]);
  }
  return i;
}
const xM = 0.5, mm = {
  Point: zM,
  LineString: AM,
  Polygon: VM,
  MultiPoint: LM,
  MultiLineString: RM,
  MultiPolygon: IM,
  GeometryCollection: EM,
  Circle: TM
};
function PM(t, e) {
  return parseInt(Ve(t), 10) - parseInt(Ve(e), 10);
}
function Nd(t, e) {
  const n = vm(t, e);
  return n * n;
}
function vm(t, e) {
  return xM * t / e;
}
function TM(t, e, n, i, a) {
  const o = n.getFill(), r = n.getStroke();
  if (o || r) {
    const s = t.getBuilder(n.getZIndex(), "Circle");
    s.setFillStrokeStyle(o, r), s.drawCircle(e, i, a);
  }
  const l = n.getText();
  if (l && l.getText()) {
    const s = t.getBuilder(n.getZIndex(), "Text");
    s.setTextStyle(l), s.drawText(e, i);
  }
}
function Wd(t, e, n, i, a, o, r, l) {
  const s = [], u = n.getImage();
  if (u) {
    let h = !0;
    const f = u.getImageState();
    f == Me.LOADED || f == Me.ERROR ? h = !1 : f == Me.IDLE && u.load(), h && s.push(u.ready());
  }
  const c = n.getFill();
  c && c.loading() && s.push(c.ready());
  const d = s.length > 0;
  return d && Promise.all(s).then(() => a(null)), wM(
    t,
    e,
    n,
    i,
    o,
    r,
    l
  ), d;
}
function wM(t, e, n, i, a, o, r) {
  const l = n.getGeometryFunction()(e);
  if (!l)
    return;
  const s = l.simplifyTransformed(
    i,
    a
  );
  if (n.getRenderer())
    ym(t, s, n, e, r);
  else {
    const c = mm[s.getType()];
    c(
      t,
      s,
      n,
      e,
      r,
      o
    );
  }
}
function ym(t, e, n, i, a) {
  if (e.getType() == "GeometryCollection") {
    const r = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      e.getGeometries()
    );
    for (let l = 0, s = r.length; l < s; ++l)
      ym(t, r[l], n, i, a);
    return;
  }
  t.getBuilder(n.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    e,
    i,
    n.getRenderer(),
    n.getHitDetectionRenderer(),
    a
  );
}
function EM(t, e, n, i, a, o) {
  const r = e.getGeometriesArray();
  let l, s;
  for (l = 0, s = r.length; l < s; ++l) {
    const u = mm[r[l].getType()];
    u(
      t,
      r[l],
      n,
      i,
      a,
      o
    );
  }
}
function AM(t, e, n, i, a) {
  const o = n.getStroke();
  if (o) {
    const l = t.getBuilder(
      n.getZIndex(),
      "LineString"
    );
    l.setFillStrokeStyle(null, o), l.drawLineString(e, i, a);
  }
  const r = n.getText();
  if (r && r.getText()) {
    const l = t.getBuilder(n.getZIndex(), "Text");
    l.setTextStyle(r), l.drawText(e, i, a);
  }
}
function RM(t, e, n, i, a) {
  const o = n.getStroke();
  if (o) {
    const l = t.getBuilder(
      n.getZIndex(),
      "LineString"
    );
    l.setFillStrokeStyle(null, o), l.drawMultiLineString(e, i, a);
  }
  const r = n.getText();
  if (r && r.getText()) {
    const l = t.getBuilder(n.getZIndex(), "Text");
    l.setTextStyle(r), l.drawText(e, i, a);
  }
}
function IM(t, e, n, i, a) {
  const o = n.getFill(), r = n.getStroke();
  if (r || o) {
    const s = t.getBuilder(n.getZIndex(), "Polygon");
    s.setFillStrokeStyle(o, r), s.drawMultiPolygon(e, i, a);
  }
  const l = n.getText();
  if (l && l.getText()) {
    const s = t.getBuilder(n.getZIndex(), "Text");
    s.setTextStyle(l), s.drawText(e, i, a);
  }
}
function zM(t, e, n, i, a, o) {
  const r = n.getImage(), l = n.getText(), s = l && l.getText(), u = o && r && s ? {} : void 0;
  if (r) {
    if (r.getImageState() != Me.LOADED)
      return;
    const c = t.getBuilder(n.getZIndex(), "Image");
    c.setImageStyle(r, u), c.drawPoint(e, i, a);
  }
  if (s) {
    const c = t.getBuilder(n.getZIndex(), "Text");
    c.setTextStyle(l, u), c.drawText(e, i, a);
  }
}
function LM(t, e, n, i, a, o) {
  const r = n.getImage(), l = r && r.getOpacity() !== 0, s = n.getText(), u = s && s.getText(), c = o && l && u ? {} : void 0;
  if (l) {
    if (r.getImageState() != Me.LOADED)
      return;
    const d = t.getBuilder(n.getZIndex(), "Image");
    d.setImageStyle(r, c), d.drawMultiPoint(e, i, a);
  }
  if (u) {
    const d = t.getBuilder(n.getZIndex(), "Text");
    d.setTextStyle(s, c), d.drawText(e, i, a);
  }
}
function VM(t, e, n, i, a) {
  const o = n.getFill(), r = n.getStroke();
  if (o || r) {
    const s = t.getBuilder(n.getZIndex(), "Polygon");
    s.setFillStrokeStyle(o, r), s.drawPolygon(e, i, a);
  }
  const l = n.getText();
  if (l && l.getText()) {
    const s = t.getBuilder(n.getZIndex(), "Text");
    s.setTextStyle(l), s.drawText(e, i, a);
  }
}
class BM extends hm {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = !1, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = an(), this.wrappedRenderedExtent_ = an(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */
  renderWorlds(e, n, i) {
    const a = n.extent, o = n.viewState, r = o.center, l = o.resolution, s = o.projection, u = o.rotation, c = s.getExtent(), d = this.getLayer().getSource(), h = this.getLayer().getDeclutter(), f = n.pixelRatio, g = n.viewHints, m = !(g[vt.ANIMATING] || g[vt.INTERACTING]), v = this.context, y = Math.round(ke(a) / l * f), C = Math.round(Mt(a) / l * f), M = d.getWrapX() && s.canWrapX(), p = M ? ke(c) : null, b = M ? Math.ceil((a[2] - c[2]) / p) + 1 : 1;
    let P = M ? Math.floor((a[0] - c[0]) / p) : 0;
    do {
      let x = this.getRenderTransform(
        r,
        l,
        0,
        f,
        y,
        C,
        P * p
      );
      n.declutter && (x = x.slice(0)), e.execute(
        v,
        [v.canvas.width, v.canvas.height],
        x,
        u,
        m,
        i === void 0 ? da : i ? gm : CM,
        i ? h && n.declutter[h] : void 0
      );
    } while (++P < b);
  }
  /**
   * @private
   */
  setDrawContext_() {
    this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = dt(
      this.context.canvas.width,
      this.context.canvas.height,
      Fd
    ));
  }
  /**
   * @private
   */
  resetDrawContext_() {
    if (this.opacity_ !== 1) {
      const e = this.targetContext_.globalAlpha;
      this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = e, qr(this.context), Fd.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, e, !0);
  }
  /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
    this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(e, n) {
    const i = e.layerStatesArray[e.layerIndex];
    this.opacity_ = i.opacity;
    const a = e.viewState;
    this.prepareContainer(e, n);
    const o = this.context, r = this.replayGroup_;
    let l = r && !r.isEmpty();
    if (!l && !(this.getLayer().hasListener(Qt.PRERENDER) || this.getLayer().hasListener(Qt.POSTRENDER)))
      return null;
    if (this.setDrawContext_(), this.preRender(o, e), a.projection, this.clipped_ = !1, l && i.extent && this.clipping) {
      const s = Fi(i.extent);
      l = zt(s, e.extent), this.clipped_ = l && !Bi(s, e.extent), this.clipped_ && this.clipUnrotated(o, e, s);
    }
    return l && this.renderWorlds(
      r,
      e,
      this.getLayer().getDeclutter() ? !1 : void 0
    ), !e.declutter && this.clipped_ && o.restore(), this.postRender(o, e), this.renderedRotation_ !== a.rotation && (this.renderedRotation_ = a.rotation, this.hitDetectionImageData_ = null), e.declutter || this.resetDrawContext_(), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */
  getFeatures(e) {
    return new Promise((n) => {
      if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const i = this.frameState.size.slice(), a = this.renderedCenter_, o = this.renderedResolution_, r = this.renderedRotation_, l = this.renderedProjection_, s = this.wrappedRenderedExtent_, u = this.getLayer(), c = [], d = i[0] * Tn, h = i[1] * Tn;
        c.push(
          this.getRenderTransform(
            a,
            o,
            r,
            Tn,
            d,
            h,
            0
          ).slice()
        );
        const f = u.getSource(), g = l.getExtent();
        if (f.getWrapX() && l.canWrapX() && !Bi(g, s)) {
          let m = s[0];
          const v = ke(g);
          let y = 0, C;
          for (; m < g[0]; )
            --y, C = v * y, c.push(
              this.getRenderTransform(
                a,
                o,
                r,
                Tn,
                d,
                h,
                C
              ).slice()
            ), m += v;
          for (y = 0, m = s[2]; m > g[2]; )
            ++y, C = v * y, c.push(
              this.getRenderTransform(
                a,
                o,
                r,
                Tn,
                d,
                h,
                C
              ).slice()
            ), m -= v;
        }
        this.hitDetectionImageData_ = bM(
          i,
          c,
          this.renderedFeatures_,
          u.getStyleFunction(),
          s,
          o,
          r,
          Nd(o, this.renderedPixelRatio_)
        );
      }
      n(
        MM(e, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, n, i, a, o) {
    if (!this.replayGroup_)
      return;
    const r = n.viewState.resolution, l = n.viewState.rotation, s = this.getLayer(), u = {}, c = function(g, m, v) {
      const y = Ve(g), C = u[y];
      if (C) {
        if (C !== !0 && v < C.distanceSq) {
          if (v === 0)
            return u[y] = !0, o.splice(o.lastIndexOf(C), 1), a(g, s, m);
          C.geometry = m, C.distanceSq = v;
        }
      } else {
        if (v === 0)
          return u[y] = !0, a(g, s, m);
        o.push(
          u[y] = {
            feature: g,
            layer: s,
            geometry: m,
            distanceSq: v,
            callback: a
          }
        );
      }
    };
    let d;
    const h = [this.replayGroup_], f = this.getLayer().getDeclutter();
    return h.some((g) => d = g.forEachFeatureAtCoordinate(
      e,
      r,
      l,
      i,
      c,
      f && n.declutter[f] ? n.declutter[f].all().map((m) => m.value) : null
    )), d;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.replayGroup_ && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const n = this.getLayer(), i = n.getSource();
    if (!i)
      return !1;
    const a = e.viewHints[vt.ANIMATING], o = e.viewHints[vt.INTERACTING], r = n.getUpdateWhileAnimating(), l = n.getUpdateWhileInteracting();
    if (this.ready && !r && a || !l && o)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const s = e.extent, u = e.viewState, c = u.projection, d = u.resolution, h = e.pixelRatio, f = n.getRevision(), g = n.getRenderBuffer();
    let m = n.getRenderOrder();
    m === void 0 && (m = PM);
    const v = u.center.slice(), y = du(
      s,
      g * d
    ), C = y.slice(), M = [y.slice()], p = c.getExtent();
    if (i.getWrapX() && c.canWrapX() && !Bi(p, e.extent)) {
      const k = ke(p), G = Math.max(ke(y) / 2, k);
      y[0] = p[0] - G, y[2] = p[2] + G, cg(v, c);
      const F = sg(M[0], c);
      F[0] < p[0] && F[2] < p[2] ? M.push([
        F[0] + k,
        F[1],
        F[2] + k,
        F[3]
      ]) : F[0] > p[0] && F[2] > p[2] && M.push([
        F[0] - k,
        F[1],
        F[2] - k,
        F[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == d && this.renderedRevision_ == f && this.renderedRenderOrder_ == m && this.renderedFrameDeclutter_ === !!e.declutter && Bi(this.wrappedRenderedExtent_, y))
      return Ei(this.renderedExtent_, C) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = C), this.renderedCenter_ = v, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const b = new fM(
      vm(d, h),
      y,
      d,
      h
    );
    let P;
    for (let k = 0, G = M.length; k < G; ++k)
      i.loadFeatures(M[k], d, c);
    const x = Nd(d, h);
    let _ = !0;
    const T = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */
      (k, G) => {
        let F;
        const q = k.getStyleFunction() || n.getStyleFunction();
        if (q && (F = q(k, d)), F) {
          const j = this.renderFeature(
            k,
            x,
            F,
            b,
            P,
            this.getLayer().getDeclutter(),
            G
          );
          _ = _ && !j;
        }
      }
    ), B = mg(y), L = i.getFeaturesInExtent(B);
    m && L.sort(m);
    for (let k = 0, G = L.length; k < G; ++k)
      T(L[k], k);
    this.renderedFeatures_ = L, this.ready = _;
    const z = b.finish(), I = new pM(
      y,
      d,
      h,
      i.getOverlaps(),
      z,
      n.getRenderBuffer(),
      !!e.declutter
    );
    return this.renderedResolution_ = d, this.renderedRevision_ = f, this.renderedRenderOrder_ = m, this.renderedFrameDeclutter_ = !!e.declutter, this.renderedExtent_ = C, this.wrappedRenderedExtent_ = y, this.renderedCenter_ = v, this.renderedProjection_ = c, this.renderedPixelRatio_ = h, this.replayGroup_ = I, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, n, i, a, o, r, l) {
    if (!i)
      return !1;
    let s = !1;
    if (Array.isArray(i))
      for (let u = 0, c = i.length; u < c; ++u)
        s = Wd(
          a,
          e,
          i[u],
          n,
          this.boundHandleStyleImageChange_,
          o,
          r,
          l
        ) || s;
    else
      s = Wd(
        a,
        e,
        i,
        n,
        this.boundHandleStyleImageChange_,
        o,
        r,
        l
      );
    return s;
  }
}
class FM extends Zg {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new BM(this);
  }
}
class $d {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(e) {
    this.rbush_ = new Eg(e), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(e, n) {
    const i = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3],
      value: n
    };
    this.rbush_.insert(i), this.items_[Ve(n)] = i;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(e, n) {
    const i = new Array(n.length);
    for (let a = 0, o = n.length; a < o; a++) {
      const r = e[a], l = n[a], s = {
        minX: r[0],
        minY: r[1],
        maxX: r[2],
        maxY: r[3],
        value: l
      };
      i[a] = s, this.items_[Ve(l)] = s;
    }
    this.rbush_.load(i);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(e) {
    const n = Ve(e), i = this.items_[n];
    return delete this.items_[n], this.rbush_.remove(i) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(e, n) {
    const i = this.items_[Ve(n)], a = [i.minX, i.minY, i.maxX, i.maxY];
    ro(a, e) || (this.remove(n), this.insert(e, n));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(n) {
      return n.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(e) {
    const n = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3]
    };
    return this.rbush_.search(n).map(function(a) {
      return a.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(e) {
    return this.forEach_(this.getAll(), e);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(e, n) {
    return this.forEach_(this.getInExtent(e), n);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(e, n) {
    let i;
    for (let a = 0, o = e.length; a < o; a++)
      if (i = n(e[a]), i)
        return i;
    return i;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return ba(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(e) {
    const n = this.rbush_.toJSON();
    return Mi(n.minX, n.minY, n.maxX, n.maxY, e);
  }
  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(e) {
    this.rbush_.load(e.rbush_.all());
    for (const n in e.items_)
      this.items_[n] = e.items_[n];
  }
}
function Xd(t, e, n, i, a, o, r) {
  let l, s;
  const u = (n - e) / i;
  if (u === 1)
    l = e;
  else if (u === 2)
    l = e, s = a;
  else if (u !== 0) {
    let c = t[e], d = t[e + 1], h = 0;
    const f = [0];
    for (let v = e + i; v < n; v += i) {
      const y = t[v], C = t[v + 1];
      h += Math.sqrt((y - c) * (y - c) + (C - d) * (C - d)), f.push(h), c = y, d = C;
    }
    const g = a * h, m = y_(f, g);
    m < 0 ? (s = (g - f[-m - 2]) / (f[-m - 1] - f[-m - 2]), l = e + (-m - 2) * i) : l = e + m * i;
  }
  r = r > 1 ? r : 2, o = o || new Array(r);
  for (let c = 0; c < r; ++c)
    o[c] = l === void 0 ? NaN : s === void 0 ? t[l + c] : qt(t[l + c], t[l + i + c], s);
  return o;
}
function kM(t, e, n, i) {
  const a = [];
  let o = an();
  for (let r = 0, l = n.length; r < l; ++r) {
    const s = n[r];
    o = hu(
      t,
      e,
      s[0],
      i
    ), a.push((o[0] + o[2]) / 2, (o[1] + o[3]) / 2), e = s[s.length - 1];
  }
  return a;
}
const Ud = hn();
class Kt {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(e, n, i, a, o, r) {
    this.styleFunction, this.extent_, this.id_ = r, this.type_ = e, this.flatCoordinates_ = n, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = i || null, this.properties_ = o, this.squaredTolerance_, this.stride_ = a, this.simplifiedGeometry_;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(e) {
    return this.properties_[e];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? og(this.flatCoordinates_) : hu(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const e = $i(this.getExtent());
      this.flatInteriorPoints_ = bu(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        e,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const e = bS(this.flatCoordinates_, this.ends_), n = kM(this.flatCoordinates_, 0, e, 2);
      this.flatInteriorPoints_ = yS(
        this.flatCoordinates_,
        0,
        e,
        2,
        n
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = Xd(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const e = this.flatCoordinates_;
      let n = 0;
      const i = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let a = 0, o = i.length; a < o; ++a) {
        const r = i[a], l = Xd(e, n, r, 2, 0.5);
        lu(this.flatMidpoints_, l), n = r;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(e, n) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(e) {
    e = on(e);
    const n = e.getExtent(), i = e.getWorldExtent();
    if (n && i) {
      const a = Mt(i) / Mt(n);
      ii(
        Ud,
        i[0],
        i[3],
        a,
        -a,
        0,
        0,
        0
      ), pi(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        Ud,
        this.flatCoordinates_
      );
    }
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(e) {
    e(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }
  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    var e;
    return new Kt(
      this.type_,
      this.flatCoordinates_.slice(),
      (e = this.ends_) == null ? void 0 : e.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }
  /**
   * @return {Array<number>|null} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    return this.simplifyTransformed = Qf((e, n) => {
      if (e === this.squaredTolerance_)
        return this.simplifiedGeometry_;
      this.simplifiedGeometry_ = this.clone(), n && this.simplifiedGeometry_.applyTransform(n);
      const i = this.simplifiedGeometry_.getFlatCoordinates();
      let a;
      switch (this.type_) {
        case "LineString":
          i.length = Su(
            i,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            e,
            i,
            0
          ), a = [i.length];
          break;
        case "MultiLineString":
          a = [], i.length = fS(
            i,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            e,
            i,
            0,
            a
          );
          break;
        case "Polygon":
          a = [], i.length = bg(
            i,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(e),
            i,
            0,
            a
          );
          break;
      }
      return a && (this.simplifiedGeometry_ = new Kt(
        this.type_,
        i,
        a,
        2,
        this.properties_,
        this.id_
      )), this.squaredTolerance_ = e, this.simplifiedGeometry_;
    }), this;
  }
}
Kt.prototype.getFlatCoordinates = Kt.prototype.getOrientedFlatCoordinates;
const Zt = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function OM(t, e) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
let DM = !1;
function GM(t, e, n, i, a, o, r) {
  const l = new XMLHttpRequest();
  l.open(
    "GET",
    typeof t == "function" ? t(n, i, a) : t,
    !0
  ), e.getType() == "arraybuffer" && (l.responseType = "arraybuffer"), l.withCredentials = DM, l.onload = function(s) {
    if (!l.status || l.status >= 200 && l.status < 300) {
      const u = e.getType();
      try {
        let c;
        u == "text" || u == "json" ? c = l.responseText : u == "xml" ? c = l.responseXML || l.responseText : u == "arraybuffer" && (c = /** @type {ArrayBuffer} */
        l.response), c ? o(
          /** @type {Array<FeatureType>} */
          e.readFeatures(c, {
            extent: n,
            featureProjection: a
          }),
          e.readProjection(c)
        ) : r();
      } catch {
        r();
      }
    } else
      r();
  }, l.onerror = r, l.send();
}
function Yd(t, e) {
  return function(n, i, a, o, r) {
    const l = (
      /** @type {import("./source/Vector").default<FeatureType>} */
      this
    );
    GM(
      t,
      e,
      n,
      i,
      a,
      /**
       * @param {Array<FeatureType>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(s, u) {
        l.addFeatures(s), o !== void 0 && o(s);
      },
      /* FIXME handle error */
      r || Sa
    );
  };
}
class gi extends li {
  /**
   * @param {string} type Type.
   * @param {FeatureClass} [feature] Feature.
   * @param {Array<FeatureClass>} [features] Features.
   */
  constructor(e, n, i) {
    super(e), this.feature = n, this.features = i;
  }
}
class NM extends lm {
  /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = Sa, this.format_ = e.format, this.overlaps_ = e.overlaps === void 0 ? !0 : e.overlaps, this.url_ = e.url, e.loader !== void 0 ? this.loader_ = e.loader : this.url_ !== void 0 && (Ee(this.format_, "`format` must be set when `url` is set"), this.loader_ = Yd(this.url_, this.format_)), this.strategy_ = e.strategy !== void 0 ? e.strategy : OM;
    const n = e.useSpatialIndex !== void 0 ? e.useSpatialIndex : !0;
    this.featuresRtree_ = n ? new $d() : null, this.loadedExtentsRtree_ = new $d(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let i, a;
    Array.isArray(e.features) ? a = e.features : e.features && (i = e.features, a = i.getArray()), !n && i === void 0 && (i = new wn(a)), a !== void 0 && this.addFeaturesInternal(a), i !== void 0 && this.bindFeaturesCollection_(i);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */
  addFeature(e) {
    this.addFeatureInternal(e), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */
  addFeatureInternal(e) {
    const n = Ve(e);
    if (!this.addToIndex_(n, e)) {
      this.featuresCollection_ && this.featuresCollection_.remove(e);
      return;
    }
    this.setupChangeEvents_(n, e);
    const i = e.getGeometry();
    if (i) {
      const a = i.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(a, e);
    } else
      this.nullGeometryFeatures_[n] = e;
    this.dispatchEvent(
      new gi(Zt.ADDFEATURE, e)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */
  setupChangeEvents_(e, n) {
    n instanceof Kt || (this.featureChangeKeys_[e] = [
      we(n, Se.CHANGE, this.handleFeatureChange_, this),
      we(
        n,
        _a.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ]);
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(e, n) {
    let i = !0;
    if (n.getId() !== void 0) {
      const a = String(n.getId());
      if (!(a in this.idIndex_))
        this.idIndex_[a] = n;
      else if (n instanceof Kt) {
        const o = this.idIndex_[a];
        o instanceof Kt ? Array.isArray(o) ? o.push(n) : this.idIndex_[a] = [o, n] : i = !1;
      } else
        i = !1;
    }
    return i && (Ee(
      !(e in this.uidIndex_),
      "The passed `feature` was already added to the source"
    ), this.uidIndex_[e] = n), i;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */
  addFeatures(e) {
    this.addFeaturesInternal(e), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */
  addFeaturesInternal(e) {
    const n = [], i = [], a = [];
    for (let o = 0, r = e.length; o < r; o++) {
      const l = e[o], s = Ve(l);
      this.addToIndex_(s, l) && i.push(l);
    }
    for (let o = 0, r = i.length; o < r; o++) {
      const l = i[o], s = Ve(l);
      this.setupChangeEvents_(s, l);
      const u = l.getGeometry();
      if (u) {
        const c = u.getExtent();
        n.push(c), a.push(l);
      } else
        this.nullGeometryFeatures_[s] = l;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(n, a), this.hasListener(Zt.ADDFEATURE))
      for (let o = 0, r = i.length; o < r; o++)
        this.dispatchEvent(
          new gi(Zt.ADDFEATURE, i[o])
        );
  }
  /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(e) {
    let n = !1;
    this.addEventListener(
      Zt.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(i) {
        n || (n = !0, e.push(i.feature), n = !1);
      }
    ), this.addEventListener(
      Zt.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(i) {
        n || (n = !0, e.remove(i.feature), n = !1);
      }
    ), e.addEventListener(
      Rt.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (i) => {
        n || (n = !0, this.addFeature(i.element), n = !1);
      }
    ), e.addEventListener(
      Rt.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (i) => {
        n || (n = !0, this.removeFeature(i.element), n = !1);
      }
    ), this.featuresCollection_ = e;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(e) {
    if (e) {
      for (const i in this.featureChangeKeys_)
        this.featureChangeKeys_[i].forEach($e);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      const i = (a) => {
        this.removeFeatureInternal(a);
      };
      this.featuresRtree_.forEach(i);
      for (const a in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[a]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const n = new gi(Zt.CLEAR);
    this.dispatchEvent(n), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(e, n) {
    const i = [e[0], e[1], e[0], e[1]];
    return this.forEachFeatureInExtent(i, function(a) {
      const o = a.getGeometry();
      if (o instanceof Kt || o.intersectsCoordinate(e))
        return n(a);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(e, n) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(e, n);
    this.featuresCollection_ && this.featuresCollection_.forEach(n);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(e, n) {
    return this.forEachFeatureInExtent(
      e,
      /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(i) {
        const a = i.getGeometry();
        if (a instanceof Kt || a.intersectsExtent(e)) {
          const o = n(i);
          if (o)
            return o;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    let e;
    return this.featuresCollection_ ? e = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (e = this.featuresRtree_.getAll(), ba(this.nullGeometryFeatures_) || lu(e, Object.values(this.nullGeometryFeatures_))), e;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  getFeaturesAtCoordinate(e) {
    const n = [];
    return this.forEachFeatureAtCoordinateDirect(e, function(i) {
      n.push(i);
    }), n;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(e, n) {
    if (this.featuresRtree_) {
      if (!(n && n.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(e);
      const a = ug(e, n);
      return [].concat(
        ...a.map((o) => this.featuresRtree_.getInExtent(o))
      );
    }
    return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(e, n) {
    const i = e[0], a = e[1];
    let o = null;
    const r = [NaN, NaN];
    let l = 1 / 0;
    const s = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return n = n || oo, this.featuresRtree_.forEachInExtent(
      s,
      /**
       * @param {FeatureType} feature Feature.
       */
      function(u) {
        if (n(u)) {
          const c = u.getGeometry(), d = l;
          if (l = c instanceof Kt ? 0 : c.closestPointXY(i, a, r, l), l < d) {
            o = u;
            const h = Math.sqrt(l);
            s[0] = i - h, s[1] = a - h, s[2] = i + h, s[3] = a + h;
          }
        }
      }
    ), o;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(e) {
    return this.featuresRtree_.getExtent(e);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(e) {
    const n = this.idIndex_[e.toString()];
    return n !== void 0 ? (
      /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
      n
    ) : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */
  getFeatureByUid(e) {
    const n = this.uidIndex_[e];
    return n !== void 0 ? n : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<import('../format/Feature.js').FeatureToFeatureClass<FeatureType>>|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(e) {
    const n = (
      /** @type {FeatureType} */
      e.target
    ), i = Ve(n), a = n.getGeometry();
    if (!a)
      i in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(n), this.nullGeometryFeatures_[i] = n);
    else {
      const r = a.getExtent();
      i in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i], this.featuresRtree_ && this.featuresRtree_.insert(r, n)) : this.featuresRtree_ && this.featuresRtree_.update(r, n);
    }
    const o = n.getId();
    if (o !== void 0) {
      const r = o.toString();
      this.idIndex_[r] !== n && (this.removeFromIdIndex_(n), this.idIndex_[r] = n);
    } else
      this.removeFromIdIndex_(n), this.uidIndex_[i] = n;
    this.changed(), this.dispatchEvent(
      new gi(Zt.CHANGEFEATURE, n)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(e) {
    const n = e.getId();
    return n !== void 0 ? n in this.idIndex_ : Ve(e) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && ba(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, n, i) {
    const a = this.loadedExtentsRtree_, o = this.strategy_(e, n, i);
    for (let r = 0, l = o.length; r < l; ++r) {
      const s = o[r];
      a.forEachInExtent(
        s,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(c) {
          return Bi(c.extent, s);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new gi(Zt.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        s,
        n,
        i,
        (c) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new gi(
              Zt.FEATURESLOADEND,
              void 0,
              c
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new gi(Zt.FEATURESLOADERROR)
          );
        }
      ), a.insert(s, { extent: s.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(e) {
    const n = this.loadedExtentsRtree_;
    let i;
    n.forEachInExtent(e, function(a) {
      if (ro(a.extent, e))
        return i = a, !0;
    }), i && n.remove(i);
  }
  /**
   * Batch remove features from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {Array<FeatureType>} features Features to remove.
   * @api
   */
  removeFeatures(e) {
    const n = [];
    for (let i = 0, a = e.length; i < a; ++i) {
      const o = e[i], r = this.removeFeatureInternal(o);
      r && n.push(r);
    }
    n.length > 0 && this.changed();
  }
  /**
   * Remove a single feature from the source. If you want to batch remove
   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */
  removeFeature(e) {
    if (!e)
      return;
    this.removeFeatureInternal(e) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {FeatureType|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(e) {
    const n = Ve(e);
    if (!(n in this.uidIndex_))
      return;
    n in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[n] : this.featuresRtree_ && this.featuresRtree_.remove(e);
    const i = this.featureChangeKeys_[n];
    i == null || i.forEach($e), delete this.featureChangeKeys_[n];
    const a = e.getId();
    if (a !== void 0) {
      const o = a.toString(), r = this.idIndex_[o];
      r === e ? delete this.idIndex_[o] : Array.isArray(r) && (r.splice(r.indexOf(e), 1), r.length === 1 && (this.idIndex_[o] = r[0]));
    }
    return delete this.uidIndex_[n], this.hasListener(Zt.REMOVEFEATURE) && this.dispatchEvent(
      new gi(Zt.REMOVEFEATURE, e)
    ), e;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(e) {
    let n = !1;
    for (const i in this.idIndex_) {
      const a = this.idIndex_[i];
      if (e instanceof Kt && Array.isArray(a) && a.includes(e))
        a.splice(a.indexOf(e), 1);
      else if (this.idIndex_[i] === e) {
        delete this.idIndex_[i], n = !0;
        break;
      }
    }
    return n;
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader<FeatureType>} loader The loader to set.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(e) {
    Ee(this.format_, "`format` must be set when `url` is set"), this.url_ = e, this.setLoader(Yd(e, this.format_));
  }
}
const ft = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
class WM extends _n {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.options = e, this.id = e.id, this.insertFirst = e.insertFirst !== void 0 ? e.insertFirst : !0, this.stopEvent = e.stopEvent !== void 0 ? e.stopEvent : !0, this.element = document.createElement("div"), this.element.className = e.className !== void 0 ? e.className : "ol-overlay-container " + eb, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = e.autoPan === !0 ? {} : e.autoPan || void 0, this.rendered = {
      transform_: "",
      visible: !0
    }, this.mapPostrenderListenerKey = null, this.addChangeListener(ft.ELEMENT, this.handleElementChanged), this.addChangeListener(ft.MAP, this.handleMapChanged), this.addChangeListener(ft.OFFSET, this.handleOffsetChanged), this.addChangeListener(ft.POSITION, this.handlePositionChanged), this.addChangeListener(ft.POSITIONING, this.handlePositioningChanged), e.element !== void 0 && this.setElement(e.element), this.setOffset(e.offset !== void 0 ? e.offset : [0, 0]), this.setPositioning(e.positioning || "top-left"), e.position !== void 0 && this.setPosition(e.position);
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(ft.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(ft.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(ft.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(ft.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(ft.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    Fg(this.element);
    const e = this.getElement();
    e && this.element.appendChild(e);
  }
  /**
   * @protected
   */
  handleMapChanged() {
    this.mapPostrenderListenerKey && (br(this.element), $e(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
    const e = this.getMap();
    if (e) {
      this.mapPostrenderListenerKey = we(
        e,
        Zn.POSTRENDER,
        this.render,
        this
      ), this.updatePixelPosition();
      const n = this.stopEvent ? e.getOverlayContainerStopEvent() : e.getOverlayContainer();
      this.insertFirst ? n.insertBefore(this.element, n.childNodes[0] || null) : n.appendChild(this.element), this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition(), this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(e) {
    this.set(ft.ELEMENT, e);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(e) {
    this.set(ft.MAP, e);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(e) {
    this.set(ft.OFFSET, e);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(e) {
    this.set(ft.POSITION, e);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    this.autoPan && this.panIntoView(this.autoPan);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(e) {
    const n = this.getMap();
    if (!n || !n.getTargetElement() || !this.get(ft.POSITION))
      return;
    const i = this.getRect(n.getTargetElement(), n.getSize()), a = this.getElement(), o = this.getRect(a, [
      US(a),
      YS(a)
    ]);
    e = e || {};
    const r = e.margin === void 0 ? 20 : e.margin;
    if (!Bi(i, o)) {
      const l = o[0] - i[0], s = i[2] - o[2], u = o[1] - i[1], c = i[3] - o[3], d = [0, 0];
      if (l < 0 ? d[0] = l - r : s < 0 && (d[0] = Math.abs(s) + r), u < 0 ? d[1] = u - r : c < 0 && (d[1] = Math.abs(c) + r), d[0] !== 0 || d[1] !== 0) {
        const h = (
          /** @type {import("./coordinate.js").Coordinate} */
          n.getView().getCenterInternal()
        ), f = n.getPixelFromCoordinateInternal(h);
        if (!f)
          return;
        const g = [f[0] + d[0], f[1] + d[1]], m = e.animation || {};
        n.getView().animateInternal({
          center: n.getCoordinateFromPixelInternal(g),
          duration: m.duration,
          easing: m.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(e, n) {
    const i = e.getBoundingClientRect(), a = i.left + window.pageXOffset, o = i.top + window.pageYOffset;
    return [a, o, a + n[0], o + n[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(e) {
    this.set(ft.POSITIONING, e);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(e) {
    this.rendered.visible !== e && (this.element.style.display = e ? "" : "none", this.rendered.visible = e);
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const e = this.getMap(), n = this.getPosition();
    if (!e || !e.isRendered() || !n) {
      this.setVisible(!1);
      return;
    }
    const i = e.getPixelFromCoordinate(n), a = e.getSize();
    this.updateRenderedPosition(i, a);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(e, n) {
    const i = this.element.style, a = this.getOffset(), o = this.getPositioning();
    this.setVisible(!0);
    const r = Math.round(e[0] + a[0]) + "px", l = Math.round(e[1] + a[1]) + "px";
    let s = "0%", u = "0%";
    o == "bottom-right" || o == "center-right" || o == "top-right" ? s = "-100%" : (o == "bottom-center" || o == "center-center" || o == "top-center") && (s = "-50%"), o == "bottom-left" || o == "bottom-center" || o == "bottom-right" ? u = "-100%" : (o == "center-left" || o == "center-center" || o == "center-right") && (u = "-50%");
    const c = `translate(${s}, ${u}) translate(${r}, ${l})`;
    this.rendered.transform_ != c && (this.rendered.transform_ = c, i.transform = c);
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
}
const $M = ["innerHTML"], XM = {
  style: { "font-size": "14px", "font-weight": "bold" },
  class: "mb-1"
}, UM = {
  style: { "font-size": "13px" },
  class: "mb-1"
}, YM = {
  __name: "Map",
  props: ["content", "info"],
  setup(t) {
    const { getText: e } = ri();
    let n = Z(null), i = Z(null), a = Z(null), o, r;
    const l = `https://www.google.com/maps/search/?api=1&query=${t.content.coordinates[1]},${t.content.coordinates[0]}`;
    at(async () => {
      await Ye();
      const u = new Ou({
        geometry: new Hr(nd(t.content.coordinates))
      }), c = new _i({
        image: new ko({
          anchor: [0.5, 46],
          anchorXUnits: "fraction",
          anchorYUnits: "pixels",
          src: `https://generic-be-test.replit.app//colorize-image?color=%23${t.info.primaryColor.substring(1)}`
        })
      });
      u.setStyle(c);
      const d = new NM({
        features: [u]
      }), h = new FM({
        source: d
      });
      o = new w0({
        target: n.value,
        layers: [
          new rM({
            source: new eM()
          }),
          h
        ],
        view: new Pn({
          center: nd(t.content.coordinates),
          zoom: t.content.zoom
        })
      }), r = new WM({
        element: i.value,
        autoPan: !0,
        autoPanAnimation: {
          duration: 250
        },
        positioning: "bottom-center",
        offset: [0, -235]
      }), o.addOverlay(r), o.on("singleclick", function(f) {
        const g = o.forEachFeatureAtPixel(f.pixel, function(m) {
          return m;
        });
        if (g === u) {
          const m = g.getGeometry().getCoordinates();
          r.setPosition(m);
        } else
          r.setPosition(void 0);
      });
    });
    function s() {
      r.setPosition(void 0);
    }
    return (u, c) => (J(), Ce(gn, null, {
      default: H(() => [
        S(zo, { elevation: "20" }, {
          default: H(() => [
            S(gn, null, {
              default: H(() => [
                w("h3", {
                  style: re({ color: t.info.primaryColor }),
                  innerHTML: W(e)(t.content.title) || "Puoi venirci a conoscere qui"
                }, null, 12, $M),
                w("div", {
                  ref_key: "mapContainer",
                  ref: n,
                  style: { width: "100%", height: "400px" }
                }, null, 512),
                w("div", {
                  ref_key: "popupContainer",
                  ref: i,
                  class: "ol-popup"
                }, [
                  S(Be, {
                    icon: "mdi-window-close",
                    class: "popup-close-btn",
                    onClick: s
                  }),
                  w("div", {
                    ref_key: "popupContent",
                    ref: a,
                    class: "d-flex flex-column align-start"
                  }, [
                    S(nn, {
                      src: t.info.logo,
                      width: "80",
                      height: "auto",
                      "object-fit": "",
                      style: { "margin-bottom": "10px" }
                    }, null, 8, ["src"]),
                    w("p", XM, Ge(t.info.name), 1),
                    w("p", UM, Ge(t.content.address), 1),
                    w("a", {
                      href: l,
                      target: "_blank",
                      rel: "noopener noreferrer",
                      class: "nav",
                      style: re({ color: t.info.primaryColor })
                    }, [
                      S(Be, {
                        icon: "mdi-directions",
                        color: t.info.primaryColor,
                        style: { "font-size": "16px" },
                        class: "mr-1"
                      }, null, 8, ["color"]),
                      c[0] || (c[0] = ct(" Navigazione ", -1))
                    ], 4)
                  ], 512),
                  c[1] || (c[1] = w("div", { class: "ol-popup-arrow" }, null, -1))
                ], 512)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}, jM = /* @__PURE__ */ rn(YM, [["__scopeId", "data-v-22e77fbc"]]), HM = { class: "articles-wrapper margin_top__default" }, ZM = ["src"], KM = { class: "margin_top__default" }, qM = {
  __name: "Blog",
  props: ["content", "info"],
  setup(t) {
    const { getText: e } = ri(), n = Z([]), i = E(() => t.content.type === "static"), a = (o) => o ? o.length > 150 ? o.slice(0, 150) + "..." : o : "";
    return at(() => {
      i.value ? n.value = t.content.articles : Qa.getRequest("blog/post", { project: "dorianadinanni.it" }, (o) => {
        n.value = o.posts.slice(0, 3).reverse();
      });
    }), (o, r) => (J(), Ce(gn, null, {
      default: H(() => [
        w("h1", {
          style: re({ color: t.info.primaryColor })
        }, Ge(W(e)(t.content.title) || "I miei articoli"), 5),
        w("div", HM, [
          (J(!0), Ie(pe, null, Ft(n.value, (l, s) => (J(), Ie("div", {
            key: s,
            class: "article-item mt-2"
          }, [
            w("img", {
              src: W(Ni)(l.cover),
              class: "img"
            }, null, 8, ZM),
            w("p", {
              style: re({ color: t.info.primaryColor, fontWeight: 700 })
            }, Ge(W(e)(l.title)), 5),
            w("p", null, Ge(a(W(e)(l.content))), 1)
          ]))), 128))
        ]),
        w("p", KM, [
          w("a", {
            href: "/blog",
            class: "link",
            style: re({ color: t.info.primaryColor })
          }, Ge(W(e)(t.content.url)), 5)
        ])
      ]),
      _: 1
    }));
  }
}, JM = /* @__PURE__ */ rn(qM, [["__scopeId", "data-v-d2a4554c"]]), QM = {
  __name: "Line",
  props: ["info"],
  setup(t) {
    return (e, n) => (J(), Ce(gn, null, {
      default: H(() => [
        w("hr", {
          style: re({ height: "5px", backgroundColor: t.info.primaryColor })
        }, null, 4)
      ]),
      _: 1
    }));
  }
}, ex = (t) => {
  const {
    touchstartX: e,
    touchendX: n,
    touchstartY: i,
    touchendY: a
  } = t, o = 0.5, r = 16;
  t.offsetX = n - e, t.offsetY = a - i, Math.abs(t.offsetY) < o * Math.abs(t.offsetX) && (t.left && n < e - r && t.left(t), t.right && n > e + r && t.right(t)), Math.abs(t.offsetX) < o * Math.abs(t.offsetY) && (t.up && a < i - r && t.up(t), t.down && a > i + r && t.down(t));
};
function tx(t, e) {
  var i;
  const n = t.changedTouches[0];
  e.touchstartX = n.clientX, e.touchstartY = n.clientY, (i = e.start) == null || i.call(e, {
    originalEvent: t,
    ...e
  });
}
function nx(t, e) {
  var i;
  const n = t.changedTouches[0];
  e.touchendX = n.clientX, e.touchendY = n.clientY, (i = e.end) == null || i.call(e, {
    originalEvent: t,
    ...e
  }), ex(e);
}
function ix(t, e) {
  var i;
  const n = t.changedTouches[0];
  e.touchmoveX = n.clientX, e.touchmoveY = n.clientY, (i = e.move) == null || i.call(e, {
    originalEvent: t,
    ...e
  });
}
function ax() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const e = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: t.left,
    right: t.right,
    up: t.up,
    down: t.down,
    start: t.start,
    move: t.move,
    end: t.end
  };
  return {
    touchstart: (n) => tx(n, e),
    touchend: (n) => nx(n, e),
    touchmove: (n) => ix(n, e)
  };
}
function ox(t, e) {
  var l;
  const n = e.value, i = n != null && n.parent ? t.parentElement : t, a = (n == null ? void 0 : n.options) ?? {
    passive: !0
  }, o = (l = e.instance) == null ? void 0 : l.$.uid;
  if (!i || !o) return;
  const r = ax(e.value);
  i._touchHandlers = i._touchHandlers ?? /* @__PURE__ */ Object.create(null), i._touchHandlers[o] = r, sh(r).forEach((s) => {
    i.addEventListener(s, r[s], a);
  });
}
function rx(t, e) {
  var o, r;
  const n = (o = e.value) != null && o.parent ? t.parentElement : t, i = (r = e.instance) == null ? void 0 : r.$.uid;
  if (!(n != null && n._touchHandlers) || !i) return;
  const a = n._touchHandlers[i];
  sh(a).forEach((l) => {
    n.removeEventListener(l, a[l]);
  }), delete n._touchHandlers[i];
}
const vs = {
  mounted: ox,
  unmounted: rx
}, Cm = Symbol.for("vuetify:v-window"), pm = Symbol.for("vuetify:v-window-group"), _m = U({
  continuous: Boolean,
  nextIcon: {
    type: [Boolean, String, Function, Object],
    default: "$next"
  },
  prevIcon: {
    type: [Boolean, String, Function, Object],
    default: "$prev"
  },
  reverse: Boolean,
  showArrows: {
    type: [Boolean, String],
    validator: (t) => typeof t == "boolean" || t === "hover"
  },
  verticalArrows: [Boolean, String],
  touch: {
    type: [Object, Boolean],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  modelValue: null,
  disabled: Boolean,
  selectedClass: {
    type: String,
    default: "v-window-item--active"
  },
  // TODO: mandatory should probably not be exposed but do this for now
  mandatory: {
    type: [Boolean, String],
    default: "force"
  },
  ...ve(),
  ...Oe(),
  ...Ue()
}, "VWindow"), jd = ee()({
  name: "VWindow",
  directives: {
    vTouch: vs
  },
  props: _m(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      themeClasses: i
    } = et(t), {
      isRtl: a
    } = Wt(), {
      t: o
    } = Aa(), r = Ro(t, pm), l = Z(), s = E(() => a.value ? !t.reverse : t.reverse), u = Q(!1), c = E(() => {
      const p = t.direction === "vertical" ? "y" : "x", P = (s.value ? !u.value : u.value) ? "-reverse" : "";
      return `v-window-${p}${P}-transition`;
    }), d = Q(0), h = Z(void 0), f = E(() => r.items.value.findIndex((p) => r.selected.value.includes(p.id)));
    ie(f, (p, b) => {
      const P = r.items.value.length, x = P - 1;
      P <= 2 ? u.value = p < b : p === x && b === 0 ? u.value = !0 : p === 0 && b === x ? u.value = !1 : u.value = p < b;
    }), ht(Cm, {
      transition: c,
      isReversed: u,
      transitionCount: d,
      transitionHeight: h,
      rootRef: l
    });
    const g = O(() => t.continuous || f.value !== 0), m = O(() => t.continuous || f.value !== r.items.value.length - 1);
    function v() {
      g.value && r.prev();
    }
    function y() {
      m.value && r.next();
    }
    const C = E(() => {
      const p = [], b = {
        icon: a.value ? t.nextIcon : t.prevIcon,
        class: `v-window__${s.value ? "right" : "left"}`,
        onClick: r.prev,
        "aria-label": o("$vuetify.carousel.prev")
      };
      p.push(g.value ? n.prev ? n.prev({
        props: b
      }) : S(At, b, null) : w("div", null, null));
      const P = {
        icon: a.value ? t.prevIcon : t.nextIcon,
        class: `v-window__${s.value ? "left" : "right"}`,
        onClick: r.next,
        "aria-label": o("$vuetify.carousel.next")
      };
      return p.push(m.value ? n.next ? n.next({
        props: P
      }) : S(At, P, null) : w("div", null, null)), p;
    }), M = E(() => t.touch === !1 ? t.touch : {
      ...{
        left: () => {
          s.value ? v() : y();
        },
        right: () => {
          s.value ? y() : v();
        },
        start: (b) => {
          let {
            originalEvent: P
          } = b;
          P.stopPropagation();
        }
      },
      ...t.touch === !0 ? {} : t.touch
    });
    return le(() => it(S(t.tag, {
      ref: l,
      class: te(["v-window", {
        "v-window--show-arrows-on-hover": t.showArrows === "hover",
        "v-window--vertical-arrows": !!t.verticalArrows
      }, i.value, t.class]),
      style: re(t.style)
    }, {
      default: () => {
        var p, b;
        return [w("div", {
          class: "v-window__container",
          style: {
            height: h.value
          }
        }, [(p = n.default) == null ? void 0 : p.call(n, {
          group: r
        }), t.showArrows !== !1 && w("div", {
          class: te(["v-window__controls", {
            "v-window__controls--left": t.verticalArrows === "left" || t.verticalArrows === !0
          }, {
            "v-window__controls--right": t.verticalArrows === "right"
          }])
        }, [C.value])]), (b = n.additional) == null ? void 0 : b.call(n, {
          group: r
        })];
      }
    }), [[vs, M.value]])), {
      group: r
    };
  }
}), lx = U({
  color: String,
  cycle: Boolean,
  delimiterIcon: {
    type: Pe,
    default: "$delimiter"
  },
  height: {
    type: [Number, String],
    default: 500
  },
  hideDelimiters: Boolean,
  hideDelimiterBackground: Boolean,
  interval: {
    type: [Number, String],
    default: 6e3,
    validator: (t) => Number(t) > 0
  },
  progress: [Boolean, String],
  verticalDelimiters: [Boolean, String],
  ..._m({
    continuous: !0,
    mandatory: "force",
    showArrows: !0
  })
}, "VCarousel"), ys = ee()({
  name: "VCarousel",
  props: lx(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Xe(t, "modelValue"), {
      t: a
    } = Aa(), o = Z();
    let r = -1;
    ie(i, s), ie(() => t.interval, s), ie(() => t.cycle, (u) => {
      u ? s() : window.clearTimeout(r);
    }), at(l);
    function l() {
      !t.cycle || !o.value || (r = window.setTimeout(o.value.group.next, Number(t.interval) > 0 ? Number(t.interval) : 6e3));
    }
    function s() {
      window.clearTimeout(r), window.requestAnimationFrame(l);
    }
    return le(() => {
      const u = jd.filterProps(t);
      return S(jd, oe({
        ref: o
      }, u, {
        modelValue: i.value,
        "onUpdate:modelValue": (c) => i.value = c,
        class: ["v-carousel", {
          "v-carousel--hide-delimiter-background": t.hideDelimiterBackground,
          "v-carousel--vertical-delimiters": t.verticalDelimiters
        }, t.class],
        style: [{
          height: he(t.height)
        }, t.style]
      }), {
        default: n.default,
        additional: (c) => {
          let {
            group: d
          } = c;
          return w(pe, null, [!t.hideDelimiters && w("div", {
            class: "v-carousel__controls",
            style: {
              left: t.verticalDelimiters === "left" && t.verticalDelimiters ? 0 : "auto",
              right: t.verticalDelimiters === "right" ? 0 : "auto"
            }
          }, [d.items.value.length > 0 && S(We, {
            defaults: {
              VBtn: {
                color: t.color,
                icon: t.delimiterIcon,
                size: "x-small",
                variant: "text"
              }
            },
            scoped: !0
          }, {
            default: () => [d.items.value.map((h, f) => {
              const g = {
                id: `carousel-item-${h.id}`,
                "aria-label": a("$vuetify.carousel.ariaLabel.delimiter", f + 1, d.items.value.length),
                class: ["v-carousel__controls__item", d.isSelected(h.id) && "v-btn--active"],
                onClick: () => d.select(h.id, !0)
              };
              return n.item ? n.item({
                props: g,
                item: h
              }) : S(At, oe(h, g), null);
            })]
          })]), t.progress && S(Tf, {
            absolute: !0,
            class: "v-carousel__progress",
            color: typeof t.progress == "string" ? t.progress : void 0,
            modelValue: (d.getItemIndex(i.value) + 1) / d.items.value.length * 100
          }, null)]);
        },
        prev: n.prev,
        next: n.next
      });
    }), {};
  }
}), Sm = U({
  reverseTransition: {
    type: [Boolean, String],
    default: void 0
  },
  transition: {
    type: [Boolean, String],
    default: void 0
  },
  ...ve(),
  ...Eo(),
  ...Xs()
}, "VWindowItem"), Hd = ee()({
  name: "VWindowItem",
  directives: {
    vTouch: vs
  },
  props: Sm(),
  emits: {
    "group:selected": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Ne(Cm), a = Ao(t, pm), {
      isBooted: o
    } = Io();
    if (!i || !a) throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const r = Q(!1), l = E(() => o.value && (i.isReversed.value ? t.reverseTransition !== !1 : t.transition !== !1));
    function s() {
      !r.value || !i || (r.value = !1, i.transitionCount.value > 0 && (i.transitionCount.value -= 1, i.transitionCount.value === 0 && (i.transitionHeight.value = void 0)));
    }
    function u() {
      var g;
      r.value || !i || (r.value = !0, i.transitionCount.value === 0 && (i.transitionHeight.value = he((g = i.rootRef.value) == null ? void 0 : g.clientHeight)), i.transitionCount.value += 1);
    }
    function c() {
      s();
    }
    function d(g) {
      r.value && Ye(() => {
        !l.value || !r.value || !i || (i.transitionHeight.value = he(g.clientHeight));
      });
    }
    const h = E(() => {
      const g = i.isReversed.value ? t.reverseTransition : t.transition;
      return l.value ? {
        name: typeof g != "string" ? i.transition.value : g,
        onBeforeEnter: u,
        onAfterEnter: s,
        onEnterCancelled: c,
        onBeforeLeave: u,
        onAfterLeave: s,
        onLeaveCancelled: c,
        onEnter: d
      } : !1;
    }), {
      hasContent: f
    } = Us(t, a.isSelected);
    return le(() => S(Jn, {
      transition: h.value,
      disabled: !o.value
    }, {
      default: () => {
        var g;
        return [it(w("div", {
          class: te(["v-window-item", a.selectedClass.value, t.class]),
          style: re(t.style)
        }, [f.value && ((g = n.default) == null ? void 0 : g.call(n))]), [[Pi, a.isSelected.value]])];
      }
    })), {
      groupItem: a
    };
  }
}), sx = U({
  ...xh(),
  ...Sm()
}, "VCarouselItem"), Cs = ee()({
  name: "VCarouselItem",
  inheritAttrs: !1,
  props: sx(),
  setup(t, e) {
    let {
      slots: n,
      attrs: i
    } = e;
    le(() => {
      const a = nn.filterProps(t), o = Hd.filterProps(t);
      return S(Hd, oe({
        class: ["v-carousel-item", t.class]
      }, o), {
        default: () => [S(nn, oe(i, a), n)]
      });
    });
  }
}), ux = {
  __name: "Gallery",
  props: ["id", "content", "info"],
  setup(t) {
    const e = wa(), n = Z(0), i = Z(null), a = () => {
      n.value = (n.value + t.content.images.length - 1) % t.content.images.length;
    }, o = () => {
      n.value = (n.value + 1) % t.content.images.length;
    }, r = () => {
      i.value = setInterval(() => {
        o();
      }, 4e3);
    }, l = () => {
      i.value ? (clearInterval(i.value), i.value = null) : r();
    }, s = (u) => {
      u.key === "ArrowLeft" ? (a(), l()) : u.key === "ArrowRight" && (o(), l());
    };
    return at(() => {
      window.addEventListener("keydown", s), r();
    }), Zd(() => {
      window.removeEventListener("keydown", s), clearInterval(i.value);
    }), (u, c) => (J(), Ie(pe, null, [
      t.content.type === "manual" ? (J(), Ce(ys, {
        key: 0,
        id: t.id,
        height: W(e) ? 400 : 600,
        "delimiter-icon": "mdi-square"
      }, {
        default: H(() => [
          (J(!0), Ie(pe, null, Ft(t.content.images, (d, h) => (J(), Ce(Cs, { key: h }, {
            default: H(() => [
              S(nn, {
                src: W(Ni)(d),
                cover: ""
              }, null, 8, ["src"])
            ]),
            _: 2
          }, 1024))), 128))
        ]),
        _: 1
      }, 8, ["id", "height"])) : Ae("", !0),
      t.content.type === "automatic" ? (J(), Ce(ys, {
        key: 1,
        id: t.id,
        style: { height: "96vh" },
        onClick: l,
        modelValue: n.value,
        "onUpdate:modelValue": c[0] || (c[0] = (d) => n.value = d),
        "hide-delimiters": ""
      }, {
        prev: H(() => c[1] || (c[1] = [])),
        next: H(() => c[2] || (c[2] = [])),
        default: H(() => [
          (J(!0), Ie(pe, null, Ft(t.content.images, (d) => (J(), Ce(Cs, {
            src: W(Ni)(d),
            cover: ""
          }, null, 8, ["src"]))), 256))
        ]),
        _: 1
      }, 8, ["id", "modelValue"])) : Ae("", !0)
    ], 64));
  }
}, cx = /* @__PURE__ */ rn(ux, [["__scopeId", "data-v-f361fddd"]]), po = Symbol.for("vuetify:v-expansion-panel"), bm = U({
  ...ve(),
  ...Xs()
}, "VExpansionPanelText"), ps = ee()({
  name: "VExpansionPanelText",
  props: bm(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Ne(po);
    if (!i) throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
    const {
      hasContent: a,
      onAfterLeave: o
    } = Us(t, i.isSelected);
    return le(() => S(Bs, {
      onAfterLeave: o
    }, {
      default: () => {
        var r;
        return [it(w("div", {
          class: te(["v-expansion-panel-text", t.class]),
          style: re(t.style)
        }, [n.default && a.value && w("div", {
          class: "v-expansion-panel-text__wrapper"
        }, [(r = n.default) == null ? void 0 : r.call(n)])]), [[Pi, i.isSelected.value]])];
      }
    })), {};
  }
}), Mm = U({
  color: String,
  expandIcon: {
    type: Pe,
    default: "$expand"
  },
  collapseIcon: {
    type: Pe,
    default: "$collapse"
  },
  hideActions: Boolean,
  focusable: Boolean,
  static: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !1
  },
  readonly: Boolean,
  ...ve(),
  ...ln()
}, "VExpansionPanelTitle"), _s = ee()({
  name: "VExpansionPanelTitle",
  directives: {
    vRipple: fn
  },
  props: Mm(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Ne(po);
    if (!i) throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: o
    } = xt(() => t.color), {
      dimensionStyles: r
    } = sn(t), l = E(() => ({
      collapseIcon: t.collapseIcon,
      disabled: i.disabled.value,
      expanded: i.isSelected.value,
      expandIcon: t.expandIcon,
      readonly: t.readonly
    })), s = O(() => i.isSelected.value ? t.collapseIcon : t.expandIcon);
    return le(() => {
      var u;
      return it(w("button", {
        class: te(["v-expansion-panel-title", {
          "v-expansion-panel-title--active": i.isSelected.value,
          "v-expansion-panel-title--focusable": t.focusable,
          "v-expansion-panel-title--static": t.static
        }, a.value, t.class]),
        style: re([o.value, r.value, t.style]),
        type: "button",
        tabindex: i.disabled.value ? -1 : void 0,
        disabled: i.disabled.value,
        "aria-expanded": i.isSelected.value,
        onClick: t.readonly ? void 0 : i.toggle
      }, [w("span", {
        class: "v-expansion-panel-title__overlay"
      }, null), (u = n.default) == null ? void 0 : u.call(n, l.value), !t.hideActions && S(We, {
        defaults: {
          VIcon: {
            icon: s.value
          }
        }
      }, {
        default: () => {
          var c;
          return [w("span", {
            class: "v-expansion-panel-title__icon"
          }, [((c = n.actions) == null ? void 0 : c.call(n, l.value)) ?? S(Be, null, null)])];
        }
      })]), [[fn, t.ripple]]);
    }), {};
  }
}), xm = U({
  title: String,
  text: String,
  bgColor: String,
  ...Cn(),
  ...Eo(),
  ...Tt(),
  ...Oe(),
  ...Mm(),
  ...bm()
}, "VExpansionPanel"), dx = ee()({
  name: "VExpansionPanel",
  props: xm(),
  emits: {
    "group:selected": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Ao(t, po), {
      backgroundColorClasses: a,
      backgroundColorStyles: o
    } = xt(() => t.bgColor), {
      elevationClasses: r
    } = pn(t), {
      roundedClasses: l
    } = wt(t), s = O(() => (i == null ? void 0 : i.disabled.value) || t.disabled), u = E(() => i.group.items.value.reduce((h, f, g) => (i.group.selected.value.includes(f.id) && h.push(g), h), [])), c = E(() => {
      const h = i.group.items.value.findIndex((f) => f.id === i.id);
      return !i.isSelected.value && u.value.some((f) => f - h === 1);
    }), d = E(() => {
      const h = i.group.items.value.findIndex((f) => f.id === i.id);
      return !i.isSelected.value && u.value.some((f) => f - h === -1);
    });
    return ht(po, i), le(() => {
      const h = !!(n.text || t.text), f = !!(n.title || t.title), g = _s.filterProps(t), m = ps.filterProps(t);
      return S(t.tag, {
        class: te(["v-expansion-panel", {
          "v-expansion-panel--active": i.isSelected.value,
          "v-expansion-panel--before-active": c.value,
          "v-expansion-panel--after-active": d.value,
          "v-expansion-panel--disabled": s.value
        }, l.value, a.value, t.class]),
        style: re([o.value, t.style])
      }, {
        default: () => [w("div", {
          class: te(["v-expansion-panel__shadow", ...r.value])
        }, null), S(We, {
          defaults: {
            VExpansionPanelTitle: {
              ...g
            },
            VExpansionPanelText: {
              ...m
            }
          }
        }, {
          default: () => {
            var v;
            return [f && S(_s, {
              key: "title"
            }, {
              default: () => [n.title ? n.title() : t.title]
            }), h && S(ps, {
              key: "text"
            }, {
              default: () => [n.text ? n.text() : t.text]
            }), (v = n.default) == null ? void 0 : v.call(n)];
          }
        })]
      });
    }), {
      groupItem: i
    };
  }
}), hx = ["default", "accordion", "inset", "popout"], fx = U({
  flat: Boolean,
  ...Br(),
  ...bo(xm(), ["bgColor", "collapseIcon", "color", "eager", "elevation", "expandIcon", "focusable", "hideActions", "readonly", "ripple", "rounded", "tile", "static"]),
  ...Ue(),
  ...ve(),
  ...Oe(),
  variant: {
    type: String,
    default: "default",
    validator: (t) => hx.includes(t)
  }
}, "VExpansionPanels"), gx = ee()({
  name: "VExpansionPanels",
  props: fx(),
  emits: {
    "update:modelValue": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      next: i,
      prev: a
    } = Ro(t, po), {
      themeClasses: o
    } = et(t), r = O(() => t.variant && `v-expansion-panels--variant-${t.variant}`);
    return ai({
      VExpansionPanel: {
        bgColor: O(() => t.bgColor),
        collapseIcon: O(() => t.collapseIcon),
        color: O(() => t.color),
        eager: O(() => t.eager),
        elevation: O(() => t.elevation),
        expandIcon: O(() => t.expandIcon),
        focusable: O(() => t.focusable),
        hideActions: O(() => t.hideActions),
        readonly: O(() => t.readonly),
        ripple: O(() => t.ripple),
        rounded: O(() => t.rounded),
        static: O(() => t.static)
      }
    }), le(() => S(t.tag, {
      class: te(["v-expansion-panels", {
        "v-expansion-panels--flat": t.flat,
        "v-expansion-panels--tile": t.tile
      }, o.value, r.value, t.class]),
      style: re(t.style)
    }, {
      default: () => {
        var l;
        return [(l = n.default) == null ? void 0 : l.call(n, {
          prev: a,
          next: i
        })];
      }
    })), {
      next: i,
      prev: a
    };
  }
}), mx = ["innerHTML"], vx = ["innerHTML"], yx = ["innerHTML"], Cx = {
  __name: "Services",
  props: ["content", "info"],
  setup(t) {
    const { getText: e } = ri();
    return (n, i) => (J(), Ce(gn, null, {
      default: H(() => [
        w("h1", {
          style: re({ color: t.info.primaryColor }),
          innerHTML: W(e)(t.content.title) || "I nostri servizi"
        }, null, 12, mx),
        S(gx, { multiple: "" }, {
          default: H(() => [
            (J(!0), Ie(pe, null, Ft(t.content.services, (a) => (J(), Ce(dx, {
              elevation: "20",
              class: "margin_top__default"
            }, {
              default: H(() => [
                S(_s, null, {
                  default: H(() => [
                    w("b", {
                      innerHTML: W(e)(a.name)
                    }, null, 8, vx)
                  ]),
                  _: 2
                }, 1024),
                S(ps, null, {
                  default: H(() => [
                    w("div", {
                      innerHTML: W(e)(a.description)
                    }, null, 8, yx)
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1024))), 256))
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}, rl = [
  (t) => t ? !0 : "Campo obbligatorio"
], px = rl.concat([
  (t) => /.+@.+\..+/.test(t) ? !0 : "E-mail non valida."
]), _x = rl.concat([
  (t) => /^(https?:\/\/)?([\w-]+\.)+([a-z]{2,})+(\/[\w-]*)*(\?[a-z0-9-]+=[a-z0-9-%]+(&[a-z0-9-]+=[a-z0-9-%]+)*)?$/i.test(t) ? !0 : "Sito non valido."
]), Sx = rl.concat([
  (t) => /[A-Z]/.test(t) ? !0 : "La password deve contenere almeno una lettera maiscola.",
  (t) => /[a-z]/.test(t) ? !0 : "La password deve contenere almeno una lettera minuscola.",
  (t) => /\d/.test(t) ? !0 : "La password deve contenere almeno un numero.",
  (t) => t.length >= 8 ? !0 : "La password deve contenere almeno 8 caratteri."
]), bx = (t, e) => {
  const n = [];
  for (const i of e) {
    const a = i(t);
    a !== !0 && n.push(a);
  }
  return n.length === 0 ? null : n;
}, Yn = {
  validateInput: bx,
  requiredRules: rl,
  emailRules: px,
  siteRules: _x,
  passwordRules: Sx
}, Mx = U({
  ...ve(),
  ...by()
}, "VForm"), xx = ee()({
  name: "VForm",
  props: Mx(),
  emits: {
    "update:modelValue": (t) => !0,
    submit: (t) => !0
  },
  setup(t, e) {
    let {
      slots: n,
      emit: i
    } = e;
    const a = My(t), o = Z();
    function r(s) {
      s.preventDefault(), a.reset();
    }
    function l(s) {
      const u = s, c = a.validate();
      u.then = c.then.bind(c), u.catch = c.catch.bind(c), u.finally = c.finally.bind(c), i("submit", u), u.defaultPrevented || c.then((d) => {
        var f;
        let {
          valid: h
        } = d;
        h && ((f = o.value) == null || f.submit());
      }), u.preventDefault();
    }
    return le(() => {
      var s;
      return w("form", {
        ref: o,
        class: te(["v-form", t.class]),
        style: re(t.style),
        novalidate: !0,
        onReset: r,
        onSubmit: l
      }, [(s = n.default) == null ? void 0 : s.call(n, a)]);
    }), Ra(a, o);
  }
}), Px = U({
  autoGrow: Boolean,
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  noResize: Boolean,
  rows: {
    type: [Number, String],
    default: 5,
    validator: (t) => !isNaN(parseFloat(t))
  },
  maxRows: {
    type: [Number, String],
    validator: (t) => !isNaN(parseFloat(t))
  },
  suffix: String,
  modelModifiers: Object,
  ...Os(),
  ...Zs()
}, "VTextarea"), Tx = ee()({
  name: "VTextarea",
  directives: {
    vIntersect: Ca
  },
  inheritAttrs: !1,
  props: Px(),
  emits: {
    "click:control": (t) => !0,
    "mousedown:control": (t) => !0,
    "update:focused": (t) => !0,
    "update:modelValue": (t) => !0,
    "update:rows": (t) => !0
  },
  setup(t, e) {
    let {
      attrs: n,
      emit: i,
      slots: a
    } = e;
    const o = Xe(t, "modelValue"), {
      isFocused: r,
      focus: l,
      blur: s
    } = Fs(t), {
      onIntersect: u
    } = Ef(t), c = E(() => typeof t.counterValue == "function" ? t.counterValue(o.value) : (o.value || "").toString().length), d = E(() => {
      if (n.maxlength) return n.maxlength;
      if (!(!t.counter || typeof t.counter != "number" && typeof t.counter != "string"))
        return t.counter;
    }), h = Z(), f = Z(), g = Q(""), m = Z(), v = E(() => t.persistentPlaceholder || r.value || t.active);
    function y() {
      var L;
      m.value !== document.activeElement && ((L = m.value) == null || L.focus()), r.value || l();
    }
    function C(L) {
      y(), i("click:control", L);
    }
    function M(L) {
      i("mousedown:control", L);
    }
    function p(L) {
      L.stopPropagation(), y(), Ye(() => {
        o.value = "", As(t["onClick:clear"], L);
      });
    }
    function b(L) {
      var I;
      const z = L.target;
      if (o.value = z.value, (I = t.modelModifiers) != null && I.trim) {
        const k = [z.selectionStart, z.selectionEnd];
        Ye(() => {
          z.selectionStart = k[0], z.selectionEnd = k[1];
        });
      }
    }
    const P = Z(), x = Z(Number(t.rows)), _ = E(() => ["plain", "underlined"].includes(t.variant));
    Pt(() => {
      t.autoGrow || (x.value = Number(t.rows));
    });
    function T() {
      t.autoGrow && Ye(() => {
        if (!P.value || !f.value) return;
        const L = getComputedStyle(P.value), z = getComputedStyle(f.value.$el), I = parseFloat(L.getPropertyValue("--v-field-padding-top")) + parseFloat(L.getPropertyValue("--v-input-padding-top")) + parseFloat(L.getPropertyValue("--v-field-padding-bottom")), k = P.value.scrollHeight, G = parseFloat(L.lineHeight), F = Math.max(parseFloat(t.rows) * G + I, parseFloat(z.getPropertyValue("--v-input-control-height"))), q = parseFloat(t.maxRows) * G + I || 1 / 0, j = Gt(k ?? 0, F, q);
        x.value = Math.floor((j - I) / G), g.value = he(j);
      });
    }
    at(T), ie(o, T), ie(() => t.rows, T), ie(() => t.maxRows, T), ie(() => t.density, T), ie(x, (L) => {
      i("update:rows", L);
    });
    let B;
    return ie(P, (L) => {
      L ? (B = new ResizeObserver(T), B.observe(P.value)) : B == null || B.disconnect();
    }), pt(() => {
      B == null || B.disconnect();
    }), le(() => {
      const L = !!(a.counter || t.counter || t.counterValue), z = !!(L || a.details), [I, k] = ws(n), {
        modelValue: G,
        ...F
      } = hr.filterProps(t), q = gr.filterProps(t);
      return S(hr, oe({
        ref: h,
        modelValue: o.value,
        "onUpdate:modelValue": (j) => o.value = j,
        class: ["v-textarea v-text-field", {
          "v-textarea--prefixed": t.prefix,
          "v-textarea--suffixed": t.suffix,
          "v-text-field--prefixed": t.prefix,
          "v-text-field--suffixed": t.suffix,
          "v-textarea--auto-grow": t.autoGrow,
          "v-textarea--no-resize": t.noResize || t.autoGrow,
          "v-input--plain-underlined": _.value
        }, t.class],
        style: t.style
      }, I, F, {
        centerAffix: x.value === 1 && !_.value,
        focused: r.value
      }), {
        ...a,
        default: (j) => {
          let {
            id: ne,
            isDisabled: A,
            isDirty: R,
            isReadonly: V,
            isValid: X,
            hasDetails: D
          } = j;
          return S(gr, oe({
            ref: f,
            style: {
              "--v-textarea-control-height": g.value
            },
            onClick: C,
            onMousedown: M,
            "onClick:clear": p,
            "onClick:prependInner": t["onClick:prependInner"],
            "onClick:appendInner": t["onClick:appendInner"]
          }, q, {
            id: ne.value,
            active: v.value || R.value,
            centerAffix: x.value === 1 && !_.value,
            dirty: R.value || t.dirty,
            disabled: A.value,
            focused: r.value,
            details: D.value,
            error: X.value === !1
          }), {
            ...a,
            default: (Y) => {
              let {
                props: {
                  class: ce,
                  ...K
                }
              } = Y;
              return w(pe, null, [t.prefix && w("span", {
                class: "v-text-field__prefix"
              }, [t.prefix]), it(w("textarea", oe({
                ref: m,
                class: ce,
                value: o.value,
                onInput: b,
                autofocus: t.autofocus,
                readonly: V.value,
                disabled: A.value,
                placeholder: t.placeholder,
                rows: t.rows,
                name: t.name,
                onFocus: y,
                onBlur: s
              }, K, k), null), [[Ca, {
                handler: u
              }, null, {
                once: !0
              }]]), t.autoGrow && it(w("textarea", {
                class: te([ce, "v-textarea__sizer"]),
                id: `${K.id}-sizer`,
                "onUpdate:modelValue": (se) => o.value = se,
                ref: P,
                readonly: !0,
                "aria-hidden": "true"
              }, null), [[Um, o.value]]), t.suffix && w("span", {
                class: "v-text-field__suffix"
              }, [t.suffix])]);
            }
          });
        },
        details: z ? (j) => {
          var ne;
          return w(pe, null, [(ne = a.details) == null ? void 0 : ne.call(a, j), L && w(pe, null, [w("span", null, null), S(xf, {
            active: t.persistentCounter || r.value,
            value: c.value,
            max: d.value,
            disabled: t.disabled
          }, a.counter)])]);
        } : void 0
      });
    }), Ra({}, h, f, m);
  }
}), wx = ["innerHTML"], Ex = ["href", "innerHTML"], Ax = ["innerHTML"], Rx = {
  __name: "Contacts",
  props: ["content", "info"],
  setup(t) {
    const { getText: n } = ri(), i = Z(""), a = Z(""), o = Z(""), r = () => {
      !Yn.validateInput(o.value, Yn.emailRules) && !Yn.validateInput(i.value, Yn.requiredRules) && !Yn.validateInput(a.value, Yn.requiredRules) && Qa.postRequest("send-email", {
        email: "",
        subject: `Qualcuno ho usato il form del sito ${t.info.name}`,
        body: `Buongiorno,
Sono il tuo mailer, hai ricevuto il seguente messaggio:

Nominativo: ${i.value}
Mail: ${o.value}

Testo:
${a.value}`
      }, function() {
        alert(`Mail inviata
Ti ringraziamo per il contatto`);
      });
    };
    return (l, s) => (J(), Ce(gn, null, {
      default: H(() => [
        S(zo, { elevation: "20" }, {
          default: H(() => [
            S(gn, null, {
              default: H(() => [
                w("h2", {
                  style: re({ color: t.info.primaryColor }),
                  innerHTML: W(n)(t.content.title) || "I nostri contatti"
                }, null, 12, wx),
                S(Ia, null, {
                  default: H(() => [
                    (J(!0), Ie(pe, null, Ft(t.content.contacts, (u) => (J(), Ce(Fn, {
                      height: "20",
                      key: u
                    }, {
                      prepend: H(() => [
                        S(Be, {
                          icon: u.icon,
                          color: t.info.primaryColor
                        }, null, 8, ["icon", "color"])
                      ]),
                      default: H(() => [
                        S(cf, { class: "contact__text" }, {
                          default: H(() => [
                            w("a", {
                              href: u.url,
                              target: "_blank",
                              style: { "text-decoration": "none", color: "inherit" },
                              innerHTML: W(n)(u.title)
                            }, null, 8, Ex)
                          ]),
                          _: 2
                        }, 1024)
                      ]),
                      _: 2
                    }, 1024))), 128))
                  ]),
                  _: 1
                }),
                s[4] || (s[4] = w("br", null, null, -1)),
                w("hr", {
                  style: re({ height: "5px", backgroundColor: t.info.primaryColor })
                }, null, 4),
                s[5] || (s[5] = w("br", null, null, -1)),
                w("b", {
                  innerHTML: W(n)(t.content.subtitle) || "Contattaci direttamente con questo form"
                }, null, 8, Ax),
                s[6] || (s[6] = w("br", null, null, -1)),
                s[7] || (s[7] = w("br", null, null, -1)),
                S(xx, {
                  "fast-fail": "",
                  onSubmit: Ja(r, ["prevent"])
                }, {
                  default: H(() => [
                    S(pa, null, {
                      default: H(() => [
                        S(dn, {
                          cols: "12",
                          md: "6"
                        }, {
                          default: H(() => [
                            S(Qn, {
                              modelValue: i.value,
                              "onUpdate:modelValue": s[0] || (s[0] = (u) => i.value = u),
                              rules: W(Yn).requiredRules,
                              variant: "outlined",
                              label: "Name"
                            }, null, 8, ["modelValue", "rules"])
                          ]),
                          _: 1
                        }),
                        S(dn, {
                          cols: "12",
                          md: "6"
                        }, {
                          default: H(() => [
                            S(Qn, {
                              modelValue: o.value,
                              "onUpdate:modelValue": s[1] || (s[1] = (u) => o.value = u),
                              rules: W(Yn).emailRules,
                              variant: "outlined",
                              label: "Email"
                            }, null, 8, ["modelValue", "rules"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    S(pa, null, {
                      default: H(() => [
                        S(dn, {
                          cols: "12",
                          md: "12"
                        }, {
                          default: H(() => [
                            S(Tx, {
                              label: "Body",
                              rows: "4",
                              modelValue: a.value,
                              "onUpdate:modelValue": s[2] || (s[2] = (u) => a.value = u),
                              rules: W(Yn).requiredRules,
                              variant: "outlined"
                            }, null, 8, ["modelValue", "rules"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    s[3] || (s[3] = w("br", null, null, -1)),
                    S(At, {
                      block: "",
                      text: "Send",
                      type: "submit",
                      color: t.info.primaryColor
                    }, null, 8, ["color"])
                  ]),
                  _: 1,
                  __: [3]
                })
              ]),
              _: 1,
              __: [4, 5, 6, 7]
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}, Ix = /* @__PURE__ */ rn(Rx, [["__scopeId", "data-v-4734370a"]]), zx = ee()({
  name: "VSlideGroupItem",
  props: Eo(),
  emits: {
    "group:selected": (t) => !0
  },
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = Ao(t, Kh);
    return () => {
      var a;
      return (a = n.default) == null ? void 0 : a.call(n, {
        isSelected: i.isSelected.value,
        select: i.select,
        toggle: i.toggle,
        selectedClass: i.selectedClass.value
      });
    };
  }
}), Lx = {
  __name: "BrandList",
  props: ["content", "info"],
  setup(t) {
    const e = wa();
    return (n, i) => (J(), Ce(gn, null, {
      default: H(() => [
        S(Kl, { "show-arrows": "" }, {
          prev: H(() => [
            S(Be, null, {
              default: H(() => i[0] || (i[0] = [
                ct("mdi-chevron-left", -1)
              ])),
              _: 1,
              __: [0]
            })
          ]),
          next: H(() => [
            S(Be, null, {
              default: H(() => i[1] || (i[1] = [
                ct("mdi-chevron-right", -1)
              ])),
              _: 1,
              __: [1]
            })
          ]),
          default: H(() => [
            (J(!0), Ie(pe, null, Ft(t.content.brands, (a, o) => (J(), Ce(zx, { key: o }, {
              default: H(() => [
                S(zo, {
                  height: W(e) ? 150 : 300,
                  width: W(e) ? 150 : 300,
                  class: "brand_item"
                }, {
                  default: H(() => [
                    S(nn, { src: a }, null, 8, ["src"])
                  ]),
                  _: 2
                }, 1032, ["height", "width"])
              ]),
              _: 2
            }, 1024))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}, Vx = /* @__PURE__ */ rn(Lx, [["__scopeId", "data-v-07e05de9"]]), Bx = ["innerHTML"], Fx = ["src"], kx = ["src"], Ox = ["innerHTML"], Dx = {
  __name: "Advantages",
  props: ["content", "info"],
  setup(t) {
    const { getText: e } = ri(), n = wa();
    return (i, a) => (J(), Ce(gn, null, {
      default: H(() => [
        w("h1", {
          style: re({ color: t.info.primaryColor }),
          innerHTML: W(e)(t.content.title) || "I nostri vantaggi"
        }, null, 12, Bx),
        (J(!0), Ie(pe, null, Ft(t.content.advantages, (o, r) => (J(), Ce(zo, {
          key: r,
          class: te(["margin_top__default", { "carousel--mobile": W(n) }]),
          elevation: "20"
        }, {
          default: H(() => [
            w("div", {
              class: te(["img-wrapper", { "mobile-height": W(n) }])
            }, [
              Array.isArray(o.image) ? (J(), Ce(ys, {
                key: 0,
                "show-arrows": "",
                "hide-delimiters": "",
                height: W(n) ? "400px" : "600px"
              }, {
                default: H(() => [
                  (J(!0), Ie(pe, null, Ft(o.image, (l, s) => (J(), Ce(Cs, { key: s }, {
                    default: H(() => [
                      w("img", {
                        src: W(Ni)(l),
                        class: "img"
                      }, null, 8, Fx)
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1032, ["height"])) : (J(), Ie("img", {
                key: 1,
                src: W(Ni)(o.image),
                class: "img"
              }, null, 8, kx))
            ], 2),
            S(tu, {
              style: { "white-space": "normal" },
              innerHTML: W(e)(o.name)
            }, null, 8, ["innerHTML"]),
            o.description ? (J(), Ce(nu, { key: 0 }, {
              default: H(() => [
                w("div", {
                  innerHTML: W(e)(o.description)
                }, null, 8, Ox)
              ]),
              _: 2
            }, 1024)) : Ae("", !0)
          ]),
          _: 2
        }, 1032, ["class"]))), 128))
      ]),
      _: 1
    }));
  }
}, Gx = /* @__PURE__ */ rn(Dx, [["__scopeId", "data-v-8395df3e"]]), Nx = U({
  color: String,
  ...vn(),
  ...ve(),
  ...ln(),
  ...Cn(),
  ...Dr(),
  ...Qs(),
  ...Tt(),
  ...Oe(),
  ...Ue()
}, "VSheet"), Wx = ee()({
  name: "VSheet",
  props: Nx(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      themeClasses: i
    } = et(t), {
      backgroundColorClasses: a,
      backgroundColorStyles: o
    } = xt(() => t.color), {
      borderClasses: r
    } = yn(t), {
      dimensionStyles: l
    } = sn(t), {
      elevationClasses: s
    } = pn(t), {
      locationStyles: u
    } = Gr(t), {
      positionClasses: c
    } = eu(t), {
      roundedClasses: d
    } = wt(t);
    return le(() => S(t.tag, {
      class: te(["v-sheet", i.value, a.value, r.value, s.value, c.value, d.value, t.class]),
      style: re([o.value, l.value, u.value, t.style])
    }, n)), {};
  }
}), $x = ["innerHTML"], Xx = ["innerHTML"], Ux = ["innerHTML"], Yx = ["href"], jx = "right", Hx = "bottom", Zx = {
  __name: "DualSection",
  props: ["content", "info"],
  setup(t) {
    const e = wa(), { getText: n } = ri(), i = E(() => (t.content.orientationDesktop || jx) === "left"), a = E(() => (t.content.orientationMobile || Hx) === "top"), o = E(() => e.value ? a.value : i.value);
    return (r, l) => (J(), Ce(gn, null, {
      default: H(() => [
        S(pa, { align: "center" }, {
          default: H(() => [
            o.value ? (J(), Ce(dn, {
              key: 0,
              cols: "12",
              md: "6"
            }, {
              default: H(() => [
                S(nn, {
                  src: W(Ni)(t.content.image),
                  cover: ""
                }, null, 8, ["src"])
              ]),
              _: 1
            })) : Ae("", !0),
            S(dn, {
              cols: "12",
              md: "6"
            }, {
              default: H(() => [
                S(Wx, { style: { "background-color": "transparent" } }, {
                  default: H(() => [
                    t.content.title ? (J(), Ie("p", {
                      key: 0,
                      class: "text-h3 font-weight-black",
                      style: re({ color: t.info.primaryColor + " !important" }),
                      innerHTML: W(n)(t.content.title)
                    }, null, 12, $x)) : Ae("", !0),
                    l[0] || (l[0] = w("br", null, null, -1)),
                    t.content.subtitle ? (J(), Ie("p", {
                      key: 1,
                      class: "text-subtitle-1 font-weight-black",
                      innerHTML: W(n)(t.content.subtitle) + "<br>"
                    }, null, 8, Xx)) : Ae("", !0),
                    t.content.description ? (J(), Ie("p", {
                      key: 2,
                      innerHTML: W(n)(t.content.description)
                    }, null, 8, Ux)) : Ae("", !0),
                    l[1] || (l[1] = w("br", null, null, -1)),
                    t.content.url && t.content.button ? (J(), Ie("a", {
                      key: 3,
                      href: t.content.url
                    }, [
                      S(At, {
                        innerHTML: W(n)(t.content.button),
                        class: "text-none",
                        variant: "flat",
                        color: t.info.primaryColor,
                        style: { marginTop: "7px" }
                      }, null, 8, ["innerHTML", "color"])
                    ], 8, Yx)) : Ae("", !0)
                  ]),
                  _: 1,
                  __: [0, 1]
                })
              ]),
              _: 1
            }),
            o.value ? Ae("", !0) : (J(), Ce(dn, {
              key: 1,
              cols: "12",
              md: "6"
            }, {
              default: H(() => [
                S(nn, {
                  src: W(Ni)(t.content.image),
                  cover: ""
                }, null, 8, ["src"])
              ]),
              _: 1
            }))
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}, Pm = {
  __name: "Home",
  setup(t) {
    const { getAncor: e } = ri(), n = kn(), { data: i } = tn(n), a = {
      map: jM,
      blog: JM,
      line: QM,
      gallery: cx,
      services: Cx,
      contacts: Ix,
      brandlist: Vx,
      advantages: Gx,
      dualSection: Zx
    }, o = i.value.addOn, r = i.value.info, l = E(() => i.value.components.filter((s) => s.type === "blog" ? o == null ? void 0 : o.some((u) => u.toLowerCase() === "blog") : !0));
    return m_({
      title: "FastSite",
      meta: [
        { name: "FastSite", content: "This is the home page" }
      ]
    }), (s, u) => (J(!0), Ie(pe, null, Ft(l.value, (c) => (J(), Ce(qd(a[c.type]), {
      id: W(e)(c.menu) ? W(e)(c.menu).toLowerCase() : null,
      content: c.content,
      info: W(r)
    }, null, 8, ["id", "content", "info"]))), 256));
  }
}, Kx = ["href"], qx = {
  __name: "SocialBubbles",
  props: {
    chattyActive: Boolean
  },
  setup(t) {
    const e = kn(), { data: n } = tn(e), i = n.value.info, a = i.socialBubbles;
    return (o, r) => (J(!0), Ie(pe, null, Ft(W(a), (l, s) => (J(), Ie("div", {
      key: s,
      class: "social-container shadown",
      style: re({
        bottom: `${(t.chattyActive ? 100 : 20) + s * 70}px`,
        backgroundColor: "transparent"
      })
    }, [
      w("a", {
        href: l.url,
        target: "_blank",
        rel: "noopener noreferrer"
      }, [
        S(At, {
          icon: l.icon,
          style: re({ backgroundColor: W(i).primaryColor, color: "#fff" }),
          size: "x-large"
        }, null, 8, ["icon", "style"])
      ], 8, Kx)
    ], 4))), 128));
  }
}, Tm = /* @__PURE__ */ rn(qx, [["__scopeId", "data-v-8ea47031"]]), Jx = U({
  ...ve(),
  ...Lp({
    fullHeight: !0
  }),
  ...Ue()
}, "VApp"), wm = ee()({
  name: "VApp",
  props: Jx(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const i = et(t), {
      layoutClasses: a,
      getLayoutItem: o,
      items: r,
      layoutRef: l
    } = Fp(t), {
      rtlClasses: s
    } = Wt();
    return le(() => {
      var u;
      return w("div", {
        ref: l,
        class: te(["v-application", i.themeClasses.value, a.value, s.value, t.class]),
        style: re([t.style])
      }, [w("div", {
        class: "v-application__wrap"
      }, [(u = n.default) == null ? void 0 : u.call(n)])]);
    }), {
      getLayoutItem: o,
      items: r,
      theme: i
    };
  }
}), Qx = U({
  scrollable: Boolean,
  ...ve(),
  ...ln(),
  ...Oe({
    tag: "main"
  })
}, "VMain"), Em = ee()({
  name: "VMain",
  props: Qx(),
  setup(t, e) {
    let {
      slots: n
    } = e;
    const {
      dimensionStyles: i
    } = sn(t), {
      mainStyles: a
    } = Vp(), {
      ssrBootStyles: o
    } = Io();
    return le(() => S(t.tag, {
      class: te(["v-main", {
        "v-main--scrollable": t.scrollable
      }, t.class]),
      style: re([a.value, o.value, i.value, t.style])
    }, {
      default: () => {
        var r, l;
        return [t.scrollable ? w("div", {
          class: "v-main__scroller"
        }, [(r = n.default) == null ? void 0 : r.call(n)]) : (l = n.default) == null ? void 0 : l.call(n)];
      }
    })), {};
  }
}), oP = {
  __name: "DemoLayout",
  props: {
    json: Object
  },
  setup(t) {
    const e = Z(!1), n = Z(!1), i = kn(), { data: a, ready: o } = tn(i), r = t, l = E(() => a.value.info.backgroundImage ? {
      backgroundImage: `url(${a.value.info.backgroundImage})`,
      backgroundSize: "cover",
      backgroundPosition: "center",
      backgroundRepeat: "no-repeat"
    } : {
      backgroundColor: a.value.info.secondaryColor
    });
    return at(() => {
      i.initDataByJson(r.json);
    }), ie(o, (s) => {
      if (!s) return;
      const u = a.value.addOn;
      if (u && u.includes("Chatty")) {
        const c = document.createElement("script");
        c.type = "module", c.src = `https://chatty-be.replit.app/chat-file/js?file=inject&user_id=${a.value.info.chattyId}`, document.body.appendChild(c), c.onload = () => {
          e.value = !0;
        }, c.onerror = () => {
          e.value = !1;
        };
      }
      a.value.info.socialBubbles && (n.value = !0);
    }), (s, u) => W(o) ? (J(), Ce(wm, { key: 0 }, {
      default: H(() => [
        S(qf),
        n.value ? Ae("", !0) : (J(), Ce(nh, {
          key: 0,
          bottomOffset: e.value ? 100 : 20
        }, null, 8, ["bottomOffset"])),
        n.value ? (J(), Ce(Tm, {
          key: 1,
          chattyActive: e.value
        }, null, 8, ["chattyActive"])) : Ae("", !0),
        S(Em, {
          style: re(l.value)
        }, {
          default: H(() => [
            S(Pm)
          ]),
          _: 1
        }, 8, ["style"]),
        S(Jf)
      ]),
      _: 1
    })) : Ae("", !0);
  }
}, rP = {
  __name: "DemoViewLayout",
  props: {
    hostname: String,
    id: Number
  },
  setup(t) {
    const e = Z(!1), n = Z(!1), i = kn(), { data: a, ready: o } = tn(i), r = t, l = E(() => a.value.info.backgroundImage ? {
      backgroundImage: `url(${a.value.info.backgroundImage})`,
      backgroundSize: "cover",
      backgroundPosition: "center",
      backgroundRepeat: "no-repeat"
    } : {
      backgroundColor: a.value.info.secondaryColor
    });
    return at(() => {
      i.initDataByDemoLayout(r.hostname, r.id);
    }), ie(o, (s) => {
      if (!s) return;
      const u = a.value.addOn;
      if (u && u.includes("Chatty")) {
        const c = document.createElement("script");
        c.type = "module", c.src = `https://chatty-be.replit.app/chat-file/js?file=inject&user_id=${a.value.info.chattyId}`, document.body.appendChild(c), c.onload = () => {
          e.value = !0;
        }, c.onerror = () => {
          e.value = !1;
        };
      }
      a.value.info.socialBubbles && (n.value = !0);
    }), (s, u) => W(o) ? (J(), Ce(wm, { key: 0 }, {
      default: H(() => [
        S(qf),
        n.value ? Ae("", !0) : (J(), Ce(nh, {
          key: 0,
          bottomOffset: e.value ? 100 : 20
        }, null, 8, ["bottomOffset"])),
        n.value ? (J(), Ce(Tm, {
          key: 1,
          chattyActive: e.value
        }, null, 8, ["chattyActive"])) : Ae("", !0),
        S(Em, {
          style: re(l.value)
        }, {
          default: H(() => [
            S(Pm)
          ]),
          _: 1
        }, 8, ["style"]),
        S(Jf)
      ]),
      _: 1
    })) : Ae("", !0);
  }
};
export {
  oP as DemoLayout,
  rP as DemoViewLayout
};
